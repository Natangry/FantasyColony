# Auto-generated code snapshot
_Updated_: 2025-08-31 07:02:33 UTC

// ===== FILE: Assets/Editor/SpriteImportDefaults.cs =====
// Editor-only: ensures sprites import with our project defaults (hi-res, crisp pixels).
// - Applies automatically to any texture under a folder named "Sprites" (e.g. Assets/Resources/Sprites/)
// - Adds menu items to (re)apply settings to selected textures or an entire folder
//
// Defaults:
//   TextureType: Sprite (2D and UI)
//   SpriteMode: Single
//   Pixels Per Unit: 64
//   Filter Mode: Point (no filter)
//   Compression: None (Uncompressed)
//   Wrap Mode: Clamp
//   MipMaps: Off
//   sRGB: On
//   Alpha Is Transparency: On (where supported)
//   Pivot: Bottom-Center (0.5, 0.0)

#if UNITY_EDITOR
using System;
using System.Linq;
using UnityEditor;
using UnityEngine;
using System.Reflection;

namespace FantasyColony.EditorTools
{
    public class SpriteImportDefaults : AssetPostprocessor
    {
        const float DefaultPPU = 64f;
        const int   DefaultMaxSize = 1024;

        static bool IsSpritePath(string path)
        {
            if (string.IsNullOrEmpty(path)) return false;
            path = path.Replace('\\', '/').ToLowerInvariant();
            return path.Contains("/sprites/");
        }

        void OnPreprocessTexture()
        {
            if (!IsSpritePath(assetPath)) return;
            var ti = (TextureImporter)assetImporter;
            ApplyDefaults(ti);
        }

        static void ApplyDefaults(TextureImporter ti)
        {
            ti.textureType = TextureImporterType.Sprite;
            ti.spriteImportMode = SpriteImportMode.Single;
            ti.spritePixelsPerUnit = DefaultPPU;
            ti.mipmapEnabled = false;
            ti.filterMode = FilterMode.Point;
            ti.textureCompression = TextureImporterCompression.Uncompressed;
            ti.wrapMode = TextureWrapMode.Clamp;
            ti.maxTextureSize = DefaultMaxSize;

            // Color space & alpha handling
#if UNITY_2019_3_OR_NEWER
            ti.sRGBTexture = true;
#endif
#if !UNITY_2023_1_OR_NEWER
            // In newer versions this field may be hidden/ignored, but it's safe to set where available.
            ti.alphaIsTransparency = true;
#endif
#if UNITY_2021_2_OR_NEWER
            ti.alphaSource = TextureImporterAlphaSource.FromInput;
#endif

            // Pivot: Bottom-Center (Unity 6 removed 'spriteAlignment'; set via spritePivot and
            // use reflection to set alignment to Custom when property exists on older versions)
            SetPivotBottomCenter(ti);
        }

        static void SetPivotBottomCenter(TextureImporter ti)
        {
            // Always set explicit pivot
            ti.spritePivot = new Vector2(0.5f, 0f);

            // Try to set alignment to Custom when the legacy property exists
            try
            {
                var prop = typeof(TextureImporter).GetProperty("spriteAlignment",
                    BindingFlags.Public | BindingFlags.Instance);
                if (prop != null && prop.CanWrite)
                {
                    var enumType = prop.PropertyType;
                    object customVal = null;
                    // If type is an enum that defines "Custom", use it; otherwise fall back to 9
                    if (enumType.IsEnum && Enum.GetNames(enumType).Contains("Custom"))
                        customVal = Enum.Parse(enumType, "Custom");
                    else
                        customVal = Convert.ChangeType(9, enumType); // 9 == SpriteAlignment.Custom in legacy

                    prop.SetValue(ti, customVal);
                }
            }
            catch
            {
                // Safe no-op on newer Unity versions
            }
        }

        // --- Context menus ---------------------------------------------------

        [MenuItem("Assets/Sprites/Apply Sprite Defaults (64 PPU)", true)]
        static bool ValidateApplyToSelection()
        {
            return Selection.assetGUIDs != null && Selection.assetGUIDs.Length > 0;
        }

        [MenuItem("Assets/Sprites/Apply Sprite Defaults (64 PPU)")]
        static void ApplyToSelection()
        {
            int count = 0;
            foreach (var guid in Selection.assetGUIDs)
            {
                var path = AssetDatabase.GUIDToAssetPath(guid);
                if (string.IsNullOrEmpty(path)) continue;
                if (!IsSpritePath(path)) continue;
                var ti = AssetImporter.GetAtPath(path) as TextureImporter;
                if (ti == null) continue;
                ApplyDefaults(ti);
                AssetDatabase.ImportAsset(path, ImportAssetOptions.ForceUpdate);
                count++;
            }
            Debug.Log($"[SpriteImportDefaults] Applied to {count} asset(s).");
        }

        [MenuItem("Assets/Sprites/Apply Defaults To Folder (recursive)", true)]
        static bool ValidateApplyToFolder()
        {
            // Enable when a folder is selected
            return Selection.assetGUIDs.Any(guid =>
            {
                var path = AssetDatabase.GUIDToAssetPath(guid);
                return AssetDatabase.IsValidFolder(path);
            });
        }

        [MenuItem("Assets/Sprites/Apply Defaults To Folder (recursive)")]
        static void ApplyToFolder()
        {
            int total = 0;
            foreach (var guid in Selection.assetGUIDs)
            {
                var folder = AssetDatabase.GUIDToAssetPath(guid);
                if (!AssetDatabase.IsValidFolder(folder)) continue;
                var guids = AssetDatabase.FindAssets("t:Texture2D", new[] { folder });
                foreach (var texGuid in guids)
                {
                    var path = AssetDatabase.GUIDToAssetPath(texGuid);
                    if (!IsSpritePath(path)) continue;
                    var ti = AssetImporter.GetAtPath(path) as TextureImporter;
                    if (ti == null) continue;
                    ApplyDefaults(ti);
                    AssetDatabase.ImportAsset(path, ImportAssetOptions.ForceUpdate);
                    total++;
                }
            }
            Debug.Log($"[SpriteImportDefaults] Applied to {total} asset(s) in folder(s).");
        }
    }
}
#endif

// ===== FILE: Assets/Scripts/Core/AppBootstrap.cs =====
using UnityEngine;

namespace FantasyColony.Core
{
    /// <summary>
    /// Single entry point. We don't rely on authored Unity scenes; everything is spawned at runtime.
    /// </summary>
    public static class AppBootstrap
    {
        [RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.AfterSceneLoad)]
        private static void Boot()
        {
            // Root host object that survives for the whole app lifetime.
            var root = new GameObject("AppRoot");
            Object.DontDestroyOnLoad(root);
            root.AddComponent<AppHost>();
        }
    }
}

// ===== FILE: Assets/Scripts/Core/AppHost.cs =====
using UnityEngine;
using FantasyColony.UI.Root;
using FantasyColony.UI.Router;
using FantasyColony.Core.Services;

// Disambiguate our service interfaces from Unity's similarly named types
using FCLogger = FantasyColony.Core.Services.ILogger;
using FCFileLogger = FantasyColony.Core.Services.FileLogger;
using FCConfigService = FantasyColony.Core.Services.IConfigService;
using FCDummyConfig = FantasyColony.Core.Services.DummyConfigService;
using FCEventBus = FantasyColony.Core.Services.IEventBus;
using FCSimpleEventBus = FantasyColony.Core.Services.SimpleEventBus;
using FCAssetProvider = FantasyColony.Core.Services.IAssetProvider;
using FCResourcesProvider = FantasyColony.Core.Services.ResourcesAssetProvider;

namespace FantasyColony.Core
{
    /// <summary>
    /// Lifetime owner. Builds services, creates UIRoot and pushes Main Menu screen.
    /// </summary>
    public class AppHost : MonoBehaviour
    {
        private ServiceRegistry _services;
        private UIRoot _uiRoot;
        private UIRouter _router;

        private void Awake()
        {
            Application.targetFrameRate = 60;
            QualitySettings.vSyncCount = 0;

            _services = new ServiceRegistry();
            _services.Register<FCLogger>(new FCFileLogger());
            _services.Register<FCConfigService>(new FCDummyConfig());
            _services.Register<FCEventBus>(new FCSimpleEventBus());
            _services.Register<FCAssetProvider>(new FCResourcesProvider());

            // Create UI root (Canvas + EventSystem)
            _uiRoot = UIRoot.Create(transform);

            // Router mounts screens under UIRoot
            _router = new UIRouter(_uiRoot.ScreenParent, _services);

            // Push Main Menu
            _router.Push<FantasyColony.UI.Screens.MainMenuScreen>();
        }
    }
}

// ===== FILE: Assets/Scripts/Core/ServiceRegistry.cs =====
using System;
using System.Collections.Generic;

namespace FantasyColony.Core
{
    public sealed class ServiceRegistry
    {
        private readonly Dictionary<Type, object> _map = new();

        public void Register<T>(T impl) where T : class
        {
            _map[typeof(T)] = impl ?? throw new ArgumentNullException(nameof(impl));
        }

        public T Get<T>() where T : class
        {
            if (_map.TryGetValue(typeof(T), out var o) && o is T t)
                return t;
            throw new InvalidOperationException($"Service not registered: {typeof(T).Name}");
        }
    }
}

// ===== FILE: Assets/Scripts/Core/Services/IAssetProvider.cs =====
using UnityEngine;

namespace FantasyColony.Core.Services
{
    public interface IAssetProvider
    {
        Sprite LoadSprite(string virtualPath);
        AudioClip LoadAudio(string virtualPath);
    }

    public sealed class ResourcesAssetProvider : IAssetProvider
    {
        public Sprite LoadSprite(string virtualPath)
        {
            return Resources.Load<Sprite>(virtualPath);
        }

        public AudioClip LoadAudio(string virtualPath)
        {
            return Resources.Load<AudioClip>(virtualPath);
        }
    }
}

// ===== FILE: Assets/Scripts/Core/Services/IConfigService.cs =====
namespace FantasyColony.Core.Services
{
    public interface IConfigService
    {
        string Get(string key, string fallback = "");
        void Set(string key, string value);
        void Save();
    }

    /// <summary>
    /// Minimal no-op config for early boot. Replace later with a JSON-backed service.
    /// </summary>
    public sealed class DummyConfigService : IConfigService
    {
        public string Get(string key, string fallback = "") => fallback;
        public void Set(string key, string value) { }
        public void Save() { }
    }
}

// ===== FILE: Assets/Scripts/Core/Services/IEventBus.cs =====
using System;
using System.Collections.Generic;

namespace FantasyColony.Core.Services
{
    public interface IEventBus
    {
        void Subscribe<T>(Action<T> handler);
        void Unsubscribe<T>(Action<T> handler);
        void Publish<T>(T evt);
    }

    public sealed class SimpleEventBus : IEventBus
    {
        private readonly Dictionary<Type, Delegate> _subs = new();

        public void Subscribe<T>(Action<T> handler)
        {
            if (_subs.TryGetValue(typeof(T), out var d))
                _subs[typeof(T)] = Delegate.Combine(d, handler);
            else
                _subs[typeof(T)] = handler;
        }

        public void Unsubscribe<T>(Action<T> handler)
        {
            if (_subs.TryGetValue(typeof(T), out var d))
            {
                var res = Delegate.Remove(d, handler);
                if (res == null) _subs.Remove(typeof(T));
                else _subs[typeof(T)] = res;
            }
        }

        public void Publish<T>(T evt)
        {
            if (_subs.TryGetValue(typeof(T), out var d) && d is Action<T> a)
            {
                a.Invoke(evt);
            }
        }
    }
}

// ===== FILE: Assets/Scripts/Core/Services/ILogger.cs =====
using System;
using System.IO;
using UnityEngine;

namespace FantasyColony.Core.Services
{
    public interface ILogger
    {
        void Info(string msg);
        void Warn(string msg);
        void Error(string msg, Exception ex = null);
    }

    public sealed class FileLogger : ILogger
    {
        private readonly string _path;

        public FileLogger()
        {
            var dir = Path.Combine(UnityEngine.Application.persistentDataPath, "logs");
            if (!Directory.Exists(dir)) Directory.CreateDirectory(dir);
            _path = Path.Combine(dir, $"log_{DateTime.Now:yyyyMMdd_HHmmss}.txt");
            Info($"FantasyColony boot {UnityEngine.Application.version} Unity {UnityEngine.Application.unityVersion}");
        }

        public void Info(string msg)
        {
            Debug.Log(msg);
            Append("INFO", msg);
        }

        public void Warn(string msg)
        {
            Debug.LogWarning(msg);
            Append("WARN", msg);
        }

        public void Error(string msg, Exception ex = null)
        {
            Debug.LogError(msg);
            if (ex != null) msg += "\n" + ex;
            Append("ERROR", msg);
        }

        private void Append(string level, string msg)
        {
            try
            {
                File.AppendAllText(_path, $"[{DateTime.Now:HH:mm:ss}] {level} {msg}\n");
            }
            catch { /* ignore logging failures */ }
        }
    }
}

// ===== FILE: Assets/Scripts/UI/Root/UIRoot.cs =====
using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.UI;

namespace FantasyColony.UI.Root
{
    public sealed class UIRoot : MonoBehaviour
    {
        public RectTransform ScreenParent { get; private set; }

        public static UIRoot Create(Transform parent)
        {
            var go = new GameObject("UIRoot");
            go.transform.SetParent(parent, false);
            var root = go.AddComponent<UIRoot>();
            root.Build();
            return root;
        }

        private void Build()
        {
            // Canvas
            var canvasGO = new GameObject("Canvas");
            canvasGO.transform.SetParent(transform, false);
            var canvas = canvasGO.AddComponent<Canvas>();
            canvas.renderMode = RenderMode.ScreenSpaceOverlay;
            canvasGO.AddComponent<GraphicRaycaster>();

            var scaler = canvasGO.AddComponent<CanvasScaler>();
            scaler.uiScaleMode = CanvasScaler.ScaleMode.ScaleWithScreenSize;
            scaler.referenceResolution = new Vector2(1920, 1080);
            scaler.matchWidthOrHeight = 0.5f;

            // EventSystem if missing
            bool hasEventSystem = EventSystem.current != null;
#if UNITY_2023_1_OR_NEWER
            if (!hasEventSystem)
            {
                hasEventSystem = (Object.FindFirstObjectByType<EventSystem>() != null);
            }
#else
            if (!hasEventSystem)
            {
                hasEventSystem = (FindObjectOfType<EventSystem>() != null);
            }
#endif

            if (!hasEventSystem)
            {
                var es = new GameObject("EventSystem");
                es.AddComponent<EventSystem>();
                es.AddComponent<StandaloneInputModule>();
            }

            // Screen parent
            var screenParentGO = new GameObject("Screens");
            screenParentGO.transform.SetParent(canvasGO.transform, false);
            ScreenParent = screenParentGO.AddComponent<RectTransform>();
            ScreenParent.anchorMin = Vector2.zero;
            ScreenParent.anchorMax = Vector2.one;
            ScreenParent.offsetMin = Vector2.zero;
            ScreenParent.offsetMax = Vector2.zero;
        }
    }
}

// ===== FILE: Assets/Scripts/UI/Router/IScreen.cs =====
using UnityEngine;

namespace FantasyColony.UI.Router
{
    public interface IScreen
    {
        void Enter(Transform parent);
        void Exit();
    }

    public abstract class UIScreenBase : IScreen
    {
        protected RectTransform Root;
        public abstract void Enter(Transform parent);
        public abstract void Exit();
    }
}

// ===== FILE: Assets/Scripts/UI/Router/UIRouter.cs =====
using System;
using System.Collections.Generic;
using UnityEngine;
using FantasyColony.Core;

namespace FantasyColony.UI.Router
{
    public sealed class UIRouter
    {
        private readonly Transform _parent;
        private readonly ServiceRegistry _services;
        private readonly Stack<IScreen> _stack = new();

        public UIRouter(Transform parent, ServiceRegistry services)
        {
            _parent = parent;
            _services = services;
        }

        public void Push<T>() where T : IScreen, new()
        {
            var screen = new T();
            screen.Enter(_parent);
            _stack.Push(screen);
        }

        public void Pop()
        {
            if (_stack.Count == 0) return;
            var top = _stack.Pop();
            top.Exit();
        }
    }
}

// ===== FILE: Assets/Scripts/UI/Screens/MainMenuScreen.cs =====
using UnityEngine;
using UnityEngine.UI;
using FantasyColony.UI.Router;
using FantasyColony.UI.Widgets;
using FantasyColony.UI.Style;
using FantasyColony.Core.Services;

namespace FantasyColony.UI.Screens
{
    /// <summary>
    /// Main Menu (non-functional for now). Uses Base UI Style, bottom-right vertical stack.
    /// Order: Log, Start, Continue, Load, Options, Mods, Creator, Restart, Quit
    /// </summary>
    public sealed class MainMenuScreen : UIScreenBase
    {
        public override void Enter(Transform parent)
        {
            // Root
            var go = new GameObject("MainMenu", typeof(RectTransform));
            Root = go.GetComponent<RectTransform>();
            Root.SetParent(parent, false);
            Root.anchorMin = Vector2.zero;
            Root.anchorMax = Vector2.one;
            Root.offsetMin = Vector2.zero;
            Root.offsetMax = Vector2.zero;

            // Background (image if present, else solid)
            var bgSprite = Resources.Load<Sprite>("ui/menu/main_menu_bg");
            UIFactory.CreateFullscreenBackground(Root, bgSprite, new Color32(18, 15, 12, 255));

            // Panel stack (bottom-right)
            var panel = UIFactory.CreateBottomRightStack(Root, "MenuPanel");
            // Make panel background transparent (no shadow panel), keep layout behavior
            var panelImg = panel.GetComponent<Image>();
            if (panelImg)
            {
                panelImg.color = new Color(0,0,0,0);
                panelImg.raycastTarget = false; // do not block button mouse events
            }
            panel.SetAsLastSibling();

            // Buttons (log "Not implemented")
            void NotImpl(string name) => Debug.Log($"BUTTON: {name} (not implemented)");

            UIFactory.CreateButtonSecondary(panel, "Log",        () => NotImpl("Log"));
            UIFactory.CreateButtonPrimary(panel,   "Start",      () => NotImpl("Start"));
            var btnContinue = UIFactory.CreateButtonSecondary(panel, "Continue", () => NotImpl("Continue"));
            var btnLoad     = UIFactory.CreateButtonSecondary(panel, "Load",     () => NotImpl("Load"));
            UIFactory.CreateButtonSecondary(panel, "Options",    () => NotImpl("Options"));
            UIFactory.CreateButtonSecondary(panel, "Mods",       () => NotImpl("Mods"));
            UIFactory.CreateButtonSecondary(panel, "Creator",    () => NotImpl("Creator"));
            UIFactory.CreateButtonSecondary(panel, "Restart",    () => NotImpl("Restart"));
            UIFactory.CreateButtonDanger(panel,     "Quit",      () => NotImpl("Quit"));

            // Disabled rules for now (no save system yet)
            btnContinue.interactable = false;
            btnLoad.interactable = false;
        }

        public override void Exit()
        {
            if (Root != null)
            {
                Object.Destroy(Root.gameObject);
                Root = null;
            }
        }
    }
}

// ===== FILE: Assets/Scripts/UI/Style/BaseUIStyle.cs =====
using UnityEngine;

namespace FantasyColony.UI.Style
{
    public static class BaseUIStyle
    {
        // Colors
        public static Color32 Gold            = Hex("#D6B25E");
        public static Color32 GoldHover       = Hex("#E4C77D");
        public static Color32 GoldPressed     = Hex("#B99443");
        public static Color32 PanelSurface    = new Color32(0x1F,0x1A,0x14, (byte)(0.95f * 255));
        public static Color32 SecondaryFill   = Hex("#2A231B");
        public static Color32 Keyline         = new Color32(0x5A,0x4C,0x38, (byte)(0.60f * 255));
        public static Color32 TextPrimary     = Hex("#F1E9D2");
        public static Color32 TextSecondary   = Hex("#C9BDA2");
        public static Color32 Danger          = Hex("#B34844");
        public static Color32 DangerHover     = Hex("#C8625E");
        public static Color32 DangerPressed   = Hex("#953A37");

        // Sizes
        public const int ButtonHeight = 56;
        public const int ButtonFontSize = 24;
        public const int BodyFontSize = 20;
        public const int CaptionFontSize = 18;
        public const int PanelPadding = 24;
        public const int StackSpacing = 12;
        public const int EdgeOffset = 56;

        public static Color32 Hex(string hex)
        {
            if (ColorUtility.TryParseHtmlString(hex, out var c))
                return c;
            return Color.white;
        }
    }
}

// ===== FILE: Assets/Scripts/UI/Widgets/UIFactory.cs =====
using UnityEngine;
using UnityEngine.UI;
using FantasyColony.UI.Style;
using System;

namespace FantasyColony.UI.Widgets
{
    public static class UIFactory
    {
        // PANEL
        public static RectTransform CreatePanelSurface(Transform parent, string name = "Panel")
        {
            var go = new GameObject(name, typeof(RectTransform), typeof(CanvasRenderer), typeof(Image), typeof(VerticalLayoutGroup), typeof(ContentSizeFitter));
            go.transform.SetParent(parent, false);
            var rt = go.GetComponent<RectTransform>();
            var img = go.GetComponent<Image>();
            img.color = BaseUIStyle.PanelSurface;

            var layout = go.GetComponent<VerticalLayoutGroup>();
            layout.spacing = BaseUIStyle.StackSpacing;
            layout.padding = new RectOffset(BaseUIStyle.PanelPadding, BaseUIStyle.PanelPadding, BaseUIStyle.PanelPadding, BaseUIStyle.PanelPadding);
            // Ensure children (buttons) get proper space and panel wraps to content reliably
            layout.childControlWidth = true;
            layout.childControlHeight = true;
            layout.childForceExpandWidth = false;
            layout.childForceExpandHeight = false;

            var fitter = go.GetComponent<ContentSizeFitter>();
            fitter.horizontalFit = ContentSizeFitter.FitMode.PreferredSize;
            fitter.verticalFit = ContentSizeFitter.FitMode.PreferredSize;
            return rt;
        }

        // BUTTONS
        public static Button CreateButtonPrimary(Transform parent, string label, Action onClick) =>
            CreateButton(parent, label, BaseUIStyle.Gold, BaseUIStyle.TextSecondary, onClick);

        public static Button CreateButtonSecondary(Transform parent, string label, Action onClick) =>
            CreateButton(parent, label, BaseUIStyle.SecondaryFill, BaseUIStyle.TextPrimary, onClick);

        public static Button CreateButtonDanger(Transform parent, string label, Action onClick) =>
            CreateButton(parent, label, BaseUIStyle.Danger, BaseUIStyle.TextSecondary, onClick, isDanger:true);

        private static Button CreateButton(Transform parent, string label, Color fill, Color textColor, Action onClick, bool isDanger = false)
        {
            var go = new GameObject($"Button_{label}", typeof(RectTransform), typeof(CanvasRenderer), typeof(Image), typeof(Button), typeof(LayoutElement));
            go.transform.SetParent(parent, false);
            var rt = go.GetComponent<RectTransform>();
            rt.sizeDelta = new Vector2(380, BaseUIStyle.ButtonHeight);

            var img = go.GetComponent<Image>();
            img.color = fill;

            var btn = go.GetComponent<Button>();
            btn.targetGraphic = img; // ensure transitions target our Image
            btn.transition = Selectable.Transition.ColorTint;
            var colors = btn.colors;
            colors.normalColor = fill;
            // Stronger deltas for clearer feedback
            colors.highlightedColor = isDanger ? BaseUIStyle.DangerHover : (fill == BaseUIStyle.Gold ? BaseUIStyle.GoldHover : Multiply(fill, 1.15f));
            colors.pressedColor    = isDanger ? BaseUIStyle.DangerPressed : (fill == BaseUIStyle.Gold ? BaseUIStyle.GoldPressed : Multiply(fill, 0.80f));
            colors.selectedColor   = colors.highlightedColor;
            colors.disabledColor   = new Color(fill.r, fill.g, fill.b, 0.35f);
            colors.colorMultiplier = 1f;
            btn.colors = colors;
            btn.fadeDuration = 0.08f;
            btn.onClick.AddListener(() => onClick?.Invoke());

            // Layout sizing so buttons are visible in the stack
            var le = go.GetComponent<LayoutElement>();
            le.preferredWidth = 420;
            le.minHeight = BaseUIStyle.ButtonHeight;
            le.flexibleWidth = 0; le.flexibleHeight = 0;

            // Label
            var textGO = new GameObject("Label", typeof(RectTransform), typeof(CanvasRenderer), typeof(Text));
            textGO.transform.SetParent(go.transform, false);
            var trt = textGO.GetComponent<RectTransform>();
            trt.anchorMin = new Vector2(0, 0);
            trt.anchorMax = new Vector2(1, 1);
            trt.offsetMin = new Vector2(16, 0);
            trt.offsetMax = new Vector2(-16, 0);

            var txt = textGO.GetComponent<Text>();
            txt.text = label;
            txt.alignment = TextAnchor.MiddleLeft;
            txt.fontSize = BaseUIStyle.ButtonFontSize;
            txt.color = textColor;
            // Use default Arial to avoid TMP dependency; can swap later.
            txt.font = Resources.GetBuiltinResource<Font>("Arial.ttf");

            return btn;
        }

        // STACK CONTAINER (Bottom-right MenuPanel)
        public static RectTransform CreateBottomRightStack(Transform parent, string name = "MenuPanel")
        {
            var panel = CreatePanelSurface(parent, name);
            panel.anchorMin = new Vector2(1, 0);
            panel.anchorMax = new Vector2(1, 0);
            panel.pivot = new Vector2(1, 0);
            panel.anchoredPosition = new Vector2(-BaseUIStyle.EdgeOffset, BaseUIStyle.EdgeOffset);

            var layout = panel.GetComponent<VerticalLayoutGroup>();
            layout.childAlignment = TextAnchor.UpperCenter;

            var le = panel.GetComponent<LayoutElement>();
            if (le == null) le = panel.gameObject.AddComponent<LayoutElement>();
            le.preferredWidth = 420;
            le.flexibleWidth = 0;
            return panel;
        }

        // BACKGROUND IMAGE (full screen)
        public static Image CreateFullscreenBackground(Transform parent, Sprite sprite, Color fallbackColor)
        {
            var go = new GameObject("Background", typeof(RectTransform), typeof(CanvasRenderer), typeof(Image));
            go.transform.SetParent(parent, false);
            var rt = go.GetComponent<RectTransform>();
            rt.anchorMin = Vector2.zero;
            rt.anchorMax = Vector2.one;
            rt.offsetMin = Vector2.zero;
            rt.offsetMax = Vector2.zero;
            var img = go.GetComponent<Image>();
            if (sprite != null)
            {
                img.sprite = sprite;
                img.preserveAspect = true; // Background should not intercept clicks
                img.color = Color.white;
            }
            else
            {
                img.color = fallbackColor;
            }
            img.raycastTarget = false; // never block UI
            return img;
        }

        private static Color Multiply(Color c, float f) => new Color(c.r * f, c.g * f, c.b * f, c.a);
    }
}

// ===== FILE: Assets/TutorialInfo/Scripts/Editor/ReadmeEditor.cs =====
﻿using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEditor;
using System;
using System.IO;
using System.Reflection;

[CustomEditor(typeof(Readme))]
[InitializeOnLoad]
public class ReadmeEditor : Editor
{
    static string s_ShowedReadmeSessionStateName = "ReadmeEditor.showedReadme";
    
    static string s_ReadmeSourceDirectory = "Assets/TutorialInfo";

    const float k_Space = 16f;

    static ReadmeEditor()
    {
        EditorApplication.delayCall += SelectReadmeAutomatically;
    }

    static void RemoveTutorial()
    {
        if (EditorUtility.DisplayDialog("Remove Readme Assets",
            
            $"All contents under {s_ReadmeSourceDirectory} will be removed, are you sure you want to proceed?",
            "Proceed",
            "Cancel"))
        {
            if (Directory.Exists(s_ReadmeSourceDirectory))
            {
                FileUtil.DeleteFileOrDirectory(s_ReadmeSourceDirectory);
                FileUtil.DeleteFileOrDirectory(s_ReadmeSourceDirectory + ".meta");
            }
            else
            {
                Debug.Log($"Could not find the Readme folder at {s_ReadmeSourceDirectory}");
            }

            var readmeAsset = SelectReadme();
            if (readmeAsset != null)
            {
                var path = AssetDatabase.GetAssetPath(readmeAsset);
                FileUtil.DeleteFileOrDirectory(path + ".meta");
                FileUtil.DeleteFileOrDirectory(path);
            }

            AssetDatabase.Refresh();
        }
    }

    static void SelectReadmeAutomatically()
    {
        if (!SessionState.GetBool(s_ShowedReadmeSessionStateName, false))
        {
            var readme = SelectReadme();
            SessionState.SetBool(s_ShowedReadmeSessionStateName, true);

            if (readme && !readme.loadedLayout)
            {
                LoadLayout();
                readme.loadedLayout = true;
            }
        }
    }

    static void LoadLayout()
    {
        var assembly = typeof(EditorApplication).Assembly;
        var windowLayoutType = assembly.GetType("UnityEditor.WindowLayout", true);
        var method = windowLayoutType.GetMethod("LoadWindowLayout", BindingFlags.Public | BindingFlags.Static);
        method.Invoke(null, new object[] { Path.Combine(Application.dataPath, "TutorialInfo/Layout.wlt"), false });
    }

    static Readme SelectReadme()
    {
        var ids = AssetDatabase.FindAssets("Readme t:Readme");
        if (ids.Length == 1)
        {
            var readmeObject = AssetDatabase.LoadMainAssetAtPath(AssetDatabase.GUIDToAssetPath(ids[0]));

            Selection.objects = new UnityEngine.Object[] { readmeObject };

            return (Readme)readmeObject;
        }
        else
        {
            Debug.Log("Couldn't find a readme");
            return null;
        }
    }

    protected override void OnHeaderGUI()
    {
        var readme = (Readme)target;
        Init();

        var iconWidth = Mathf.Min(EditorGUIUtility.currentViewWidth / 3f - 20f, 128f);

        GUILayout.BeginHorizontal("In BigTitle");
        {
            if (readme.icon != null)
            {
                GUILayout.Space(k_Space);
                GUILayout.Label(readme.icon, GUILayout.Width(iconWidth), GUILayout.Height(iconWidth));
            }
            GUILayout.Space(k_Space);
            GUILayout.BeginVertical();
            {

                GUILayout.FlexibleSpace();
                GUILayout.Label(readme.title, TitleStyle);
                GUILayout.FlexibleSpace();
            }
            GUILayout.EndVertical();
            GUILayout.FlexibleSpace();
        }
        GUILayout.EndHorizontal();
    }

    public override void OnInspectorGUI()
    {
        var readme = (Readme)target;
        Init();

        foreach (var section in readme.sections)
        {
            if (!string.IsNullOrEmpty(section.heading))
            {
                GUILayout.Label(section.heading, HeadingStyle);
            }

            if (!string.IsNullOrEmpty(section.text))
            {
                GUILayout.Label(section.text, BodyStyle);
            }

            if (!string.IsNullOrEmpty(section.linkText))
            {
                if (LinkLabel(new GUIContent(section.linkText)))
                {
                    Application.OpenURL(section.url);
                }
            }

            GUILayout.Space(k_Space);
        }

        if (GUILayout.Button("Remove Readme Assets", ButtonStyle))
        {
            RemoveTutorial();
        }
    }

    bool m_Initialized;

    GUIStyle LinkStyle
    {
        get { return m_LinkStyle; }
    }

    [SerializeField]
    GUIStyle m_LinkStyle;

    GUIStyle TitleStyle
    {
        get { return m_TitleStyle; }
    }

    [SerializeField]
    GUIStyle m_TitleStyle;

    GUIStyle HeadingStyle
    {
        get { return m_HeadingStyle; }
    }

    [SerializeField]
    GUIStyle m_HeadingStyle;

    GUIStyle BodyStyle
    {
        get { return m_BodyStyle; }
    }

    [SerializeField]
    GUIStyle m_BodyStyle;

    GUIStyle ButtonStyle
    {
        get { return m_ButtonStyle; }
    }

    [SerializeField]
    GUIStyle m_ButtonStyle;

    void Init()
    {
        if (m_Initialized)
            return;
        m_BodyStyle = new GUIStyle(EditorStyles.label);
        m_BodyStyle.wordWrap = true;
        m_BodyStyle.fontSize = 14;
        m_BodyStyle.richText = true;

        m_TitleStyle = new GUIStyle(m_BodyStyle);
        m_TitleStyle.fontSize = 26;

        m_HeadingStyle = new GUIStyle(m_BodyStyle);
        m_HeadingStyle.fontStyle = FontStyle.Bold;
        m_HeadingStyle.fontSize = 18;

        m_LinkStyle = new GUIStyle(m_BodyStyle);
        m_LinkStyle.wordWrap = false;

        // Match selection color which works nicely for both light and dark skins
        m_LinkStyle.normal.textColor = new Color(0x00 / 255f, 0x78 / 255f, 0xDA / 255f, 1f);
        m_LinkStyle.stretchWidth = false;

        m_ButtonStyle = new GUIStyle(EditorStyles.miniButton);
        m_ButtonStyle.fontStyle = FontStyle.Bold;

        m_Initialized = true;
    }

    bool LinkLabel(GUIContent label, params GUILayoutOption[] options)
    {
        var position = GUILayoutUtility.GetRect(label, LinkStyle, options);

        Handles.BeginGUI();
        Handles.color = LinkStyle.normal.textColor;
        Handles.DrawLine(new Vector3(position.xMin, position.yMax), new Vector3(position.xMax, position.yMax));
        Handles.color = Color.white;
        Handles.EndGUI();

        EditorGUIUtility.AddCursorRect(position, MouseCursor.Link);

        return GUI.Button(position, label, LinkStyle);
    }
}

// ===== FILE: Assets/TutorialInfo/Scripts/Readme.cs =====
﻿using System;
using UnityEngine;

public class Readme : ScriptableObject
{
    public Texture2D icon;
    public string title;
    public Section[] sections;
    public bool loadedLayout;

    [Serializable]
    public class Section
    {
        public string heading, text, linkText, url;
    }
}

// ===== FILE: Tools/XmlDefsTools/Emit/SchemaCatalogWriter.cs =====
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Xml.Linq;
using XmlDefsTools.Scan;
using XmlDefsTools.Util;

namespace XmlDefsTools.Emit
{
    /// <summary>
    /// Writes a consolidated catalog file listing all schemas,
    /// their union of attributes and elements, and a canonical template
    /// sample for each schema.
    /// </summary>
    public static class SchemaCatalogWriter
    {
        public static void Write(string outputDir, ScanResult scan,
            IReadOnlyDictionary<string, IList<string>> orderHints)
        {
            Directory.CreateDirectory(outputDir);
            var outPath = Path.Combine(outputDir, "_AllSchemas.xml");

            var configuredSchemas = orderHints.Keys
                .Where(k => !string.Equals(k, "_common", StringComparison.OrdinalIgnoreCase)
                    && !k.StartsWith("//"))
                .ToHashSet(StringComparer.OrdinalIgnoreCase);
            var allSchemas = new HashSet<string>(scan.Schemas, StringComparer.OrdinalIgnoreCase);
            foreach (var s in configuredSchemas) allSchemas.Add(s);

            var doc = new XDocument(
                new XElement("DefSchemas",
                    new XAttribute("generated",
                        DateTime.UtcNow.ToString("yyyy-MM-ddTHH:mm:ssZ")))
            );

            var common = orderHints.TryGetValue("_common", out var commonOrder)
                ? commonOrder
                : Array.Empty<string>();

            foreach (var schema in allSchemas.OrderBy(s => s, StringComparer.OrdinalIgnoreCase))
            {
                var perSchema = orderHints.TryGetValue(schema, out var per)
                    ? per : Array.Empty<string>();
                var precedence = common.Concat(perSchema).ToList();

                // Collect union of fields from discovered defs
                var attrFields = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
                var elemFields = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
                if (scan.DefsBySchema.TryGetValue(schema, out var defs))
                {
                    foreach (var d in defs)
                    {
                        foreach (var a in d.AttributeFields) attrFields.Add(a);
                        foreach (var e in d.ElementFields) elemFields.Add(e);
                    }
                }

                // Seed with configured fields
                foreach (var hinted in perSchema) elemFields.Add(hinted);

                // Attributes for root + ordered element list
                var rootAttrs = NormalizeOrder(attrFields, precedence,
                    keepOnly: new[] { "id", "schema", "name_key", "tags", "version", "requires" });
                var elementNames = NormalizeOrder(
                    elemFields.Except(rootAttrs, StringComparer.OrdinalIgnoreCase), precedence);

                // Build a canonical template element (same rules as TemplateSynthesizer)
                var root = new XElement(schema);
                foreach (var a in rootAttrs)
                {
                    var placeholder = a.Equals("id", StringComparison.OrdinalIgnoreCase) ? "your_id_here"
                        : a.Equals("name_key", StringComparison.OrdinalIgnoreCase) ? "ui.your.key.here"
                        : a.Equals("tags", StringComparison.OrdinalIgnoreCase) ? string.Empty
                        : a.Equals("version", StringComparison.OrdinalIgnoreCase) ? "1"
                        : string.Empty;
                    root.SetAttributeValue(a, placeholder);
                }

                bool HasElem(string name) =>
                    elementNames.Any(n => n.Equals(name, StringComparison.OrdinalIgnoreCase));
                if (HasElem("version") && root.Attribute("version") == null)
                    root.Add(new XElement("version", "1"));
                if (HasElem("requires") && root.Attribute("requires") == null)
                    root.Add(new XElement("requires"));
                if (HasElem("components") ||
                    perSchema.Contains("components", StringComparer.OrdinalIgnoreCase))
                {
                    root.Add(new XElement("components",
                        new XComment(" Add component entries like <Component type=\"...\"/> ")));
                }
                foreach (var el in elementNames)
                {
                    if (string.Equals(el, "components", StringComparison.OrdinalIgnoreCase))
                        continue;
                    if (string.Equals(el, "version", StringComparison.OrdinalIgnoreCase)
                        && root.Elements("version").Any())
                        continue;
                    if (string.Equals(el, "requires", StringComparison.OrdinalIgnoreCase)
                        && root.Elements("requires").Any())
                        continue;
                    root.Add(new XElement(el));
                }
                var canonicalElement = CanonicalXml.CanonicalizeElement(root);

                // Compose catalog node
                var schemaNode = new XElement("Schema",
                    new XAttribute("name", schema),
                    new XElement("Attributes",
                        rootAttrs.Select(a => new XElement("Attr", new XAttribute("name", a)))),
                    new XElement("Elements",
                        elementNames.Select(e => new XElement("El", new XAttribute("name", e)))),
                    new XElement("Template", canonicalElement));

                doc.Root!.Add(schemaNode);
            }

            doc.Save(outPath);
        }

        private static List<string> NormalizeOrder(IEnumerable<string> names,
            IList<string> precedence, IEnumerable<string>? keepOnly = null)
        {
            var all = new HashSet<string>(names, StringComparer.OrdinalIgnoreCase);
            if (keepOnly != null)
            {
                var keep = new HashSet<string>(keepOnly, StringComparer.OrdinalIgnoreCase);
                all.RemoveWhere(n => !keep.Contains(n));
            }

            var ordered = new List<string>();
            foreach (var p in precedence)
            {
                if (all.Remove(p)) ordered.Add(p);
            }
            ordered.AddRange(all.OrderBy(n => n, StringComparer.OrdinalIgnoreCase));
            return ordered;
        }
    }
}


// ===== FILE: Tools/XmlDefsTools/Emit/TemplateSynthesizer.cs =====
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Xml.Linq;
using XmlDefsTools.Scan;
using XmlDefsTools.Util;

namespace XmlDefsTools.Emit
{
    public static class TemplateSynthesizer
    {
        public static void WriteTemplates(string outputDir, ScanResult scan, IReadOnlyDictionary<string, IList<string>> orderHints)
        {
            Directory.CreateDirectory(outputDir);
            // union of discovered schemas and configured schemas (ensures baseline output)
            var configuredSchemas = orderHints.Keys
                .Where(k => !string.Equals(k, "_common", StringComparison.OrdinalIgnoreCase) && !k.StartsWith("//"))
                .ToHashSet(StringComparer.OrdinalIgnoreCase);
            var allSchemas = new HashSet<string>(scan.Schemas, StringComparer.OrdinalIgnoreCase);
            foreach (var s in configuredSchemas) allSchemas.Add(s);

            foreach (var schema in allSchemas.OrderBy(s => s))
            {
                // if no defs discovered, synthesize from hints only
                var defs = scan.DefsBySchema.ContainsKey(schema)
                    ? scan.DefsBySchema[schema]
                    : new List<DefInfo>();

                // union of observed fields (attributes + elements)
                var attrFields = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
                var elemFields = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
                // include configured per-schema fields as elements to seed structure
                if (orderHints.TryGetValue(schema, out var hinted))
                {
                    foreach (var h in hinted) elemFields.Add(h);
                }
                foreach (var d in defs)
                {
                    foreach (var f in d.AttributeFields) attrFields.Add(f);
                    foreach (var f in d.ElementFields) elemFields.Add(f);
                }

                // known/common order
                var common = orderHints.TryGetValue("_common", out var c) ? c : Array.Empty<string>();
                var perSchema = orderHints.TryGetValue(schema, out var s) ? s : Array.Empty<string>();
                var precedence = common.Concat(perSchema).ToList();

                // Attributes to place on root element
                var rootAttrs = NormalizeOrder(attrFields, precedence, keepOnly: new[] { "id","schema","name_key","tags","version","requires" });
                // Remaining element fields (drop those already in attributes)
                var elementNames = NormalizeOrder(elemFields.Except(rootAttrs, StringComparer.OrdinalIgnoreCase),
                                                  precedence);

                bool HasElem(string name) => elementNames.Any(n => n.Equals(name, StringComparison.OrdinalIgnoreCase));

                var sb = new StringBuilder();
                sb.AppendLine($"<!-- Auto-generated default template for {schema}. Edit your copies; this file is regenerated. -->");

                var root = new XElement(schema);
                // Put attributes with placeholders
                foreach (var a in rootAttrs)
                {
                    var placeholder = a.Equals("id", StringComparison.OrdinalIgnoreCase) ? "your_id_here"
                                   : a.Equals("name_key", StringComparison.OrdinalIgnoreCase) ? "ui.your.key.here"
                                   : a.Equals("tags", StringComparison.OrdinalIgnoreCase) ? ""
                                   : a.Equals("version", StringComparison.OrdinalIgnoreCase) ? "1"
                                   : "";
                    root.SetAttributeValue(a, placeholder);
                }

                // Insert version/requires as elements too if heavily used as elements
                if (HasElem("version") && root.Attribute("version") == null)
                    root.Add(new XElement("version", "1"));
                if (HasElem("requires") && root.Attribute("requires") == null)
                    root.Add(new XElement("requires"));

                // Components block if observed
                if (HasElem("components") || perSchema.Contains("components", StringComparer.OrdinalIgnoreCase))
                {
                    root.Add(new XElement("components",
                        new XComment(" Add component entries like <Component type=\"...\"/> ")));
                }

                // Other fields as empty elements
                foreach (var el in elementNames)
                {
                    if (string.Equals(el, "components", StringComparison.OrdinalIgnoreCase)) continue;
                    if (string.Equals(el, "version", StringComparison.OrdinalIgnoreCase) && root.Elements("version").Any()) continue;
                    if (string.Equals(el, "requires", StringComparison.OrdinalIgnoreCase) && root.Elements("requires").Any()) continue;
                    root.Add(new XElement(el));
                }

                // Canonicalize attribute order
                var canonical = CanonicalXml.CanonicalizeElement(root);
                sb.AppendLine(canonical.ToString(SaveOptions.None));

                var outPath = Path.Combine(outputDir, $"{schema}.xml");
                File.WriteAllText(outPath, sb.ToString());
            }
        }

        private static List<string> NormalizeOrder(IEnumerable<string> names, IList<string> precedence, IEnumerable<string>? keepOnly = null)
        {
            var all = new HashSet<string>(names, StringComparer.OrdinalIgnoreCase);
            if (keepOnly != null)
            {
                var keep = new HashSet<string>(keepOnly, StringComparer.OrdinalIgnoreCase);
                all.RemoveWhere(n => !keep.Contains(n));
            }
            var ordered = new List<string>();
            foreach (var p in precedence)
            {
                if (all.Remove(p)) ordered.Add(p);
            }
            ordered.AddRange(all.OrderBy(n => n, StringComparer.OrdinalIgnoreCase));
            return ordered;
        }
    }
}

// ===== FILE: Tools/XmlDefsTools/Emit/XmlIndexWriter.cs =====
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using XmlDefsTools.Scan;

namespace XmlDefsTools.Emit
{
    public static class XmlIndexWriter
    {
        public static void Write(string repoRoot, string outFile, ScanResult scan)
        {
            var sb = new StringBuilder();
            sb.AppendLine("# XML Index (.xml)");
            sb.AppendLine();
            sb.AppendLine($"_Generated: {DateTime.UtcNow:yyyy-MM-dd HH:mm} UTC_");
            sb.AppendLine();
            sb.AppendLine($"**Total files scanned:** {scan.TotalFiles}  ");
            sb.AppendLine($"**Valid XML files:** {scan.ValidFiles}  ");
            sb.AppendLine($"**Defs discovered:** {scan.TotalDefs}  ");
            sb.AppendLine();

            if (scan.Errors.Any())
            {
                sb.AppendLine("## Parse Errors");
                foreach (var err in scan.Errors)
                {
                    sb.AppendLine($"- `{Rel(repoRoot, err.File)}` — {err.Message}");
                }
                sb.AppendLine();
            }

            if (scan.DuplicateIds.Any())
            {
                sb.AppendLine("## Duplicate IDs");
                foreach (var kvp in scan.DuplicateIds.OrderBy(k => k.Key, StringComparer.OrdinalIgnoreCase))
                {
                    sb.AppendLine($"- **{kvp.Key}**");
                    foreach (var item in kvp.Value)
                    {
                        sb.AppendLine($"  - `{item.Schema}` in `{Rel(repoRoot, item.SourceFile)}`");
                    }
                }
                sb.AppendLine();
            }

            // Match Code Index style: bulleted list of files with View · Raw links
            var (repo, branch) = RepoMeta();
            var allXmlFiles = scan.FileDocs.Keys.OrderBy(p => p, StringComparer.OrdinalIgnoreCase).ToList();
            if (allXmlFiles.Count > 0)
            {
                foreach (var file in allXmlFiles)
                {
                    var rel = Rel(repoRoot, file);
                    var webPath = rel.Replace('\\','/'); // ensure URL form
                    var enc = EncodePathSegments(webPath);
                    var viewUrl = $"https://github.com/{repo}/blob/{branch}/{enc}";
                    var rawUrl  = $"https://raw.githubusercontent.com/{repo}/{branch}/{enc}";
                    sb.AppendLine($"- `{webPath}` — [View]({viewUrl}) · [Raw]({rawUrl})");
                }
                sb.AppendLine();
            }

            // Keep the schema summary (below the list) for quick counts
            sb.AppendLine("## Summary by Schema");
            sb.AppendLine();
            sb.AppendLine("| Schema | Def Count | Files |");
            sb.AppendLine("|---|---:|---|");
            foreach (var schema in scan.Schemas.OrderBy(s => s))
            {
                var defs = scan.DefsBySchema[schema];
                var files = defs.Select(d => Rel(repoRoot, d.SourceFile)).Distinct().OrderBy(s => s);
                sb.AppendLine($"| {schema} | {defs.Count} | {string.Join("<br/>", files)} |");
            }
            sb.AppendLine();

            // Per-schema sections unchanged below (list ids + rare fields)

            foreach (var schema in scan.Schemas.OrderBy(s => s))
            {
                var defs = scan.DefsBySchema[schema];
                sb.AppendLine($"### {schema}");
                sb.AppendLine();
                foreach (var d in defs.OrderBy(d => d.Id, StringComparer.OrdinalIgnoreCase))
                {
                    sb.AppendLine($"- `{d.Id}` — `{Rel(repoRoot, d.SourceFile)}`");
                }
                // Any newly observed/rare fields
                var fieldCounts = new Dictionary<string,int>(StringComparer.OrdinalIgnoreCase);
                foreach (var d in defs)
                {
                    foreach (var f in d.AttributeFields.Concat(d.ElementFields))
                        fieldCounts[f] = fieldCounts.TryGetValue(f, out var c) ? c + 1 : 1;
                }
                var rare = fieldCounts.Where(kvp => kvp.Value <= Math.Max(1, defs.Count/5)).Select(kvp => kvp.Key).OrderBy(s=>s, StringComparer.OrdinalIgnoreCase).ToList();
                if (rare.Count > 0)
                {
                    sb.AppendLine();
                    sb.AppendLine("<details><summary>Less common fields</summary>");
                    sb.AppendLine();
                    foreach (var f in rare) sb.AppendLine($"- `{f}`");
                    sb.AppendLine();
                    sb.AppendLine("</details>");
                }
                sb.AppendLine();
            }

            Directory.CreateDirectory(Path.GetDirectoryName(outFile)!);
            File.WriteAllText(outFile, sb.ToString());
        }

        // Encode each path segment to avoid corrupting '/' and handle special characters safely.
        private static string EncodePathSegments(string path)
        {
            var parts = path.Replace('\\','/').Split(new[]{'/'}, StringSplitOptions.RemoveEmptyEntries);
            var encoded = parts.Select(Uri.EscapeDataString);
            return string.Join("/", encoded);
        }

        private static (string repo, string branch) RepoMeta()
        {
            var repo = Environment.GetEnvironmentVariable("GITHUB_REPOSITORY");
            if (string.IsNullOrWhiteSpace(repo)) repo = "Natangry/FantasyColony";
            var branch = Environment.GetEnvironmentVariable("GITHUB_REF_NAME");
            if (string.IsNullOrWhiteSpace(branch)) branch = "main";
            // strip refs/heads/ if present
            branch = branch.Replace("refs/heads/", "");
            return (repo, branch);
        }

        private static string Rel(string root, string path)
        {
            try
            {
                var rp = Path.GetRelativePath(root, path).Replace('\\','/');
                return rp;
            }
            catch
            {
                return path.Replace('\\','/');
            }
        }
    }
}

// ===== FILE: Tools/XmlDefsTools/Emit/XmlSnapshotWriter.cs =====
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Xml.Linq;
using XmlDefsTools.Util;

namespace XmlDefsTools.Emit
{
    public static class XmlSnapshotWriter
    {
        public static void Write(string repoRoot, string outFile, IEnumerable<(string path, XDocument? doc)> docs)
        {
            var sb = new StringBuilder();
            foreach (var (path, doc) in docs.OrderBy(t => t.path, StringComparer.OrdinalIgnoreCase))
            {
                sb.AppendLine($"// ===== FILE: {Rel(repoRoot, path)} =====");
                if (doc == null)
                {
                    sb.AppendLine("// (invalid XML)");
                    sb.AppendLine();
                    continue;
                }
                var normalized = CanonicalXml.Canonicalize(doc);
                sb.AppendLine(normalized);
                sb.AppendLine();
            }
            File.WriteAllText(outFile, sb.ToString());
        }

        private static string Rel(string root, string path)
        {
            try
            {
                var rp = Path.GetRelativePath(root, path).Replace('\\','/');
                return rp;
            }
            catch
            {
                return path.Replace('\\','/');
            }
        }
    }
}

// ===== FILE: Tools/XmlDefsTools/Program.cs =====
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text.Json;
using XmlDefsTools.Emit;
using XmlDefsTools.Scan;

namespace XmlDefsTools
{
    internal static class Program
    {
        private static int Main(string[] args)
        {
            try
            {
                var repoRoot = GetRepoRoot();
                var defsDir = GetDefsDir(repoRoot);
                Console.WriteLine($"[XmlDefsTools] Repo root: {repoRoot}");
                Console.WriteLine($"[XmlDefsTools] Defs dir : {defsDir}");

                var scanner = new XmlDefScanner();
                var scan = scanner.Scan(defsDir);

                // Load order hints
                var hintsPath = Path.Combine(repoRoot, "Tools", "XmlDefsTools", "Config", "SchemaOrder.json");
                var orderHints = File.Exists(hintsPath)
                    ? JsonSerializer.Deserialize<Dictionary<string, IList<string>>>(File.ReadAllText(hintsPath))
                    : new Dictionary<string, IList<string>>(StringComparer.OrdinalIgnoreCase);
                orderHints ??= new Dictionary<string, IList<string>>(StringComparer.OrdinalIgnoreCase);

                // Write index
                var indexPath = Path.Combine(repoRoot, "XML_INDEX.md");
                XmlIndexWriter.Write(repoRoot, indexPath, scan);
                Console.WriteLine($"[XmlDefsTools] Wrote index: {indexPath}");

                // Write snapshot
                var snapshotPath = Path.Combine(repoRoot, "XML_SNAPSHOT.txt");
                var docs = scan.FileDocs.Select(kvp => (kvp.Key, kvp.Value));
                XmlSnapshotWriter.Write(repoRoot, snapshotPath, docs);
                Console.WriteLine($"[XmlDefsTools] Wrote snapshot: {snapshotPath}");

                // Write templates
                var templatesDir = Path.Combine(repoRoot, "Docs", "Templates", "Defs");
                TemplateSynthesizer.WriteTemplates(templatesDir, scan, orderHints);
                Console.WriteLine($"[XmlDefsTools] Wrote templates to: {templatesDir}");

                // Write consolidated schema catalog
                var catalogPath = Path.Combine(templatesDir, "_AllSchemas.xml");
                SchemaCatalogWriter.Write(templatesDir, scan, orderHints);
                Console.WriteLine($"[XmlDefsTools] Wrote consolidated catalog: {catalogPath}");

                return 0;
            }
            catch (Exception ex)
            {
                Console.Error.WriteLine(ex.ToString());
                return 1;
            }
        }

        private static string GetRepoRoot()
        {
            var env = Environment.GetEnvironmentVariable("FC_REPO_ROOT");
            if (!string.IsNullOrWhiteSpace(env))
                return Path.GetFullPath(env);
            // assume current working directory is repo root (CI) or a subfolder (local)
            var cwd = Directory.GetCurrentDirectory();
            // try to find .git upwards
            var dir = new DirectoryInfo(cwd);
            while (dir != null)
            {
                if (Directory.Exists(Path.Combine(dir.FullName, ".git")))
                    return dir.FullName;
                dir = dir.Parent;
            }
            return cwd;
        }

        private static string GetDefsDir(string repoRoot)
        {
            var env = Environment.GetEnvironmentVariable("FC_DEFS_DIR");
            if (!string.IsNullOrWhiteSpace(env))
            {
                var p = Path.IsPathRooted(env) ? env : Path.Combine(repoRoot, env);
                return Directory.Exists(p) ? p : repoRoot;
            }
            var candidates = new[]
            {
                Path.Combine(repoRoot, "StreamingAssets", "Defs"),
                Path.Combine(repoRoot, "Assets", "StreamingAssets", "Defs"),
                Path.Combine(repoRoot, "GameData", "Defs")
            };
            foreach (var c in candidates)
                if (Directory.Exists(c)) return c;
            // fallback: repo root (will scan, find no files, still emit artifacts)
            return repoRoot;
        }
    }
}

// ===== FILE: Tools/XmlDefsTools/Scan/XmlDefScanner.cs =====
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Xml;
using System.Xml.Linq;

namespace XmlDefsTools.Scan
{
    public sealed class XmlDefScanner
    {
        public ScanResult Scan(string rootDir)
        {
            var res = new ScanResult();
            if (!Directory.Exists(rootDir))
                return res;

            var files = Directory.EnumerateFiles(rootDir, "*.xml", SearchOption.AllDirectories).ToList();
            res.TotalFiles = files.Count;
            foreach (var file in files)
            {
                XDocument? doc = null;
                try
                {
                    var text = File.ReadAllText(file);
                    doc = XDocument.Parse(text, LoadOptions.PreserveWhitespace | LoadOptions.SetLineInfo);
                    res.ValidFiles++;
                    res.FileDocs[file] = doc;
                }
                catch (Exception ex)
                {
                    res.Errors.Add(new ScanError { File = file, Message = ex.GetBaseException().Message });
                    res.FileDocs[file] = null;
                    continue;
                }

                // Collect defs: any element with an 'id' attribute
                var defs = doc.Descendants()
                    .Where(e => e.NodeType == System.Xml.XmlNodeType.Element)
                    .OfType<XElement>()
                    .Where(e => e.Attribute("id") != null)
                    .ToList();

                foreach (var el in defs)
                {
                    var schema = el.Name.LocalName;
                    var id = (string?)el.Attribute("id") ?? "(missing)";
                    var info = new DefInfo
                    {
                        Schema = schema,
                        Id = id,
                        SourceFile = file
                    };

                    // Attribute fields (names only)
                    foreach (var a in el.Attributes())
                    {
                        if (a.IsNamespaceDeclaration) continue;
                        info.AttributeFields.Add(a.Name.LocalName);
                    }

                    // Element fields (direct child element names only)
                    foreach (var child in el.Elements())
                    {
                        info.ElementFields.Add(child.Name.LocalName);
                    }

                    res.TotalDefs++;
                    if (!res.DefsBySchema.TryGetValue(schema, out var list))
                    {
                        list = new List<DefInfo>();
                        res.DefsBySchema[schema] = list;
                        res.Schemas.Add(schema);
                    }
                    list.Add(info);

                    // Track duplicates
                    var dupKey = id;
                    if (!res.DuplicateIds.TryGetValue(dupKey, out var dupList))
                    {
                        dupList = new List<DefInfo>();
                        res.DuplicateIds[dupKey] = dupList;
                    }
                    dupList.Add(info);
                }
            }

            // Remove entries that are not actually duplicates (only one occurrence)
            var toPrune = res.DuplicateIds.Where(kvp => kvp.Value.Count <= 1)
                                          .Select(kvp => kvp.Key).ToList();
            foreach (var k in toPrune) res.DuplicateIds.Remove(k);

            return res;
        }
    }

    public sealed class ScanResult
    {
        public int TotalFiles { get; set; }
        public int ValidFiles { get; set; }
        public int TotalDefs { get; set; }
        public HashSet<string> Schemas { get; } = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
        public Dictionary<string, List<DefInfo>> DefsBySchema { get; } = new Dictionary<string, List<DefInfo>>(StringComparer.OrdinalIgnoreCase);
        public List<ScanError> Errors { get; } = new List<ScanError>();
        public Dictionary<string, XDocument?> FileDocs { get; } = new Dictionary<string, XDocument?>(StringComparer.OrdinalIgnoreCase);
        public Dictionary<string, List<DefInfo>> DuplicateIds { get; } = new Dictionary<string, List<DefInfo>>(StringComparer.OrdinalIgnoreCase);
    }

    public sealed class DefInfo
    {
        public string Schema { get; set; } = "";
        public string Id { get; set; } = "";
        public string SourceFile { get; set; } = "";
        public HashSet<string> AttributeFields { get; } = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
        public HashSet<string> ElementFields { get; } = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
    }

    public sealed class ScanError
    {
        public string File { get; set; } = "";
        public string Message { get; set; } = "";
    }
}

// ===== FILE: Tools/XmlDefsTools/Util/CanonicalXml.cs =====
using System;
using System.IO;
using System.Linq;
using System.Text;
using System.Xml;
using System.Xml.Linq;

namespace XmlDefsTools.Util
{
    public static class CanonicalXml
    {
        private static readonly string[] AttributePrecedence =
        {
            "id","schema","name_key","tags","version","requires"
        };

        public static string Canonicalize(XDocument doc)
        {
            // Remove comments
            foreach (var c in doc.DescendantNodes().OfType<XComment>().ToList())
                c.Remove();

            // Canonicalize elements & attributes
            var root = CanonicalizeElement(doc.Root!);
            var newDoc = new XDocument(root);

            // Save with stable formatting
            var settings = new XmlWriterSettings
            {
                OmitXmlDeclaration = true,
                Indent = true,
                NewLineOnAttributes = false
            };
            var sb = new StringBuilder();
            using (var writer = XmlWriter.Create(sb, settings))
            {
                newDoc.Save(writer);
            }
            return sb.ToString().Trim() + Environment.NewLine;
        }

        public static XElement CanonicalizeElement(XElement el)
        {
            var orderedAttrs = el.Attributes()
                .Where(a => !a.IsNamespaceDeclaration)
                .OrderBy(a => OrderKey(a.Name.LocalName))
                .ThenBy(a => a.Name.LocalName, StringComparer.OrdinalIgnoreCase)
                .ToList();

            var newEl = new XElement(el.Name);
            foreach (var a in orderedAttrs)
                newEl.SetAttributeValue(a.Name.LocalName, a.Value);

            foreach (var node in el.Nodes())
            {
                if (node is XElement child)
                {
                    newEl.Add(CanonicalizeElement(child));
                }
                else if (node is XText t)
                {
                    var v = t.Value;
                    if (!string.IsNullOrWhiteSpace(v))
                        newEl.Add(new XText(NormalizeWhitespace(v)));
                }
                // other node types (comments, processing instructions) are skipped
            }
            return newEl;
        }

        private static int OrderKey(string name)
        {
            for (int i = 0; i < AttributePrecedence.Length; i++)
                if (name.Equals(AttributePrecedence[i], StringComparison.OrdinalIgnoreCase))
                    return i - 1000; // bubble to front
            return 0;
        }

        private static string NormalizeWhitespace(string s)
        {
            // Collapse internal whitespace sequences
            var arr = s.ToCharArray();
            var sb = new StringBuilder(arr.Length);
            bool inWs = false;
            foreach (var ch in arr)
            {
                if (char.IsWhiteSpace(ch))
                {
                    if (!inWs)
                    {
                        sb.Append(' ');
                        inWs = true;
                    }
                }
                else
                {
                    sb.Append(ch);
                    inWs = false;
                }
            }
            return sb.ToString().Trim();
        }
    }
}

