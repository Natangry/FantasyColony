# Auto-generated code snapshot
_Updated_: 2025-09-01 06:42:39 UTC

// ===== FILE: Assets/Editor/SpriteImportDefaults.cs =====
// Editor-only: ensures sprites import with our project defaults (hi-res, crisp pixels).
// - Applies automatically to any texture under a folder named "Sprites" (e.g. Assets/Resources/Sprites/)
// - Adds menu items to (re)apply settings to selected textures or an entire folder
//
// Defaults:
//   TextureType: Sprite (2D and UI)
//   SpriteMode: Single
//   Pixels Per Unit: 64
//   Filter Mode: Point (no filter)
//   Compression: None (Uncompressed)
//   Wrap Mode: Clamp
//   MipMaps: Off
//   sRGB: On
//   Alpha Is Transparency: On (where supported)
//   Pivot: Bottom-Center (0.5, 0.0)

#if UNITY_EDITOR
using System;
using System.Linq;
using UnityEditor;
using UnityEngine;
using System.Reflection;

namespace FantasyColony.EditorTools
{
    public class SpriteImportDefaults : AssetPostprocessor
    {
        const float DefaultPPU = 64f;
        const int   DefaultMaxSize = 1024;

        static bool IsSpritePath(string path)
        {
            if (string.IsNullOrEmpty(path)) return false;
            path = path.Replace('\\', '/').ToLowerInvariant();
            return path.Contains("/sprites/");
        }

        void OnPreprocessTexture()
        {
            if (!IsSpritePath(assetPath)) return;
            var ti = (TextureImporter)assetImporter;
            ApplyDefaults(ti);
        }

        static void ApplyDefaults(TextureImporter ti)
        {
            ti.textureType = TextureImporterType.Sprite;
            ti.spriteImportMode = SpriteImportMode.Single;
            ti.spritePixelsPerUnit = DefaultPPU;
            ti.mipmapEnabled = false;
            ti.filterMode = FilterMode.Point;
            ti.textureCompression = TextureImporterCompression.Uncompressed;
            ti.wrapMode = TextureWrapMode.Clamp;
            ti.maxTextureSize = DefaultMaxSize;

            // Color space & alpha handling
#if UNITY_2019_3_OR_NEWER
            ti.sRGBTexture = true;
#endif
#if !UNITY_2023_1_OR_NEWER
            // In newer versions this field may be hidden/ignored, but it's safe to set where available.
            ti.alphaIsTransparency = true;
#endif
#if UNITY_2021_2_OR_NEWER
            ti.alphaSource = TextureImporterAlphaSource.FromInput;
#endif

            // Pivot: Bottom-Center (Unity 6 removed 'spriteAlignment'; set via spritePivot and
            // use reflection to set alignment to Custom when property exists on older versions)
            SetPivotBottomCenter(ti);
        }

        static void SetPivotBottomCenter(TextureImporter ti)
        {
            // Always set explicit pivot
            ti.spritePivot = new Vector2(0.5f, 0f);

            // Try to set alignment to Custom when the legacy property exists
            try
            {
                var prop = typeof(TextureImporter).GetProperty("spriteAlignment",
                    BindingFlags.Public | BindingFlags.Instance);
                if (prop != null && prop.CanWrite)
                {
                    var enumType = prop.PropertyType;
                    object customVal = null;
                    // If type is an enum that defines "Custom", use it; otherwise fall back to 9
                    if (enumType.IsEnum && Enum.GetNames(enumType).Contains("Custom"))
                        customVal = Enum.Parse(enumType, "Custom");
                    else
                        customVal = Convert.ChangeType(9, enumType); // 9 == SpriteAlignment.Custom in legacy

                    prop.SetValue(ti, customVal);
                }
            }
            catch
            {
                // Safe no-op on newer Unity versions
            }
        }

        // --- Context menus ---------------------------------------------------

        [MenuItem("Assets/Sprites/Apply Sprite Defaults (64 PPU)", true)]
        static bool ValidateApplyToSelection()
        {
            return Selection.assetGUIDs != null && Selection.assetGUIDs.Length > 0;
        }

        [MenuItem("Assets/Sprites/Apply Sprite Defaults (64 PPU)")]
        static void ApplyToSelection()
        {
            int count = 0;
            foreach (var guid in Selection.assetGUIDs)
            {
                var path = AssetDatabase.GUIDToAssetPath(guid);
                if (string.IsNullOrEmpty(path)) continue;
                if (!IsSpritePath(path)) continue;
                var ti = AssetImporter.GetAtPath(path) as TextureImporter;
                if (ti == null) continue;
                ApplyDefaults(ti);
                AssetDatabase.ImportAsset(path, ImportAssetOptions.ForceUpdate);
                count++;
            }
            Debug.Log($"[SpriteImportDefaults] Applied to {count} asset(s).");
        }

        [MenuItem("Assets/Sprites/Apply Defaults To Folder (recursive)", true)]
        static bool ValidateApplyToFolder()
        {
            // Enable when a folder is selected
            return Selection.assetGUIDs.Any(guid =>
            {
                var path = AssetDatabase.GUIDToAssetPath(guid);
                return AssetDatabase.IsValidFolder(path);
            });
        }

        [MenuItem("Assets/Sprites/Apply Defaults To Folder (recursive)")]
        static void ApplyToFolder()
        {
            int total = 0;
            foreach (var guid in Selection.assetGUIDs)
            {
                var folder = AssetDatabase.GUIDToAssetPath(guid);
                if (!AssetDatabase.IsValidFolder(folder)) continue;
                var guids = AssetDatabase.FindAssets("t:Texture2D", new[] { folder });
                foreach (var texGuid in guids)
                {
                    var path = AssetDatabase.GUIDToAssetPath(texGuid);
                    if (!IsSpritePath(path)) continue;
                    var ti = AssetImporter.GetAtPath(path) as TextureImporter;
                    if (ti == null) continue;
                    ApplyDefaults(ti);
                    AssetDatabase.ImportAsset(path, ImportAssetOptions.ForceUpdate);
                    total++;
                }
            }
            Debug.Log($"[SpriteImportDefaults] Applied to {total} asset(s) in folder(s).");
        }
    }
}
#endif

// ===== FILE: Assets/Scripts/Boot/BootPipeline.cs =====
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using FantasyColony.Core.Services;
using FantasyColony.Core.Mods;

namespace FantasyColony.Boot {
    /// <summary>
    /// Modular boot pipeline. Each step is an IBootTask for extensibility and robust error handling.
    /// </summary>
    public static class BootPipeline {
        public static IEnumerator Run(Action<string> setPhase) {
            var report = new Boot.BootReport();
            var ctx = new Boot.BootContext { Report = report };

            foreach (var task in Boot.BootTaskRegistry.DefaultTasks()) {
                setPhase?.Invoke(task.Title);
                yield return task.Execute(ctx);
            }

            // Ready
            setPhase?.Invoke("Ready");
            Boot.BootReport.Last = report;
        }
    }

    // --- Boot framework ---------------------------------------------------
    public interface IBootTask {
        string Title { get; }
        IEnumerator Execute(BootContext ctx);
    }

    public sealed class BootContext {
        public List<ModInfo> Mods = new List<ModInfo>();
        public DefRegistry Defs => DefRegistry.Instance;
        public JsonConfigService Config => JsonConfigService.Instance;
        public BootReport Report;
    }

    public sealed class BootReport {
        public struct Step { public string title; public float seconds; public string warn; public string error; }
        public readonly List<Step> steps = new();
        public static BootReport Last { get; internal set; }
        internal void Add(string title, float dt, string warn = null, string error = null) {
            steps.Add(new Step { title = title, seconds = dt, warn = warn, error = error });
        }
    }

    public static class BootTaskRegistry {
        public static IEnumerable<IBootTask> DefaultTasks() {
            yield return new ConfigTask();
            yield return new DiscoverModsTask();
            yield return new LoadDefsTask();
            yield return new ValidateAndMigrateDefsTask();
            yield return new InitServicesTask();
            yield return new WarmAssetsTask();
        }
    }

    // --- Concrete tasks ---------------------------------------------------
    sealed class ConfigTask : IBootTask {
        public string Title => "Loading configuration...";
        public IEnumerator Execute(BootContext ctx) {
            var t0 = Time.realtimeSinceStartup;
            string warn = null, err = null;
            try { ctx.Config.Load(); }
            catch (Exception e) { warn = $"Config load failed, defaults used: {e.Message}"; Debug.LogWarning(warn); }
            ctx.Report?.Add(Title, Time.realtimeSinceStartup - t0, warn, err);
            yield return null;
        }
    }

    sealed class DiscoverModsTask : IBootTask {
        public string Title => "Discovering mods...";
        public IEnumerator Execute(BootContext ctx) {
            var t0 = Time.realtimeSinceStartup;
            string warn = null;
            try { ctx.Mods = ModDiscovery.Discover(); Debug.Log($"Mods discovered: {ctx.Mods.Count}"); }
            catch (Exception e) { warn = $"Mod discovery failed: {e.Message}"; Debug.LogWarning(warn); ctx.Mods = new List<ModInfo>(); }
            ctx.Report?.Add(Title, Time.realtimeSinceStartup - t0, warn, null);
            yield return null;
        }
    }

    sealed class LoadDefsTask : IBootTask {
        public string Title => "Loading defs...";
        public IEnumerator Execute(BootContext ctx) {
            var t0 = Time.realtimeSinceStartup;
            string warn = null;
            try {
                var errors = new List<DefError>();
                XmlDefLoader.Load(ctx.Mods, ctx.Defs, errors);
                if (errors.Count > 0) warn = $"Defs loaded with {errors.Count} issues. See log.";
                if (ctx.Defs.ConflictCount > 0) {
                    var note = $"Conflicts={ctx.Defs.ConflictCount}";
                    warn = string.IsNullOrEmpty(warn) ? note : ($"{warn} | {note}");
                }
                Debug.Log($"Defs loaded. Count={ctx.Defs.Count}");
            } catch (Exception e) { warn = $"Def loading failed (lenient): {e.Message}"; Debug.LogWarning(warn); }
            ctx.Report?.Add(Title, Time.realtimeSinceStartup - t0, warn, null);
            yield return null;
        }
    }

    sealed class ValidateAndMigrateDefsTask : IBootTask {
        public string Title => "Validating & migrating defs...";
        public IEnumerator Execute(BootContext ctx) {
            var t0 = Time.realtimeSinceStartup;
            string warn = null;
            int warnCount = 0, migCount = 0;
            try {
                // Build index first, then load schemas from StreamingAssets and from each mod root inferred via index
                var index = FantasyColony.Core.Defs.DefIndex.Build(ctx.Mods, ctx.Defs);
                FantasyColony.Core.Defs.Validation.SchemaCatalog.EnsureLoadedFromIndex(index);
                var results = FantasyColony.Core.Defs.Validation.DefValidator.Run(index);
                foreach (var r in results) { Debug.LogWarning($"[Defs] {r}"); }
                warnCount = results.Count;
                migCount = FantasyColony.Core.Defs.Migrations.MigrationEngine.Run(index);
                if (warnCount > 0 || migCount > 0) {
                    warn = $"Validation warnings={warnCount}, migrations={migCount}";
                }
            } catch (Exception e) {
                warn = $"Validation phase had issues: {e.Message}";
                Debug.LogWarning(warn);
            }
            ctx.Report?.Add(Title, Time.realtimeSinceStartup - t0, warn, null);
            yield return null;
        }
    }

    sealed class InitServicesTask : IBootTask {
        public string Title => "Initializing services...";
        public IEnumerator Execute(BootContext ctx) {
            var t0 = Time.realtimeSinceStartup;
            string warn = null;
            try {
                var cfg = ctx.Config;
                var lang = cfg.Get("language", "en");
                LocService.Instance.SetLanguage(lang);
                float vMaster = Parse01(cfg.Get("vol_master", "1"));
                float vMusic  = Parse01(cfg.Get("vol_music", "1"));
                float vSfx    = Parse01(cfg.Get("vol_sfx", "1"));
                AudioService.Instance.SetVolume("master", vMaster);
                AudioService.Instance.SetVolume("music", vMusic);
                AudioService.Instance.SetVolume("sfx", vSfx);
                JsonSaveService.Instance.RefreshCache();
            } catch (Exception e) { warn = $"Service init had issues: {e.Message}"; Debug.LogWarning(warn); }
            ctx.Report?.Add(Title, Time.realtimeSinceStartup - t0, warn, null);
            yield return null;
        }
        private static float Parse01(string s) {
            if (float.TryParse(s, out var v)) {
                if (float.IsNaN(v) || float.IsInfinity(v)) return 1f;
                return Mathf.Clamp01(v);
            }
            return 1f;
        }
    }

    sealed class WarmAssetsTask : IBootTask {
        public string Title => "Warming assets...";
        public IEnumerator Execute(BootContext ctx) {
            var t0 = Time.realtimeSinceStartup;
#if ADDRESSABLES
            try {
                var handle = UnityEngine.AddressableAssets.Addressables.InitializeAsync();
                yield return handle;
            } catch { /* fail-soft */ }
#else
            yield return null;
#endif
            ctx.Report?.Add(Title, Time.realtimeSinceStartup - t0, null, null);
        }
    }
}


// ===== FILE: Assets/Scripts/Core/AppBootstrap.cs =====
using UnityEngine;

namespace FantasyColony.Core
{
    /// <summary>
    /// Single entry point. We don't rely on authored Unity scenes; everything is spawned at runtime.
    /// </summary>
    public static class AppBootstrap
    {
        [RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]
        private static void Boot()
        {
            // Guard against duplicates (domain reloads, additive loads)
#if UNITY_2023_1_OR_NEWER
            if (Object.FindFirstObjectByType<AppHost>() != null) return;
#else
            if (Object.FindObjectOfType<AppHost>() != null) return;
#endif
            // Root host object that survives for the whole app lifetime.
            var root = new GameObject("AppRoot");
            Object.DontDestroyOnLoad(root);
            root.AddComponent<AppHost>();
        }
    }
}

// ===== FILE: Assets/Scripts/Core/AppFlow.cs =====
using System.Collections;
using UnityEngine;
using FantasyColony.UI.Router;
using FantasyColony.UI.Screens;

namespace FantasyColony.Core {
    /// <summary>
    /// Centralized app-level flows (Restart, Quit) so buttons/screens don't need to know wiring.
    /// </summary>
    public class AppFlow : MonoBehaviour {
        private UIRouter _router;

        public static AppFlow Instance { get; private set; }

        private void Awake() {
            if (Instance != null && Instance != this) {
                Destroy(gameObject);
                return;
            }
            Instance = this;
            DontDestroyOnLoad(gameObject);
        }

        internal void Initialize(UIRouter router) {
            _router = router;
        }

        /// <summary>
        /// Cleanly restarts to the Boot screen, re-running the boot pipeline.
        /// </summary>
        public void Restart() {
            if (_router == null) return;
            StartCoroutine(RestartCo());
        }

        private IEnumerator RestartCo() {
            // Cover with Boot screen first
            _router.PopAll();
            _router.Push<BootScreen>();

            // Give UI one frame to present cover
            yield return null;

            // Free anything not referenced anymore
            yield return Resources.UnloadUnusedAssets();
            System.GC.Collect();
        }

        public void Quit() {
            Application.Quit();
        }
    }
}

namespace FantasyColony.UI.Screens {
    // Convenience shim to keep existing UI button bindings simple
    public static class AppFlowCommands {
        public static void Restart() => FantasyColony.Core.AppFlow.Instance?.Restart();
        public static void Quit() => FantasyColony.Core.AppFlow.Instance?.Quit();
    }
}

// ===== FILE: Assets/Scripts/Core/AppHost.cs =====
using UnityEngine;
using FantasyColony.UI.Root;
using FantasyColony.UI.Router;
using FantasyColony.Core.Services;
using FantasyColony.UI.Screens;

// Disambiguate our service interfaces from Unity's similarly named types
using FCLogger = FantasyColony.Core.Services.ILogger;
using FCFileLogger = FantasyColony.Core.Services.FileLogger;
using FCConfigService = FantasyColony.Core.Services.IConfigService;
using FCEventBus = FantasyColony.Core.Services.IEventBus;
using FCSimpleEventBus = FantasyColony.Core.Services.SimpleEventBus;
using FCAssetProvider = FantasyColony.Core.Services.IAssetProvider;
using FCResourcesProvider = FantasyColony.Core.Services.ResourcesAssetProvider;
using FCJsonConfig = FantasyColony.Core.Services.JsonConfigService;

namespace FantasyColony.Core
{
    /// <summary>
    /// Lifetime owner.
    /// Builds services, creates UIRoot and pushes Main Menu screen.
    /// </summary>
    public class AppHost : MonoBehaviour
    {
        public static AppHost Instance { get; private set; }
        public ServiceRegistry Services => _services;
        public UIRouter Router => _router;

        private ServiceRegistry _services;
        private UIRoot _uiRoot;
        private UIRouter _router;

        private void Awake()
        {
            // Duplicate guard: prefer the first instance
            if (Instance != null && Instance != this) { Destroy(gameObject); return; }
            Instance = this;

            _services = new ServiceRegistry();
            _services.Register<FCLogger>(new FCFileLogger());
            // Use JSON-backed config as the single source of truth
            var cfg = FCJsonConfig.Instance;
            cfg.Load();
            _services.Register<FCConfigService>(cfg);
            _services.Register<FCEventBus>(new FCSimpleEventBus());
            _services.Register<FCAssetProvider>(new FCResourcesProvider());
            // Make AudioService discoverable via the registry
            _services.Register<AudioService>(AudioService.Instance);

            // Apply desktop frame pacing from config (defaults: vsync=1, target_fps=-1)
            int vsync = 1; int targetFps = -1;
            System.Int32.TryParse(cfg.Get("video.vsync", "1"), out vsync);
            System.Int32.TryParse(cfg.Get("video.target_fps", "-1"), out targetFps);
            QualitySettings.vSyncCount = Mathf.Max(0, vsync);
            Application.targetFrameRate = targetFps;

            // Create UI root (Canvas + EventSystem)
            _uiRoot = UIRoot.Create(transform);

            // Router mounts screens under UIRoot
            _router = new UIRouter(_uiRoot.ScreenParent, _services);

            // Attach AppFlow helper to manage restart/quit across the app
            var flow = gameObject.GetComponent<AppFlow>();
            if (flow == null) flow = gameObject.AddComponent<AppFlow>();
            flow.Initialize(_router);

            // Global shortcuts (e.g., F9 to open Boot Report) available in all builds
            var shortcuts = gameObject.GetComponent<GlobalShortcuts>();
            if (shortcuts == null) shortcuts = gameObject.AddComponent<GlobalShortcuts>();

            // Show Boot screen first so the UI covers while startup work initializes
            _router.Push<BootScreen>();
        }

        private void OnDestroy()
        {
            if (Instance == this) Instance = null;
        }
    }
}

// ===== FILE: Assets/Scripts/Core/BuildInfo.cs =====
namespace FantasyColony.Core
{
    /// <summary>
    /// Static build info for diagnostics; can be auto-generated later by an Editor script.
    /// </summary>
    public static class BuildInfo
    {
        public const string Version = "0.1.0";
        public const string Commit = "local";
        public const string Unity = "AUTO"; // can be filled at runtime via UnityEngine.Application.unityVersion
    }
}

namespace FantasyColony.Core.Services
{
    public static class BuildInfoRuntime
    {
        public static string Describe() => $"v{FantasyColony.Core.BuildInfo.Version} ({FantasyColony.Core.BuildInfo.Commit}) | Unity {UnityEngine.Application.unityVersion}";
    }
}

// ===== FILE: Assets/Scripts/Core/Defs/DefId.cs =====
using System;

namespace FantasyColony.Core.Defs {
    /// <summary>
    /// Canonical string id shape: modid.DefType.Name
    /// </summary>
    public struct DefId {
        public string Mod; public string Type; public string Name;
        public bool IsEmpty => string.IsNullOrEmpty(Mod) || string.IsNullOrEmpty(Type) || string.IsNullOrEmpty(Name);
        public override string ToString() => string.IsNullOrEmpty(Mod) ? $"{Type}.{Name}" : $"{Mod}.{Type}.{Name}";

        public static bool TryParse(string value, out DefId id) {
            id = default;
            if (string.IsNullOrEmpty(value)) return false;
            var parts = value.Split('.');
            if (parts.Length == 2) { // Type.Name (allowed for intra-pack refs)
                id = new DefId { Mod = string.Empty, Type = parts[0], Name = parts[1] };
                return true;
            }
            if (parts.Length == 3) {
                id = new DefId { Mod = parts[0], Type = parts[1], Name = parts[2] };
                return true;
            }
            return false;
        }
    }
}

// ===== FILE: Assets/Scripts/Core/Defs/DefIndex.cs =====
using System.Collections.Generic;
using System.Xml;
using FantasyColony.Core.Mods;
using FantasyColony.Core.Services;

namespace FantasyColony.Core.Defs {
    /// <summary>
    /// Builds a read-only index of defs from the registry + quick XML header reads.
    /// </summary>
    public sealed class DefIndex {
        public readonly List<DefMeta> Items = new();
        private readonly Dictionary<string, List<DefMeta>> _byType = new();
        private readonly Dictionary<string, DefMeta> _byKey = new(); // Type.Id (no mod prefix)

        public IEnumerable<DefMeta> OfType(string type) => _byType.TryGetValue(type, out var list) ? list : System.Array.Empty<DefMeta>();
        public DefMeta Find(string type, string id) => _byKey.TryGetValue(type + "." + id, out var m) ? m : null;

        public static DefIndex Build(List<ModInfo> mods, DefRegistry registry) {
            var index = new DefIndex();
            foreach (var entry in registry.All()) {
                // entry: (Type, Id, Path, ModId)
                var meta = new DefMeta {
                    Type = entry.Type,
                    Id = entry.Id,
                    Path = entry.Path,
                    ModId = entry.ModId,
                    Schema = null,
                    SchemaVersion = 0
                };

                // Quick read root attrs for schema/schema_version without loading entire doc
                try {
                    using var reader = XmlReader.Create(entry.Path, new XmlReaderSettings { IgnoreComments = true, IgnoreWhitespace = true, DtdProcessing = DtdProcessing.Ignore });
                    reader.MoveToContent();
                    if (reader.HasAttributes) {
                        var schemaAttr = reader.GetAttribute("schema");
                        if (!string.IsNullOrEmpty(schemaAttr)) meta.Schema = schemaAttr;
                        var svAttr = reader.GetAttribute("schema_version");
                        if (!string.IsNullOrEmpty(svAttr) && int.TryParse(svAttr, out var sv)) meta.SchemaVersion = sv;
                        else if (!string.IsNullOrEmpty(meta.Schema)) {
                            var at = meta.Schema.LastIndexOf('@');
                            if (at >= 0 && int.TryParse(meta.Schema.Substring(at + 1), out var sv2)) meta.SchemaVersion = sv2;
                        }
                    }
                } catch { /* ignore per-file errors here; validator will surface issues */ }

                index.Items.Add(meta);
                if (!index._byType.TryGetValue(meta.Type, out var list)) index._byType[meta.Type] = list = new List<DefMeta>(4);
                list.Add(meta);
                index._byKey[meta.Type + "." + meta.Id] = meta;
            }
            return index;
        }
    }
}

// ===== FILE: Assets/Scripts/Core/Defs/DefMeta.cs =====
namespace FantasyColony.Core.Defs {
    /// <summary>
    /// Lightweight metadata about a def used for validation and migrations.
    /// </summary>
    public sealed class DefMeta {
        public string Type;            // e.g., FactionDef
        public string Id;              // canonical id string
        public string Path;            // source file path
        public string ModId;           // owning mod
        public string Schema;          // e.g., "FactionDef@1" or null
        public int SchemaVersion;      // parsed version (fallback from Schema)
    }
}

// ===== FILE: Assets/Scripts/Core/Defs/Migrations/MigrationEngine.cs =====
using System;
using FantasyColony.Core.Services;
using UnityEngine;

namespace FantasyColony.Core.Defs.Migrations {
    public static class MigrationEngine {
        /// <summary>
        /// Returns number of defs that were logically migrated (metadata-only for now).
        /// </summary>
        public static int Run(Defs.DefIndex index) {
            int migrated = 0;
            foreach (var m in index.Items) {
                var (ok, current) = SchemaRegistry.TryGetCurrentVersion(m.Type);
                if (!ok) continue; // unknown types are allowed
                if (m.SchemaVersion == 0) continue; // missing handled by validator; do not auto-set
                if (m.SchemaVersion < current) {
                    migrated++;
                    Debug.Log($"[Defs] Migrated {m.Type}.{m.Id} from v{m.SchemaVersion} to v{current}");
                    // Future: data transforms on DOM; for now, we only log logical migration
                }
            }
            return migrated;
        }
    }
}

// ===== FILE: Assets/Scripts/Core/Defs/Migrations/SchemaRegistry.cs =====
using System.Collections.Generic;

namespace FantasyColony.Core.Defs.Migrations {
    /// <summary>
    /// Known def types and their current schema versions.
    /// Extend as new def families are introduced.
    /// </summary>
    public static class SchemaRegistry {
        private static readonly Dictionary<string, int> _current = new Dictionary<string, int> {
            { "FactionDef", 1 },
            { "ItemDef", 1 },
            { "BiomeDef", 1 },
            { "RecipeDef", 1 },
        };

        public static (bool ok, int version) TryGetCurrentVersion(string defType) {
            if (_current.TryGetValue(defType, out var v)) return (true, v);
            return (false, 0);
        }
    }
}

// ===== FILE: Assets/Scripts/Core/Defs/Validation/DefValidator.cs =====
using System.Collections.Generic;
using System.Xml;

namespace FantasyColony.Core.Defs.Validation {
    public static class DefValidator {
        public sealed class Result { public string Path; public string Message; public override string ToString()=> $"{Path}: {Message}"; }

        public static List<Result> Run(Defs.DefIndex index) {
            var results = new List<Result>();

            // R0: Duplicates within (Type, Id) across all mods
            var seen = new HashSet<string>();
            foreach (var m in index.Items) {
                var key = m.Type + "." + m.Id;
                if (!seen.Add(key)) results.Add(new Result { Path = m.Path, Message = $"Duplicate id for {m.Type}: '{m.Id}'" });
            }

            // Spec-driven validation
            foreach (var m in index.Items) {
                // Basic ID shape
                if (string.IsNullOrEmpty(m.Id) || !Defs.DefId.TryParse(m.Id.Contains('.') ? m.Id : $"{m.Type}.{m.Id}", out _)) {
                    results.Add(new Result { Path = m.Path, Message = $"Id not well-formed: '{m.Id}' (expected modid.{m.Type}.Name or {m.Type}.Name)" });
                    continue; // other checks will be noisy without an id
                }

                // Pick spec: declared version or current known
                SchemaSpec spec = null;
                if (m.SchemaVersion > 0) {
                    SchemaCatalog.TryGet(m.Type, m.SchemaVersion, out spec);
                } else {
                    SchemaCatalog.TryGetCurrent(m.Type, out spec);
                }

                // Version sanity vs current
                var (curOk, curVer) = Defs.Migrations.SchemaRegistry.TryGetCurrentVersion(m.Type);
                if (m.SchemaVersion > 0 && curOk && m.SchemaVersion > curVer) {
                    results.Add(new Result { Path = m.Path, Message = $"Schema version {m.SchemaVersion} ahead of supported {curVer} for {m.Type}" });
                }

                // Read minimal XML into attr/elem maps (root + first-level children)
                var attrs = new Dictionary<string,string>();
                var elems = new Dictionary<string,string>();
                try {
                    using var xr = XmlReader.Create(m.Path, new XmlReaderSettings { IgnoreComments = true, IgnoreWhitespace = true, DtdProcessing = DtdProcessing.Ignore });
                    xr.MoveToContent();
                    if (xr.HasAttributes) {
                        while (xr.MoveToNextAttribute()) attrs[xr.Name] = xr.Value;
                        xr.MoveToElement();
                    }
                    if (!xr.IsEmptyElement) {
                        xr.ReadStartElement();
                        int depth0 = xr.Depth;
                        while (!xr.EOF && xr.Depth <= depth0 + 1) {
                            if (xr.NodeType == XmlNodeType.Element) {
                                var name = xr.Name;
                                string val = string.Empty;
                                if (!xr.IsEmptyElement) val = xr.ReadElementContentAsString(); else xr.Read();
                                if (!elems.ContainsKey(name)) elems[name] = val;
                                continue;
                            }
                            xr.Read();
                        }
                    }
                } catch { /* per-file parsing issues are tolerated in lenient mode */ }

                if (spec == null) {
                    // No spec found; warn once for this file, but don't block
                    results.Add(new Result { Path = m.Path, Message = $"No schema spec found for {m.Type}@{(m.SchemaVersion>0?m.SchemaVersion:0)}; skipping spec checks" });
                    continue;
                }

                // Required fields present
                if (spec.required != null && spec.required.Length > 0) {
                    for (int i = 0; i < spec.required.Length; i++) {
                        var reqName = spec.required[i];
                        var fs = FindField(spec, reqName);
                        bool present = false;
                        if (fs != null && fs.kind == "attr") present = attrs.ContainsKey(reqName);
                        else if (fs != null && fs.kind == "elem") present = elems.ContainsKey(reqName);
                        else
                            present = attrs.ContainsKey(reqName) || elems.ContainsKey(reqName);
                        if (!present) results.Add(new Result { Path = m.Path, Message = $"Missing required field '{reqName}'" });
                    }
                }

                // Field type checks where present
                if (spec.fields != null) {
                    for (int i = 0; i < spec.fields.Count; i++) {
                        var fs = spec.fields[i];
                        string v = null; bool has = false;
                        if (fs.kind == "attr") { has = attrs.TryGetValue(fs.name, out v); }
                        else { has = elems.TryGetValue(fs.name, out v); }
                        if (!has) continue; // not present; required handling above
                        var (ok, err) = TypeChecks.Check(fs, v, index);
                        if (!ok) results.Add(new Result { Path = m.Path, Message = $"Field '{fs.name}': {err}" });
                    }
                }
            }

            return results;
        }

        private static FieldSpec FindField(SchemaSpec spec, string name) {
            if (spec.fields == null) return null;
            for (int i=0;i<spec.fields.Count;i++) if (spec.fields[i].name == name) return spec.fields[i];
            return null;
        }
    }
}

// ===== FILE: Assets/Scripts/Core/Defs/Validation/SchemaCatalog.cs =====
using System;
using System.Collections.Generic;
using System.IO;
using UnityEngine;

namespace FantasyColony.Core.Defs.Validation {
    /// <summary>
    /// Loads and caches per-type schema files located in StreamingAssets and Mods.
    /// </summary>
    public static class SchemaCatalog {
        private static readonly Dictionary<string, Dictionary<int, SchemaSpec>> _map = new(); // type -> version -> spec
        private static bool _loaded;

        public static void EnsureLoadedFromIndex(Defs.DefIndex index) {
            if (_loaded) return;
            try {
                // Game-bundled schemas
                var gameDir = Path.Combine(Application.streamingAssetsPath, "Defs", "Schemas");
                LoadFromDir(gameDir);

                // Mod-provided schemas (infer mod root from def file paths in index)
                if (index != null) {
                    var roots = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
                    foreach (var m in index.Items) {
                        var root = FindDefsRoot(Path.GetDirectoryName(m.Path));
                        if (!string.IsNullOrEmpty(root) && roots.Add(root)) {
                            var dir = Path.Combine(root, "Defs", "Schemas");
                            LoadFromDir(dir);
                        }
                    }
                }
            } catch (Exception e) {
                Debug.LogWarning($"SchemaCatalog load issue: {e.Message}");
            }
            _loaded = true;
        }

        private static void LoadFromDir(string dir) {
            if (string.IsNullOrEmpty(dir) || !Directory.Exists(dir)) return;
            var files = Directory.GetFiles(dir, "*.schema.json", SearchOption.AllDirectories);
            for (int i = 0; i < files.Length; i++) LoadFile(files[i]);
        }

        private static string FindDefsRoot(string startDir) {
            try {
                var dir = startDir;
                while (!string.IsNullOrEmpty(dir)) {
                    var defsDir = Path.Combine(dir, "Defs");
                    if (Directory.Exists(defsDir)) return dir;
                    dir = Path.GetDirectoryName(dir);
                }
            } catch { }
            return null;
        }

        private static void LoadFile(string path) {
            try {
                var json = File.ReadAllText(path);
                var spec = JsonUtility.FromJson<SchemaSpec>(json);
                if (spec == null || string.IsNullOrEmpty(spec.type) || spec.version <= 0) return;

                // Mark presence of numeric bounds so zero is enforceable
                try {
                    if (spec.fields != null) {
                        foreach (var fs in spec.fields) {
                            if (string.IsNullOrEmpty(fs.name)) continue;
                            var nameEsc = System.Text.RegularExpressions.Regex.Escape(fs.name);
                            var rx = new System.Text.RegularExpressions.Regex("{[^{}]*\\\"name\\\"\\s*:\\s*\\\"" + nameEsc + "\\\"[^{}]*}", System.Text.RegularExpressions.RegexOptions.CultureInvariant);
                            var m = rx.Match(json);
                            if (m.Success) {
                                var slice = m.Value;
                                fs.hasMin = slice.Contains("\\\"min\\\"");
                                fs.hasMax = slice.Contains("\\\"max\\\"");
                            }
                        }
                    }
                } catch { /* best-effort; missing flags default to false */ }
                var tkey = spec.type;
                if (!_map.TryGetValue(tkey, out var byVer)) _map[tkey] = byVer = new Dictionary<int, SchemaSpec>();
                // First-in wins; later duplicates are ignored but warned
                if (byVer.ContainsKey(spec.version)) {
                    Debug.LogWarning($"Duplicate schema {spec.type}@{spec.version} at {path}; keeping first loaded.");
                    return;
                }
                byVer[spec.version] = spec;
            } catch (Exception e) {
                Debug.LogWarning($"Failed to load schema '{path}': {e.Message}");
            }
        }

        public static bool TryGet(string defType, int version, out SchemaSpec spec) {
            spec = null;
            if (string.IsNullOrEmpty(defType) || version <= 0) return false;
            if (_map.TryGetValue(defType, out var byVer) && byVer.TryGetValue(version, out spec)) return true;
            return false;
        }

        public static bool TryGetCurrent(string defType, out SchemaSpec spec) {
            spec = null;
            var (ok, v) = FantasyColony.Core.Defs.Migrations.SchemaRegistry.TryGetCurrentVersion(defType);
            if (!ok) return false;
            return TryGet(defType, v, out spec);
        }
    }
}

// ===== FILE: Assets/Scripts/Core/Defs/Validation/SchemaSpec.cs =====
using System;
using System.Collections.Generic;

namespace FantasyColony.Core.Defs.Validation {
    /// <summary>
    /// JSON-deserializable schema spec for a single Def type & version.
    /// Stored as StreamingAssets/Defs/Schemas/<DefType>@<version>.schema.json
    /// </summary>
    [Serializable]
    public sealed class SchemaSpec {
        public string type;      // e.g., "FactionDef"
        public int version;      // e.g., 1
        public string[] required; // names of required fields
        public List<FieldSpec> fields; // all declared fields
    }

    [Serializable]
    public sealed class FieldSpec {
        public string name;      // field name as it appears in XML
        public string kind;      // "attr" or "elem"
        public string type;      // string|int|float|bool|color|enum|defref|id|list
        public string of;        // element type for lists (optional)
        public string target;    // for defref: target DefType
        public string[] values;  // for enum: allowed values
        public int min;          // numeric bounds (optional)
        public int max;
        public int minLength;    // for string
        [NonSerialized] public bool hasMin; // runtime: whether 'min' was present in JSON
        [NonSerialized] public bool hasMax; // runtime: whether 'max' was present in JSON
        public string @default;  // optional default as text
    }
}

// ===== FILE: Assets/Scripts/Core/Defs/Validation/TypeChecks.cs =====
using System;
using System.Globalization;

namespace FantasyColony.Core.Defs.Validation {
    internal static class TypeChecks {
        public static (bool ok, string err) Check(FieldSpec fs, string value, Defs.DefIndex index) {
            var t = (fs.type ?? "string").ToLowerInvariant();
            switch (t) {
                case "string": return CheckString(value, fs);
                case "id":     return CheckId(value);
                case "int":    return CheckInt(value, fs);
                case "float":  return CheckFloat(value, fs);
                case "bool":   return CheckBool(value);
                case "color":  return CheckColor(value);
                case "enum":   return CheckEnum(value, fs);
                case "defref": return CheckDefRef(value, fs, index);
                case "list":   return (true, null); // future: validate list items
                default:        return (true, null);
            }
        }

        private static (bool,string) CheckString(string v, FieldSpec fs) {
            if (v == null) return (false, "missing string");
            if (fs.minLength > 0 && v.Length < fs.minLength) return (false, $"string too short (min {fs.minLength})");
            return (true, null);
        }
        private static (bool,string) CheckId(string v) {
            if (string.IsNullOrEmpty(v)) return (false, "missing id");
            return (FantasyColony.Core.Defs.DefId.TryParse(v, out _)) ? (true, null) : (false, "id not well-formed");
        }
        private static (bool,string) CheckInt(string v, FieldSpec fs) {
            if (!int.TryParse(v, NumberStyles.Integer, CultureInfo.InvariantCulture, out var i)) return (false, "not an int");
            if (fs.hasMin && i < fs.min) return (false, $"int < min {fs.min}");
            if (fs.hasMax && i > fs.max) return (false, $"int > max {fs.max}");
            return (true, null);
        }
        private static (bool,string) CheckFloat(string v, FieldSpec fs) {
            if (!float.TryParse(v, NumberStyles.Float, CultureInfo.InvariantCulture, out var f)) return (false, "not a float");
            if (fs.hasMin && f < fs.min) return (false, $"float < min {fs.min}");
            if (fs.hasMax && f > fs.max) return (false, $"float > max {fs.max}");
            return (true, null);
        }
        private static (bool,string) CheckBool(string v) {
            if (!bool.TryParse(v, out _)) return (false, "not a bool");
            return (true, null);
        }
        private static (bool,string) CheckColor(string v) {
            if (string.IsNullOrEmpty(v)) return (false, "missing color");
            // Accept #RRGGBB or #RRGGBBAA
            if (v.StartsWith("#") && (v.Length == 7 || v.Length == 9)) return (true, null);
            return (false, "color must be #RRGGBB or #RRGGBBAA");
        }
        private static (bool,string) CheckEnum(string v, FieldSpec fs) {
            if (fs.values == null || fs.values.Length == 0) return (true, null);
            for (int i=0;i<fs.values.Length;i++) if (string.Equals(v, fs.values[i], StringComparison.Ordinal)) return (true, null);
            return (false, $"enum value '{v}' not in [{string.Join(",", fs.values)}]");
        }
        private static (bool,string) CheckDefRef(string v, FieldSpec fs, Defs.DefIndex index) {
            if (string.IsNullOrEmpty(v)) return (false, "missing defref");
            string type, id;
            var parts = v.Split('.');
            if (parts.Length == 2) { type = parts[0]; id = parts[1]; }
            else if (parts.Length == 3) { type = parts[1]; id = parts[2]; }
            else return (false, "defref must be Type.Id or modid.Type.Name");
            if (!string.IsNullOrEmpty(fs.target) && !string.Equals(type, fs.target, StringComparison.Ordinal))
                return (false, $"defref type '{type}' expected '{fs.target}'");
            var ok = index.Find(type, id) != null;
            return ok ? (true, null) : (false, $"missing target {type}.{id}");
        }
    }
}

// ===== FILE: Assets/Scripts/Core/Defs/Validation/ValidationMode.cs =====
namespace FantasyColony.Core.Defs.Validation {
    /// <summary>
    /// Controls how strict validation is treated at runtime.
    /// Lenient is default for player builds; Strict is useful in Editor/CI.
    /// </summary>
    public enum ValidationMode {
        Lenient = 0,
        Strict = 1,
    }
}

// ===== FILE: Assets/Scripts/Core/GlobalShortcuts.cs =====
using UnityEngine;
using FantasyColony.UI.Router;
using FantasyColony.UI.Screens;
#if ENABLE_INPUT_SYSTEM
using UnityEngine.InputSystem;
#endif

namespace FantasyColony.Core {
    /// <summary>
    /// Lightweight global hotkeys available in all builds.
    /// Currently: F9 opens the Boot Report screen.
    /// </summary>
    public sealed class GlobalShortcuts : MonoBehaviour {
        private void Awake() {
            // Attach to AppHost GameObject; keep across restarts
            DontDestroyOnLoad(gameObject);
        }

        private void Update() {
            // Open Boot Report
            bool pressed = false;
#if ENABLE_INPUT_SYSTEM
            var kb = Keyboard.current;
            if (kb != null && kb.f9Key.wasPressedThisFrame) pressed = true;
#endif
#if ENABLE_LEGACY_INPUT_MANAGER
            if (!pressed && UnityEngine.Input.GetKeyDown(KeyCode.F9)) pressed = true;
#endif
            if (pressed) {
                var router = UIRouter.Current;
                if (router == null) {
                    // Fallback if static Current isn't set yet
                    var host = AppHost.Instance;
                    router = host != null ? host.Router : null;
                }
                if (router != null) router.Push<BootReportScreen>();
                else Debug.LogWarning("[GlobalShortcuts] No UIRouter available to open Boot Report.");
            }
        }
    }
}

// ===== FILE: Assets/Scripts/Core/Input/InputRouter.cs =====
using UnityEngine;

namespace FantasyColony.Core.Input
{
    /// <summary>
    /// Placeholder router for the new Input System. No-ops if the package is missing.
    /// </summary>
    public static class InputRouter
    {
        public static void EnableMenuMap()
        {
#if ENABLE_INPUT_SYSTEM
            // Hook up your InputActionAsset and enable the UI/menu action map here.
#endif
        }

        public static void DisableAll()
        {
#if ENABLE_INPUT_SYSTEM
            // Disable action maps here.
#endif
        }
    }
}

// ===== FILE: Assets/Scripts/Core/Mods/ModDiscovery.cs =====
using System;
using System.Collections.Generic;
using System.IO;
using UnityEngine;

namespace FantasyColony.Core.Mods
{
    public class ModInfo
    {
        public string id;
        public string path;
        public override string ToString() => id;
    }

    public static class ModDiscovery
    {
        /// <summary>
        /// Discover mods in StreamingAssets/Mods and persistentDataPath/Mods. Non-fatal on errors.
        /// </summary>
        public static List<ModInfo> Discover()
        {
            var list = new List<ModInfo>();
            TryDiscover(Path.Combine(Application.streamingAssetsPath, "Mods"), list);
            TryDiscover(Path.Combine(Application.persistentDataPath, "Mods"), list);
            return list;
        }

        private static void TryDiscover(string root, List<ModInfo> into)
        {
            try
            {
                if (string.IsNullOrEmpty(root) || !Directory.Exists(root)) return;
                foreach (var dir in Directory.GetDirectories(root))
                {
                    var id = Path.GetFileName(dir);
                    into.Add(new ModInfo { id = id, path = dir });
                }
            }
            catch (Exception e)
            {
                Debug.LogWarning($"Mod discovery error at {root}: {e.Message}");
            }
        }
    }
}

// ===== FILE: Assets/Scripts/Core/Mods/XmlDefLoader.cs =====
using System;
using System.Collections.Generic;
using UnityEngine;
using FantasyColony.Core.Services;

namespace FantasyColony.Core.Mods {
    public class DefError {
        public string Path;
        public string Message;
        public override string ToString() => $"{Path}: {Message}";
    }

    /// <summary>
    /// Lenient XML loader: scans *.xml under each mod and registers their root elements by name+id.
    /// </summary>
    public static class XmlDefLoader {
        // Existing signature used by boot pipeline
        public static void Load(List<ModInfo> mods, DefRegistry registry, List<DefError> errors) {
            // current: iterate XML files under each mod's Defs folder, register Type/Id → path
            // note: per-file schema metadata is now collected later by DefIndex for validation/migrations
            foreach (var mod in mods) {
                var dir = System.IO.Path.Combine(mod.path, "Defs");
                if (!System.IO.Directory.Exists(dir)) continue;
                foreach (var file in System.IO.Directory.EnumerateFiles(dir, "*.xml", System.IO.SearchOption.AllDirectories)) {
                    try {
                        using var xr = System.Xml.XmlReader.Create(file, new System.Xml.XmlReaderSettings { IgnoreComments = true, IgnoreWhitespace = true, DtdProcessing = System.Xml.DtdProcessing.Ignore });
                        xr.MoveToContent();
                        var type = xr.Name; // root element name is type
                        var id = xr.GetAttribute("id") ?? string.Empty;
                        if (string.IsNullOrEmpty(id)) {
                            errors?.Add(new DefError { Path = file, Message = $"Missing id for type '{type}'" });
                            continue;
                        }
                        registry.Register(type, id, file, mod.id);
                    } catch (Exception e) {
                        errors?.Add(new DefError { Path = file, Message = e.Message });
                    }
                }
            }
        }
    }
}

// ===== FILE: Assets/Scripts/Core/ServiceRegistry.cs =====
using System;
using System.Collections.Generic;

namespace FantasyColony.Core
{
    public sealed class ServiceRegistry
    {
        private readonly Dictionary<Type, object> _map = new();

        public void Register<T>(T impl) where T : class
        {
            _map[typeof(T)] = impl ?? throw new ArgumentNullException(nameof(impl));
        }

        public T Get<T>() where T : class
        {
            if (_map.TryGetValue(typeof(T), out var o) && o is T t)
                return t;
            throw new InvalidOperationException($"Service not registered: {typeof(T).Name}");
        }

        /// <summary>
        /// Non-throwing lookup for fail-soft flows (player builds).
        /// </summary>
        public bool TryGet<T>(out T service) where T : class
        {
            if (_map.TryGetValue(typeof(T), out var o) && o is T t)
            {
                service = t;
                return true;
            }
            service = null;
            return false;
        }

        /// <summary>
        /// Returns true if a service of type T is registered.
        /// </summary>
        public bool Has<T>() where T : class => _map.ContainsKey(typeof(T));

        /// <summary>
        /// Optional unregistration helper. Returns true if removed.
        /// </summary>
        public bool Unregister<T>() where T : class => _map.Remove(typeof(T));
    }
}

// ===== FILE: Assets/Scripts/Core/Services/AddressablesAssetProvider.cs =====
#if ADDRESSABLES
using UnityEngine;
using UnityEngine.AddressableAssets;
using UnityEngine.ResourceManagement.AsyncOperations;

namespace FantasyColony.Core.Services {
    /// <summary>
    /// Optional Addressables-backed asset provider.
    /// Compiles only when ADDRESSABLES define is present.
    /// </summary>
    public sealed class AddressablesAssetProvider : IAssetProvider {
        private static bool _initialized;

        public static void EnsureInitialized() {
            if (_initialized) return;
            try {
                var h = Addressables.InitializeAsync();
                h.Completed += _ => { _initialized = true; };
            } catch { /* swallow; fail-soft */ }
        }

        public Sprite LoadSprite(string virtualPath) {
            EnsureInitialized();
            return LoadSync<Sprite>(virtualPath);
        }

        public AudioClip LoadAudio(string virtualPath) {
            EnsureInitialized();
            return LoadSync<AudioClip>(virtualPath);
        }

        public TextAsset LoadText(string virtualPath) {
            EnsureInitialized();
            return LoadSync<TextAsset>(virtualPath);
        }

        private static T LoadSync<T>(string key) where T : UnityEngine.Object {
            try {
                AsyncOperationHandle<T> handle = Addressables.LoadAssetAsync<T>(key);
                return handle.WaitForCompletion();
            } catch { return null; }
        }
    }
}
#endif

// ===== FILE: Assets/Scripts/Core/Services/AudioService.cs =====
using System;
using UnityEngine;

namespace FantasyColony.Core.Services
{
    /// <summary>
    /// Lightweight audio bootstrap: one BGM source and one-shot SFX source.
    /// No Addressables; uses Resources for now. Safe no-ops if assets are missing.
    /// </summary>
    public class AudioService : MonoBehaviour
    {
        private static AudioService _instance;
        public static AudioService Instance
        {
            get
            {
                if (_instance == null)
                {
                    var go = new GameObject("__AudioService");
                    DontDestroyOnLoad(go);
                    _instance = go.AddComponent<AudioService>();
                }
                return _instance;
            }
        }

        private AudioSource _bgm;
        private AudioSource _sfx;

        private float _volMaster = 1f, _volMusic = 1f, _volSfx = 1f;

        private void Awake()
        {
            // Duplicate guard: prefer the first instance
            if (_instance != null && _instance != this)
            {
                Destroy(gameObject);
                return;
            }
            _instance = this;

            _bgm = gameObject.AddComponent<AudioSource>();
            _bgm.loop = true;
            _bgm.playOnAwake = false;

            _sfx = gameObject.AddComponent<AudioSource>();
            _sfx.loop = false;
            _sfx.playOnAwake = false;
        }

        public void SetVolume(string channel, float linear01)
        {
            linear01 = Mathf.Clamp01(linear01);
            switch (channel)
            {
                case "master": _volMaster = linear01; break;
                case "music": _volMusic = linear01; break;
                case "sfx": _volSfx = linear01; break;
            }
            ApplyVolumes();
        }

        private void ApplyVolumes()
        {
            if (_bgm != null) _bgm.volume = _volMaster * _volMusic;
            if (_sfx != null) _sfx.volume = _volMaster * _volSfx;
        }

        public void PlayBgm(string resourceKey)
        {
            try
            {
                var clip = Resources.Load<AudioClip>(resourceKey);
                if (clip == null)
                {
                    Debug.LogWarning($"AudioService: BGM not found at Resources/{resourceKey}");
                    return;
                }
                _bgm.clip = clip;
                ApplyVolumes();
                _bgm.Play();
            }
            catch (Exception e)
            {
                Debug.LogWarning($"AudioService PlayBgm error: {e.Message}");
            }
        }

        public void StopBgm()
        {
            if (_bgm != null) _bgm.Stop();
        }

        public void PlaySfx(string resourceKey)
        {
            try
            {
                var clip = Resources.Load<AudioClip>(resourceKey);
                if (clip == null)
                {
                    Debug.LogWarning($"AudioService: SFX not found at Resources/{resourceKey}");
                    return;
                }
                ApplyVolumes();
                _sfx.PlayOneShot(clip);
            }
            catch (Exception e)
            {
                Debug.LogWarning($"AudioService PlaySfx error: {e.Message}");
            }
        }
    }
}

// ===== FILE: Assets/Scripts/Core/Services/DefRegistry.cs =====
using System;
using System.Collections.Generic;
using UnityEngine;

namespace FantasyColony.Core.Services {
    /// <summary>
    /// Definition registry keyed by type then id, storing file path and mod id.
    /// </summary>
    public class DefRegistry {
        private static DefRegistry _instance;
        public static DefRegistry Instance => _instance ?? (_instance = new DefRegistry());

        public struct Entry {
            public string Type;
            public string Id;
            public string Path;
            public string ModId;
        }

        private readonly Dictionary<string, Dictionary<string, Entry>> _map = new(StringComparer.OrdinalIgnoreCase);

        public int Count { get; private set; }
        public int ConflictCount { get; private set; }

        public void Register(string type, string id, string filePath, string modId) {
            if (string.IsNullOrEmpty(type) || string.IsNullOrEmpty(id)) return;
            if (!_map.TryGetValue(type, out var inner)) {
                inner = new Dictionary<string, Entry>(StringComparer.OrdinalIgnoreCase);
                _map[type] = inner;
            }
            if (inner.TryGetValue(id, out var existing)) {
                ConflictCount++;
                Debug.LogWarning($"[Defs] Conflict for {type}/{id}: {existing.ModId} -> {modId} (file: {filePath})");
            }
            else { Count++; }
            inner[id] = new Entry { Type = type, Id = id, Path = filePath ?? string.Empty, ModId = modId };
        }

        // Legacy Add signature for backward compatibility
        public void Add(string type, string id, string filePath) => Register(type, id, filePath, string.Empty);

        public bool TryGetPath(string type, string id, out string path) {
            path = null;
            if (string.IsNullOrEmpty(type) || string.IsNullOrEmpty(id)) return false;
            if (_map.TryGetValue(type, out var inner) && inner.TryGetValue(id, out var e)) {
                path = e.Path;
                return true;
            }
            return false;
        }

        public IEnumerable<Entry> All() {
            foreach (var inner in _map.Values)
                foreach (var e in inner.Values)
                    yield return e;
        }

        public IEnumerable<string> Types() => _map.Keys;

        public IEnumerable<string> Ids(string type) {
            if (_map.TryGetValue(type, out var inner)) return inner.Keys;
            return Array.Empty<string>();
        }
    }
}

// ===== FILE: Assets/Scripts/Core/Services/IAssetProvider.cs =====
using UnityEngine;

namespace FantasyColony.Core.Services
{
    public interface IAssetProvider
    {
        Sprite LoadSprite(string virtualPath);
        AudioClip LoadAudio(string virtualPath);
        TextAsset LoadText(string virtualPath);
    }

    public sealed class ResourcesAssetProvider : IAssetProvider
    {
        public Sprite LoadSprite(string virtualPath)
        {
            return Resources.Load<Sprite>(virtualPath);
        }

        public AudioClip LoadAudio(string virtualPath)
        {
            return Resources.Load<AudioClip>(virtualPath);
        }

        public TextAsset LoadText(string virtualPath)
        {
            return Resources.Load<TextAsset>(virtualPath);
        }
    }
}

// ===== FILE: Assets/Scripts/Core/Services/IConfigService.cs =====
namespace FantasyColony.Core.Services
{
    public interface IConfigService
    {
        string Get(string key, string fallback = "");
        void Set(string key, string value);
        void Save();
    }

    /// <summary>
    /// Minimal no-op config for early boot. Replace later with a JSON-backed service.
    /// </summary>
    public sealed class DummyConfigService : IConfigService
    {
        public string Get(string key, string fallback = "") => fallback;
        public void Set(string key, string value) { }
        public void Save() { }
    }
}

// ===== FILE: Assets/Scripts/Core/Services/IEventBus.cs =====
using System;
using System.Collections.Generic;

namespace FantasyColony.Core.Services
{
    public interface IEventBus
    {
        void Subscribe<T>(Action<T> handler);
        void Unsubscribe<T>(Action<T> handler);
        void Publish<T>(T evt);
    }

    public sealed class SimpleEventBus : IEventBus
    {
        private readonly Dictionary<Type, Delegate> _subs = new();

        public void Subscribe<T>(Action<T> handler)
        {
            if (_subs.TryGetValue(typeof(T), out var d))
                _subs[typeof(T)] = Delegate.Combine(d, handler);
            else
                _subs[typeof(T)] = handler;
        }

        public void Unsubscribe<T>(Action<T> handler)
        {
            if (_subs.TryGetValue(typeof(T), out var d))
            {
                var res = Delegate.Remove(d, handler);
                if (res == null) _subs.Remove(typeof(T));
                else _subs[typeof(T)] = res;
            }
        }

        public void Publish<T>(T evt)
        {
            if (_subs.TryGetValue(typeof(T), out var d) && d is Action<T> a)
            {
                a.Invoke(evt);
            }
        }
    }
}

// ===== FILE: Assets/Scripts/Core/Services/ILogger.cs =====
using System;
using System.IO;
using UnityEngine;

namespace FantasyColony.Core.Services
{
    public interface ILogger
    {
        void Info(string msg);
        void Warn(string msg);
        void Error(string msg, Exception ex = null);
    }

    public sealed class FileLogger : ILogger
    {
        private readonly string _path;

        public FileLogger()
        {
            var dir = Path.Combine(UnityEngine.Application.persistentDataPath, "logs");
            if (!Directory.Exists(dir)) Directory.CreateDirectory(dir);
            _path = Path.Combine(dir, $"log_{DateTime.Now:yyyyMMdd_HHmmss}.txt");
            Info($"FantasyColony boot {UnityEngine.Application.version} Unity {UnityEngine.Application.unityVersion}");
        }

        public void Info(string msg)
        {
            Debug.Log(msg);
            Append("INFO", msg);
        }

        public void Warn(string msg)
        {
            Debug.LogWarning(msg);
            Append("WARN", msg);
        }

        public void Error(string msg, Exception ex = null)
        {
            Debug.LogError(msg);
            if (ex != null) msg += "\n" + ex;
            Append("ERROR", msg);
        }

        private void Append(string level, string msg)
        {
            try
            {
                File.AppendAllText(_path, $"[{DateTime.Now:HH:mm:ss}] {level} {msg}\n");
            }
            catch { /* ignore logging failures */ }
        }
    }
}

// ===== FILE: Assets/Scripts/Core/Services/JsonConfigService.cs =====
using System;
using System.Collections.Generic;
using System.IO;
using UnityEngine;

namespace FantasyColony.Core.Services
{
    /// <summary>
    /// Minimal JSON-backed config service with string Get/Set to avoid API churn.
    /// </summary>
    public class JsonConfigService : IConfigService
    {
        private static JsonConfigService _instance;
        public static JsonConfigService Instance => _instance ?? (_instance = new JsonConfigService());

        private readonly Dictionary<string, string> _map = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
        private string Path => System.IO.Path.Combine(Application.persistentDataPath, "config.json");

        public void Load()
        {
            try
            {
                if (!File.Exists(Path)) return;
                var json = File.ReadAllText(Path);
                var data = JsonUtility.FromJson<Bag>(json);
                _map.Clear();
                if (data != null && data.keys != null)
                {
                    for (int i = 0; i < data.keys.Length; i++)
                    {
                        var k = data.keys[i];
                        var v = (data.values != null && i < data.values.Length) ? data.values[i] : string.Empty;
                        if (!string.IsNullOrEmpty(k)) _map[k] = v ?? string.Empty;
                    }
                }
            }
            catch (Exception e)
            {
                Debug.LogWarning($"JsonConfigService load error: {e.Message}");
            }
        }

        public void Save()
        {
            try
            {
                var bag = new Bag
                {
                    keys = new string[_map.Count],
                    values = new string[_map.Count]
                };
                int idx = 0;
                foreach (var kv in _map)
                {
                    bag.keys[idx] = kv.Key;
                    bag.values[idx] = kv.Value;
                    idx++;
                }
                var json = JsonUtility.ToJson(bag, true);
                var dir = System.IO.Path.GetDirectoryName(Path);
                if (!string.IsNullOrEmpty(dir)) Directory.CreateDirectory(dir);
                var tmp = Path + ".tmp";
                try
                {
                    File.WriteAllText(tmp, json);
                    // Atomic replace when available (PC platforms)
#if UNITY_2021_2_OR_NEWER
                    var bak = Path + ".bak";
                    File.Replace(tmp, Path, bak, true);
#else
                    // Fallback: best-effort replace
                    if (File.Exists(Path)) File.Delete(Path);
                    File.Move(tmp, Path);
#endif
                }
                finally { if (File.Exists(tmp)) { try { File.Delete(tmp); } catch { } } }
            }
            catch (Exception e)
            {
                Debug.LogWarning($"JsonConfigService save error: {e.Message}");
            }
        }

        public string Get(string key, string fallback = "")
        {
            if (string.IsNullOrEmpty(key)) return fallback;
            return _map.TryGetValue(key, out var v) ? v : fallback;
        }

        public FantasyColony.Core.Defs.Validation.ValidationMode GetValidationMode()
        {
            var s = Get("validation_mode", "lenient").ToLowerInvariant();
            return (s == "strict") ? FantasyColony.Core.Defs.Validation.ValidationMode.Strict : FantasyColony.Core.Defs.Validation.ValidationMode.Lenient;
        }

        public void Set(string key, string value) {
            _map[key] = value ?? string.Empty;
            // Optional: persist to disk here if desired.
        }

        [Serializable]
        private class Bag
        {
            public string[] keys;
            public string[] values;
        }
    }
}

// ===== FILE: Assets/Scripts/Core/Services/JsonSaveService.cs =====
using System;
using System.Collections.Generic;
using System.IO;
using System.Globalization;
using UnityEngine;

namespace FantasyColony.Core.Services
{
    public struct SaveSlotMeta
    {
        public string slotId;
        public string displayName;
        public DateTime lastPlayedUtc;
        public string version;
    }

    /// <summary>
    /// Skeleton save service: only reads metadata from disk so the Main Menu can react.
    /// </summary>
    public class JsonSaveService
    {
        private static JsonSaveService _instance;
        public static JsonSaveService Instance => _instance ?? (_instance = new JsonSaveService());

        private readonly List<SaveSlotMeta> _cache = new List<SaveSlotMeta>();
        public IReadOnlyList<SaveSlotMeta> Slots => _cache;

        private string Root => Path.Combine(Application.persistentDataPath, "saves");

        public void RefreshCache()
        {
            _cache.Clear();
            try
            {
                if (!Directory.Exists(Root)) return;
                foreach (var dir in Directory.GetDirectories(Root))
                {
                    var slotId = Path.GetFileName(dir);
                    var metaPath = Path.Combine(dir, "meta.json");
                    if (!File.Exists(metaPath)) continue;
                    try
                    {
                        var json = File.ReadAllText(metaPath);
                        var meta = JsonUtility.FromJson<SlotBag>(json) ?? new SlotBag();
                        var when = DateTimeOffset.TryParseExact(meta.lastPlayedUtc, "O", CultureInfo.InvariantCulture, DateTimeStyles.AssumeUniversal, out var dto)
                            ? dto.UtcDateTime : DateTime.UtcNow;
                        _cache.Add(new SaveSlotMeta
                        {
                            slotId = slotId,
                            displayName = string.IsNullOrEmpty(meta.displayName) ? slotId : meta.displayName,
                            lastPlayedUtc = when,
                            version = meta.version ?? "unknown"
                        });
                    }
                    catch (Exception e)
                    {
                        Debug.LogWarning($"Bad save meta in {dir}: {e.Message}");
                    }
                }
                _cache.Sort((a, b) => b.lastPlayedUtc.CompareTo(a.lastPlayedUtc));
            }
            catch (Exception e)
            {
                Debug.LogWarning($"Save discovery error: {e.Message}");
            }
        }

        public bool HasAnySaves() => _cache.Count > 0;

        [Serializable]
        private class SlotBag
        {
            public string displayName;
            public string lastPlayedUtc;
            public string version;
        }
    }
}

// ===== FILE: Assets/Scripts/Core/Services/LocService.cs =====
using System;
using System.Collections.Generic;
using UnityEngine;
using FantasyColony.Core;

namespace FantasyColony.Core.Services
{
    /// <summary>
    /// Minimal localization service. Loads Resources/Localization/{lang}/strings.json (TextAsset).
    /// Falls back to English or the key itself.
    /// </summary>
    public class LocService
    {
        private static LocService _instance;
        public static LocService Instance => _instance ?? (_instance = new LocService());

        private readonly Dictionary<string, string> _map = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
        public string Language { get; private set; } = "en";

        public void SetLanguage(string lang)
        {
            Language = string.IsNullOrEmpty(lang) ? "en" : lang;
            Load(Language);
        }

        public string Get(string key)
        {
            if (string.IsNullOrEmpty(key)) return string.Empty;
            return _map.TryGetValue(key, out var v) ? v : key;
        }

        private void Load(string lang)
        {
            _map.Clear();
            // Try target language
            if (!TryLoadInto(lang))
            {
                // Fallback to English
                if (!string.Equals(lang, "en", StringComparison.OrdinalIgnoreCase))
                {
                    TryLoadInto("en");
                }
            }
        }

        private bool TryLoadInto(string lang)
        {
            try
            {
                var path = $"Localization/{lang}/strings";
                TextAsset ta = null;
                // Prefer provider if available (mod- and backend-friendly)
                var host = AppHost.Instance;
                if (host != null && host.Services != null && host.Services.TryGet<IAssetProvider>(out var provider))
                {
                    ta = provider.LoadText(path);
                }
                // Fallback to Resources for safety
                if (ta == null)
                {
                    ta = Resources.Load<TextAsset>(path);
                }
                if (ta == null) return false;
                var bag = JsonUtility.FromJson<LocBag>(ta.text);
                if (bag?.entries != null)
                {
                    foreach (var e in bag.entries)
                    {
                        if (!string.IsNullOrEmpty(e.key)) _map[e.key] = e.value ?? string.Empty;
                    }
                }
                return true;
            }
            catch (Exception e)
            {
                Debug.LogWarning($"LocService load error: {e.Message}");
                return false;
            }
        }

        [Serializable]
        private class LocBag
        {
            public Entry[] entries;
        }

        [Serializable]
        private class Entry
        {
            public string key;
            public string value;
        }
    }
}

// ===== FILE: Assets/Scripts/Dev/DevLogOverlay.cs =====
using System;
using System.Collections.Generic;
using System.Collections.Concurrent;
using System.Text;
using System.Threading;
using UnityEngine;
//#if is allowed to safely reference the new Input System only when present
#if ENABLE_INPUT_SYSTEM
using UnityEngine.InputSystem;
#endif

/// <summary>
/// Lightweight, robust in-game developer log overlay.
/// - Captures all Unity logs via Application.logMessageReceivedThreaded
/// - Thread-safe queue -> main-thread list with ring buffer cap
/// - IMGUI-based so it works without any prefabs/scenes
/// - Filters (Debug/Warning/Errors), Pause, Auto-scroll, Stack Traces
/// - Copy Visible respects current filters
/// </summary>
public class DevLogOverlay : MonoBehaviour
{
    [Serializable]
    public struct LogEntry
    {
        public DateTime time;
        public int frame;
        public int threadId;
        public LogType type;
        public string message;
        public string stackTrace; // may be empty based on policy
        public string contextName; // optional
        public int count; // number of additional consecutive occurrences collapsed into this entry
    }

    private struct QueuedLog
    {
        public DateTime time;
        public int threadId;
        public LogType type;
        public string message;
        public string stackTrace;
        public string contextName;
    }

    private const int DefaultCapacity = 5000;
    private const int WindowPadding = 8;

    private static DevLogOverlay _instance;
    private static readonly object InstanceLock = new object();

    // Threaded producer -> main thread consumer
    private readonly ConcurrentQueue<QueuedLog> _incoming = new ConcurrentQueue<QueuedLog>();
    private readonly List<LogEntry> _entries = new List<LogEntry>(DefaultCapacity + 64);

    [Header("Buffer")]
    [Tooltip("Maximum number of entries kept in memory (oldest are dropped).")]
    public int capacity = DefaultCapacity;

    [Header("Filters")]
    public bool showDebug = true;
    public bool showWarnings = true;
    public bool showErrors = true; // includes Error, Assert, Exception

    [Header("Behavior")]
    public bool paused = false;
    public bool autoScroll = true;
    public bool showStackTraces = false; // toggles display; capture is controlled by Unity's stack trace policy
    public bool collapseRepeats = true; // when true, consecutive identical messages are collapsed

    private Vector2 _scroll;
    private bool _visible = true;
    private Rect _windowRect;
    private int _dockedCorner = 2; // 0=TL,1=TR,2=BL,3=BR

    private GUIStyle _rowStyle;
    private GUIStyle _rowStyleWarn;
    private GUIStyle _rowStyleError;
    private GUIStyle _tinyLabel;

    private string _search = "";
    private bool _focusSearch;

    // ---------- Public API ----------
    public static void Show()
    {
        EnsureInstance();
        _instance._visible = true;
    }

    public static void Hide()
    {
        if (_instance != null) _instance._visible = false;
    }

    public static void ToggleVisible()
    {
        EnsureInstance();
        _instance._visible = !_instance._visible;
    }

    public static bool IsVisible => _instance != null && _instance._visible;

    public static void Clear()
    {
        if (_instance == null) return;
        _instance._entries.Clear();
    }

    public static IReadOnlyList<LogEntry> Snapshot()
    {
        EnsureInstance();
        return _instance._entries;
    }

    private static void EnsureInstance()
    {
        if (_instance != null) return;
        lock (InstanceLock)
        {
            if (_instance != null) return;
            var go = new GameObject("__DevLogOverlay");
            DontDestroyOnLoad(go);
            _instance = go.AddComponent<DevLogOverlay>();
        }
    }

    // ---------- Unity lifecycle ----------
    private void Awake()
    {
        // Reasonable defaults: errors/exceptions include stacks; others off for perf until toggled
        try
        {
            Application.SetStackTraceLogType(LogType.Log, StackTraceLogType.None);
            Application.SetStackTraceLogType(LogType.Warning, StackTraceLogType.None);
            Application.SetStackTraceLogType(LogType.Error, StackTraceLogType.ScriptOnly);
            Application.SetStackTraceLogType(LogType.Assert, StackTraceLogType.ScriptOnly);
            Application.SetStackTraceLogType(LogType.Exception, StackTraceLogType.ScriptOnly);
        }
        catch { /* Some platforms may not support changing this at runtime */ }

        // Sensible default window size
        var w = Mathf.RoundToInt(Screen.width * 0.6f);
        var h = Mathf.RoundToInt(Screen.height * 0.5f);
        _windowRect = new Rect(WindowPadding, Screen.height - h - WindowPadding, w, h);
    }

    private void OnEnable()
    {
        Application.logMessageReceivedThreaded += OnLogMessageReceivedThreaded;
    }

    private void OnDisable()
    {
        Application.logMessageReceivedThreaded -= OnLogMessageReceivedThreaded;
    }

    private void Update()
    {
        // Drain queue to main-thread list
        while (_incoming.TryDequeue(out var q))
        {
            var e = new LogEntry
            {
                time = q.time,
                frame = Time.frameCount,
                threadId = q.threadId,
                type = q.type,
                message = q.message ?? string.Empty,
                stackTrace = q.stackTrace ?? string.Empty,
                contextName = q.contextName ?? string.Empty
            };

            if (!paused)
            {
                if (collapseRepeats && _entries.Count > 0)
                {
                    var lastIndex = _entries.Count - 1;
                    var lastEntry = _entries[lastIndex];
                    if (AreSameForCollapse(lastEntry, e))
                    {
                        lastEntry.count = lastEntry.count + 1;
                        // keep the most recent time/frame/thread for the collapsed line
                        lastEntry.time = e.time;
                        lastEntry.frame = e.frame;
                        lastEntry.threadId = e.threadId;
                        _entries[lastIndex] = lastEntry;
                    }
                    else
                    {
                        _entries.Add(e);
                    }
                }
                else
                {
                    _entries.Add(e);
                }

                if (_entries.Count > Mathf.Max(512, capacity))
                {
                    var over = _entries.Count - capacity;
                    _entries.RemoveRange(0, over);
                }
            }
        }

        // Handle hotkeys without throwing when only the new Input System is active
        HandleHotkeys();
    }

    private void OnGUI()
    {
        if (!_visible) return;

        EnsureStyles();

        // Simple draggable/dockable window
        _windowRect = GUI.Window(GetInstanceID(), _windowRect, DrawWindow, "Developer Log");

        // Keep inside screen
        _windowRect.x = Mathf.Clamp(_windowRect.x, WindowPadding, Screen.width - _windowRect.width - WindowPadding);
        _windowRect.y = Mathf.Clamp(_windowRect.y, WindowPadding, Screen.height - _windowRect.height - WindowPadding);
    }

    private void DrawWindow(int id)
    {
        GUILayout.BeginHorizontal();
        if (GUILayout.Button(paused ? "Resume" : "Pause", GUILayout.Height(24))) paused = !paused;
        if (GUILayout.Button("Clear", GUILayout.Height(24))) _entries.Clear();
        if (GUILayout.Button("Copy Visible", GUILayout.Height(24))) CopyVisibleToClipboard();
        if (GUILayout.Button("Close", GUILayout.Height(24))) _visible = false;
        GUILayout.FlexibleSpace();
        autoScroll = GUILayout.Toggle(autoScroll, "Auto-Scroll", GUILayout.Height(24));
        showStackTraces = GUILayout.Toggle(showStackTraces, "Stack Traces", GUILayout.Height(24));
        collapseRepeats = GUILayout.Toggle(collapseRepeats, "Collapse Repeats", GUILayout.Height(24));
        GUILayout.EndHorizontal();

        GUILayout.Space(4);

        GUILayout.BeginHorizontal();
        showDebug = GUILayout.Toggle(showDebug, "Debug", GUILayout.Width(80));
        showWarnings = GUILayout.Toggle(showWarnings, "Warning", GUILayout.Width(90));
        showErrors = GUILayout.Toggle(showErrors, "Errors", GUILayout.Width(80));

        GUILayout.Space(10);
        GUILayout.Label("Search:", GUILayout.Width(50));
        GUI.SetNextControlName("DevLogSearch");
        _search = GUILayout.TextField(_search ?? string.Empty, GUILayout.MinWidth(120));
        if (_focusSearch)
        {
            _focusSearch = false;
            GUI.FocusControl("DevLogSearch");
        }
        if (GUILayout.Button("×", GUILayout.Width(26))) { _search = string.Empty; GUI.FocusControl(null); }

        GUILayout.FlexibleSpace();
        if (GUILayout.Button("Dock", GUILayout.Width(60))) CycleDock();
        GUILayout.EndHorizontal();

        GUILayout.Space(4);

        // Header line
        GUILayout.BeginHorizontal();
        GUILayout.Label("Time", _tinyLabel, GUILayout.Width(90));
        GUILayout.Label("F", _tinyLabel, GUILayout.Width(36));
        GUILayout.Label("T", _tinyLabel, GUILayout.Width(28));
        GUILayout.Label("Level", _tinyLabel, GUILayout.Width(60));
        GUILayout.Label("Message", _tinyLabel);
        GUILayout.EndHorizontal();

        // List
        _scroll = GUILayout.BeginScrollView(_scroll, GUI.skin.box);

        var countBefore = _entries.Count;
        for (int i = 0; i < _entries.Count; i++)
        {
            var e = _entries[i];
            if (!PassesFilter(e)) continue;
            if (!PassesSearch(e)) continue;

            var style = StyleFor(e.type);
            GUILayout.BeginHorizontal();
            GUILayout.Label(e.time.ToString("HH:mm:ss.fff"), _tinyLabel, GUILayout.Width(90));
            GUILayout.Label(e.frame.ToString(), _tinyLabel, GUILayout.Width(36));
            GUILayout.Label(e.threadId.ToString(), _tinyLabel, GUILayout.Width(28));
            GUILayout.Label(LevelLabel(e.type), _tinyLabel, GUILayout.Width(60));
            if (e.count > 0)
            {
                // Show message with (xN) suffix for collapsed duplicates
                GUILayout.Label(string.Concat(e.message, " (x", (e.count + 1).ToString(), ")"), style);
            }
            else
            {
                GUILayout.Label(e.message, style);
            }
            GUILayout.EndHorizontal();

            if (showStackTraces && HasStack(e))
            {
                GUILayout.BeginHorizontal();
                GUILayout.Space(90 + 36 + 28 + 60 + 8);
                GUILayout.Label(e.stackTrace, GUI.skin.label);
                GUILayout.EndHorizontal();
            }
        }

        if (autoScroll && Event.current.type == EventType.Repaint)
        {
            _scroll.y = float.MaxValue;
        }

        GUILayout.EndScrollView();

        GUI.DragWindow(new Rect(0, 0, 10000, 20));
    }

    private void EnsureStyles()
    {
        if (_rowStyle == null)
        {
            _rowStyle = new GUIStyle(GUI.skin.label) { wordWrap = true };
            _rowStyleWarn = new GUIStyle(_rowStyle);
            _rowStyleError = new GUIStyle(_rowStyle);

            // Colorize severities for quick scanning
            _rowStyleWarn.normal.textColor = Color.yellow; // Warnings
            _rowStyleError.normal.textColor = Color.red;   // Errors/Exceptions/Asserts

            _tinyLabel = new GUIStyle(GUI.skin.label)
            {
                fontSize = 10,
                alignment = TextAnchor.UpperLeft
            };
        }
    }

    private void HandleHotkeys()
    {
#if ENABLE_INPUT_SYSTEM && !ENABLE_LEGACY_INPUT_MANAGER
        var kb = Keyboard.current;
        if (kb != null)
        {
            if (kb.f9Key.wasPressedThisFrame) ToggleVisible();
            if (kb.f10Key.wasPressedThisFrame) paused = !paused;
        }
#else
        if (Input.GetKeyDown(KeyCode.F9)) ToggleVisible();
        if (Input.GetKeyDown(KeyCode.F10)) paused = !paused;
#endif
    }

    private void CycleDock()
    {
        _dockedCorner = (_dockedCorner + 1) % 4;

        var w = _windowRect.width;
        var h = _windowRect.height;

        switch (_dockedCorner)
        {
            case 0: _windowRect.position = new Vector2(WindowPadding, WindowPadding); break; // TL
            case 1: _windowRect.position = new Vector2(Screen.width - w - WindowPadding, WindowPadding); break; // TR
            case 2: _windowRect.position = new Vector2(WindowPadding, Screen.height - h - WindowPadding); break; // BL
            case 3: _windowRect.position = new Vector2(Screen.width - w - WindowPadding, Screen.height - h - WindowPadding); break; // BR
        }
    }

    private GUIStyle StyleFor(LogType t)
    {
        switch (t)
        {
            case LogType.Warning: return _rowStyleWarn;
            case LogType.Error:
            case LogType.Assert:
            case LogType.Exception: return _rowStyleError;
            default: return _rowStyle;
        }
    }

    private static string LevelLabel(LogType t)
    {
        switch (t)
        {
            case LogType.Warning: return "WARN";
            case LogType.Error: return "ERROR";
            case LogType.Assert: return "ASSERT";
            case LogType.Exception: return "EXC";
            default: return "DEBUG";
        }
    }

    private static bool HasStack(in LogEntry e)
    {
        if (string.IsNullOrEmpty(e.stackTrace)) return false;
        // Many non-error logs have empty stack due to policy; only render if provided
        return true;
    }

    private bool PassesFilter(in LogEntry e)
    {
        switch (e.type)
        {
            case LogType.Warning: return showWarnings;
            case LogType.Error:
            case LogType.Assert:
            case LogType.Exception: return showErrors;
            default: return showDebug;
        }
    }

    private bool PassesSearch(in LogEntry e)
    {
        if (string.IsNullOrEmpty(_search)) return true;
        var s = _search.Trim();
        if (s.Length == 0) return true;
        return (e.message?.IndexOf(s, StringComparison.OrdinalIgnoreCase) ?? -1) >= 0
            || (e.stackTrace?.IndexOf(s, StringComparison.OrdinalIgnoreCase) ?? -1) >= 0
            || (e.contextName?.IndexOf(s, StringComparison.OrdinalIgnoreCase) ?? -1) >= 0;
    }

    private void CopyVisibleToClipboard()
    {
        var sb = new StringBuilder(8192);
        foreach (var e in _entries)
        {
            if (!PassesFilter(e)) continue;
            if (!PassesSearch(e)) continue;

            sb.Append('[').Append(e.time.ToString("HH:mm:ss.fff")).Append("] ");
            sb.Append("F=").Append(e.frame).Append(' ');
            sb.Append("T=").Append(e.threadId).Append(' ');
            sb.Append('[').Append(LevelLabel(e.type)).Append("] ");
            if (!string.IsNullOrEmpty(e.contextName))
            {
                sb.Append('{').Append(e.contextName).Append("} ");
            }
            if (e.count > 0)
            {
                sb.Append(e.message ?? string.Empty).Append(" (x").Append((e.count + 1).ToString()).AppendLine(")");
            }
            else
            {
                sb.AppendLine(e.message ?? string.Empty);
            }

            if (showStackTraces && HasStack(e))
            {
                sb.AppendLine(e.stackTrace);
            }
        }

        GUIUtility.systemCopyBuffer = sb.ToString();
    }

    private static bool AreSameForCollapse(in LogEntry a, in LogEntry b)
    {
        if (a.type != b.type) return false;
        if (!string.Equals(a.message, b.message, StringComparison.Ordinal)) return false;
        if (!string.Equals(a.stackTrace, b.stackTrace, StringComparison.Ordinal)) return false;
        if (!string.Equals(a.contextName, b.contextName, StringComparison.Ordinal)) return false;
        return true;
    }

    private void OnLogMessageReceivedThreaded(string condition, string stacktrace, LogType type)
    {
        var q = new QueuedLog
        {
            time = DateTime.Now,
            threadId = Thread.CurrentThread.ManagedThreadId,
            type = type,
            message = condition,
            stackTrace = stacktrace,
            contextName = string.Empty
        };
        _incoming.Enqueue(q);
    }
}

// Optional convenience for code callers (e.g., MainMenuScreen) without adding compile-time dependency on UnityEngine.UI
public static class DevLog
{
    public static void Show() => DevLogOverlay.Show();
    public static void Hide() => DevLogOverlay.Hide();
    public static void Toggle() => DevLogOverlay.ToggleVisible();
    public static void Clear() => DevLogOverlay.Clear();
}




// ===== FILE: Assets/Scripts/Dev/OpenDevLogButton.cs =====
using UnityEngine;
using UnityEngine.UI;

/// <summary>
/// Attach this to the Main Menu "Log" button to open/close the Dev Log overlay.
/// Keeps scene/prefab changes minimal and avoids coupling to MainMenuScreen implementation.
/// </summary>
[RequireComponent(typeof(Button))]
public class OpenDevLogButton : MonoBehaviour
{
    [Tooltip("Button that will toggle the Dev Log overlay. If left empty, this component will use the Button on the same GameObject.")]
    public Button button;

    [Tooltip("If true, the overlay will open (Show) instead of toggling when clicked.")]
    public bool openOnly = false;

    private void Reset()
    {
        if (button == null) button = GetComponent<Button>();
    }

    private void Awake()
    {
        if (button == null) button = GetComponent<Button>();
        if (button != null)
        {
            button.onClick.AddListener(OnClick);
        }
    }

    private void OnDestroy()
    {
        if (button != null)
            button.onClick.RemoveListener(OnClick);
    }

    private void OnClick()
    {
        if (openOnly) DevLogOverlay.Show(); else DevLogOverlay.ToggleVisible();
    }
}

// ===== FILE: Assets/Scripts/UI/Root/UIRoot.cs =====
using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.UI;
#if ENABLE_INPUT_SYSTEM
// Only available when the new Input System package/define is enabled
using UnityEngine.InputSystem.UI;
#endif

namespace FantasyColony.UI.Root
{
    public sealed class UIRoot : MonoBehaviour
    {
        public RectTransform ScreenParent { get; private set; }

        public static UIRoot Create(Transform parent)
        {
            var go = new GameObject("UIRoot");
            go.transform.SetParent(parent, false);
            var root = go.AddComponent<UIRoot>();
            root.Build();
            return root;
        }

        private void Build()
        {
            // Canvas
            var canvasGO = new GameObject("Canvas");
            canvasGO.transform.SetParent(transform, false);
            var canvas = canvasGO.AddComponent<Canvas>();
            canvas.renderMode = RenderMode.ScreenSpaceOverlay;
            // Ensure pixel-accurate rounding to avoid uneven 1px borders on sliced images
            canvas.pixelPerfect = true; // ScreenSpaceOverlay only
            canvasGO.AddComponent<GraphicRaycaster>();

            var scaler = canvasGO.AddComponent<CanvasScaler>();
            scaler.uiScaleMode = CanvasScaler.ScaleMode.ScaleWithScreenSize;
            scaler.referenceResolution = new Vector2(1920, 1080);
            scaler.matchWidthOrHeight = 0.5f;

            // EventSystem if missing
            bool hasEventSystem = EventSystem.current != null;
#if UNITY_2023_1_OR_NEWER
            if (!hasEventSystem)
                hasEventSystem = (Object.FindFirstObjectByType<EventSystem>() != null);
#else
            if (!hasEventSystem)
                hasEventSystem = (FindObjectOfType<EventSystem>() != null);
#endif
            if (!hasEventSystem)
            {
                // Create EventSystem and attach the correct UI input module
                var es = new GameObject("EventSystem");
                es.AddComponent<EventSystem>();
#if ENABLE_INPUT_SYSTEM
                if (es.GetComponent<InputSystemUIInputModule>() == null)
                {
                    es.AddComponent<InputSystemUIInputModule>();
                }
#else
                if (es.GetComponent<StandaloneInputModule>() == null)
                {
                    es.AddComponent<StandaloneInputModule>();
                }
#endif
            }

            // Screen parent
            var screenParentGO = new GameObject("Screens");
            screenParentGO.transform.SetParent(canvasGO.transform, false);
            ScreenParent = screenParentGO.AddComponent<RectTransform>();
            ScreenParent.anchorMin = Vector2.zero;
            ScreenParent.anchorMax = Vector2.one;
            ScreenParent.offsetMin = Vector2.zero;
            ScreenParent.offsetMax = Vector2.zero;
        }
    }
}

// ===== FILE: Assets/Scripts/UI/Router/IScreen.cs =====
using UnityEngine;

namespace FantasyColony.UI.Router
{
    public interface IScreen
    {
        void Enter(Transform parent);
        void Exit();
    }

    public abstract class UIScreenBase : IScreen
    {
        protected RectTransform Root;
        public abstract void Enter(Transform parent);
        public abstract void Exit();
    }
}

// ===== FILE: Assets/Scripts/UI/Router/UIRouter.cs =====
using System;
using System.Collections.Generic;
using UnityEngine;
using FantasyColony.Core;

namespace FantasyColony.UI.Router
{
    public sealed class UIRouter
    {
        private readonly Transform _parent;
        private readonly ServiceRegistry _services;
        private readonly Stack<IScreen> _stack = new();

        // Global access to the active router (set in ctor)
        public static UIRouter Current { get; private set; }

        public UIRouter(Transform parent, ServiceRegistry services)
        {
            _parent = parent;
            _services = services;
            Current = this;
        }

        public void Push<T>() where T : IScreen, new()
        {
            var screen = new T();
            screen.Enter(_parent);
            _stack.Push(screen);
        }

        // Allow initializing a screen (e.g., dialogs) before entering
        public void Push<T>(Action<T> init) where T : IScreen, new()
        {
            var screen = new T();
            init?.Invoke(screen);
            Push(screen);
        }

        // Push an existing instance
        public void Push(IScreen screen)
        {
            screen.Enter(_parent);
            _stack.Push(screen);
        }

        public void Pop()
        {
            if (_stack.Count == 0) return;
            var top = _stack.Pop();
            top.Exit();
        }

        // --- Restart helpers ---
        public void PopAll()
        {
            while (_stack.Count > 0) Pop();
        }

        public void ResetTo<T>() where T : IScreen, new()
        {
            PopAll();
            Push<T>();
        }
    }
}

// ===== FILE: Assets/Scripts/UI/Screens/BootReportScreen.cs =====
using System.Text;
using UnityEngine;
using UnityEngine.UI;
using FantasyColony.UI.Router;

namespace FantasyColony.UI.Screens {
    /// <summary>
    /// Simple UI to present BootReport contents and first N validation messages.
    /// Dev-only utility; keep minimal.
    /// </summary>
    public sealed class BootReportScreen : IScreen {
        public GameObject Root { get; private set; }

        public void Enter(Transform parent) {
            CreateContent(parent);
        }
        public void Exit() { if (Root != null) GameObject.Destroy(Root); Root = null; }

        private Text _title;
        private Text _body;
        private Button _copy;
        private Button _close;

        private void CreateContent(Transform parent) {
            Root = new GameObject("BootReportScreen", typeof(RectTransform));
            Root.transform.SetParent(parent, false);
            var rootRT = (RectTransform)Root.transform;
            rootRT.anchorMin = new Vector2(0.5f, 0.5f);
            rootRT.anchorMax = new Vector2(0.5f, 0.5f);
            rootRT.pivot = new Vector2(0.5f, 0.5f);

            var panel = CreatePanel(Root.transform, new Vector2(800, 600));
            _title = CreateText(panel, "Boot Report", 24, TextAnchor.MiddleCenter);
            var titleRT = _title.rectTransform;
            titleRT.anchoredPosition = new Vector2(0, 250);

            _body = CreateText(panel, "", 14, TextAnchor.UpperLeft);
            var bodyRT = _body.rectTransform;
            bodyRT.sizeDelta = new Vector2(740, 430);
            bodyRT.anchoredPosition = new Vector2(0, 20);
            _body.horizontalOverflow = HorizontalWrapMode.Wrap;
            _body.verticalOverflow = VerticalWrapMode.Truncate;

            _copy = CreateButton(panel, "Copy", OnCopyClicked);
            _copy.GetComponent<RectTransform>().anchoredPosition = new Vector2(-120, -250);
            _close = CreateButton(panel, "Close", () => UIRouter.Current?.Pop());
            _close.GetComponent<RectTransform>().anchoredPosition = new Vector2(120, -250);

            Refresh();
        }

        private void Refresh() {
            var report = FantasyColony.Boot.BootReport.Last;
            if (report == null) {
                _body.text = "(no report)";
                return;
            }
            var sb = new StringBuilder();
            sb.AppendLine("Tasks:");
            for (int i = 0; i < report.steps.Count; i++) {
                var s = report.steps[i];
                sb.AppendLine($" - {s.title}  ({s.seconds:0.000}s){(string.IsNullOrEmpty(s.warn) ? "" : "  [" + s.warn + "]")}");
            }
            _body.text = sb.ToString();
        }

        private void OnCopyClicked() {
            var report = FantasyColony.Boot.BootReport.Last;
            if (report == null) return;
            var sb = new StringBuilder();
            for (int i = 0; i < report.steps.Count; i++) {
                var s = report.steps[i];
                sb.AppendLine($"{s.title}\t{s.seconds:0.000}\t{(s.warn ?? "").Replace('\n', ' ')}");
            }
#if UNITY_EDITOR
            UnityEditor.EditorGUIUtility.systemCopyBuffer = sb.ToString();
#else
            GUIUtility.systemCopyBuffer = sb.ToString();
#endif
        }

        // --- tiny UI helpers (local, to avoid style dependencies) ---
        private RectTransform CreatePanel(Transform parent, Vector2 size) {
            var go = new GameObject("Panel", typeof(RectTransform), typeof(Image));
            go.transform.SetParent(parent, false);
            var rt = (RectTransform)go.transform;
            rt.sizeDelta = size;
            rt.anchoredPosition = Vector2.zero;
            var img = go.GetComponent<Image>();
            img.color = new Color(0, 0, 0, 0.8f);
            var outline = go.AddComponent<Outline>();
            outline.effectColor = new Color(1, 1, 1, 0.05f);
            return rt;
        }
        private Text CreateText(RectTransform parent, string text, int size, TextAnchor anchor) {
            var go = new GameObject("Text", typeof(RectTransform), typeof(Text));
            go.transform.SetParent(parent, false);
            var t = go.GetComponent<Text>();
            t.text = text;
            t.fontSize = size;
            t.alignment = anchor;
            t.font = Resources.GetBuiltinResource<Font>("Arial.ttf");
            var rt = (RectTransform)go.transform;
            rt.sizeDelta = new Vector2(740, 60);
            rt.anchoredPosition = Vector2.zero;
            return t;
        }
        private Button CreateButton(RectTransform parent, string text, System.Action onClick) {
            var go = new GameObject("Button", typeof(RectTransform), typeof(Image), typeof(Button));
            go.transform.SetParent(parent, false);
            var rt = (RectTransform)go.transform;
            rt.sizeDelta = new Vector2(160, 40);
            var img = go.GetComponent<Image>();
            img.color = new Color(1, 1, 1, 0.1f);
            var btn = go.GetComponent<Button>();
            btn.onClick.AddListener(() => onClick());
            var label = CreateText(rt, text, 16, TextAnchor.MiddleCenter);
            label.rectTransform.sizeDelta = rt.sizeDelta;
            return btn;
        }
    }
}


// ===== FILE: Assets/Scripts/UI/Screens/BootScreen.cs =====
using System;
using System.Collections;
using UnityEngine;
using UnityEngine.UI;
using FantasyColony.UI.Router;
using FantasyColony.Boot;

namespace FantasyColony.UI.Screens
{
    // Boot screen: shows a cover and phase text while the app boot pipeline runs
    public class BootScreen : IScreen
    {
        public string Title = "Loading";
        public GameObject Root { get; private set; }
        private Text _phaseText;

        public void Enter(Transform parent)
        {
            Root = new GameObject("BootScreen");
            var rt = Root.AddComponent<RectTransform>();
            rt.SetParent(parent, false);
            rt.anchorMin = Vector2.zero; rt.anchorMax = Vector2.one;
            rt.offsetMin = Vector2.zero; rt.offsetMax = Vector2.zero;

            // Solid dark cover (prevents flash)
            var bg = new GameObject("Background");
            var bgrt = bg.AddComponent<RectTransform>();
            bgrt.SetParent(rt, false);
            bgrt.anchorMin = Vector2.zero; bgrt.anchorMax = Vector2.one;
            bgrt.offsetMin = Vector2.zero; bgrt.offsetMax = Vector2.zero;
            var bgImg = bg.AddComponent<Image>();
            bgImg.color = new Color(0.10f, 0.09f, 0.08f, 1f);
            bgImg.raycastTarget = true;

            // Centered title
            var titleGO = new GameObject("Title");
            var tr = titleGO.AddComponent<RectTransform>();
            tr.SetParent(rt, false);
            tr.anchorMin = tr.anchorMax = new Vector2(0.5f, 0.5f);
            tr.anchoredPosition = new Vector2(0f, 24f);
            tr.sizeDelta = new Vector2(640f, 80f);
            var text = titleGO.AddComponent<Text>();
            text.font = Resources.GetBuiltinResource<Font>("Arial.ttf");
            text.fontSize = 24; text.alignment = TextAnchor.MiddleCenter;
            text.color = Color.white;
            text.horizontalOverflow = HorizontalWrapMode.Overflow;
            text.verticalOverflow = VerticalWrapMode.Truncate;
            text.text = string.IsNullOrEmpty(Title) ? "Loading" : Title;

            // Phase text (small subtitle)
            var phaseGO = new GameObject("Phase");
            var pr = phaseGO.AddComponent<RectTransform>();
            pr.SetParent(rt, false);
            pr.anchorMin = pr.anchorMax = new Vector2(0.5f, 0.5f);
            pr.anchoredPosition = new Vector2(0f, -16f);
            pr.sizeDelta = new Vector2(720f, 40f);
            _phaseText = phaseGO.AddComponent<Text>();
            _phaseText.font = text.font;
            _phaseText.fontSize = 18; _phaseText.alignment = TextAnchor.MiddleCenter;
            _phaseText.color = new Color(0.92f, 0.92f, 0.92f, 0.95f);
            _phaseText.horizontalOverflow = HorizontalWrapMode.Overflow;
            _phaseText.verticalOverflow = VerticalWrapMode.Truncate;
            _phaseText.text = string.Empty;

            // Kick off the boot pipeline on the next frame
            var runner = Root.AddComponent<Runner>();
            runner.StartCoroutine(BootCo());
        }

        public void Exit()
        {
            if (Root != null)
            {
                UnityEngine.Object.Destroy(Root);
                Root = null;
            }
        }

        private IEnumerator BootCo()
        {
            yield return null; // render once so the cover is visible
            yield return BootPipeline.Run(SetPhase);
            Time.timeScale = 1f;
            UIRouter.Current?.ResetTo<MainMenuScreen>();
        }

        private void SetPhase(string s)
        {
            if (_phaseText != null) _phaseText.text = s ?? string.Empty;
        }

        private class Runner : MonoBehaviour { }
    }
}

// ===== FILE: Assets/Scripts/UI/Screens/ConfirmDialogScreen.cs =====
using System;
using UnityEngine;
using UnityEngine.UI;
using FantasyColony.UI.Router;
using FantasyColony.UI.Widgets;

namespace FantasyColony.UI.Screens
{
    // Simple reusable confirmation dialog with a dimming overlay
    public class ConfirmDialogScreen : IScreen
    {
        // Configure via UIRouter.Current.Push<ConfirmDialogScreen>(init => { ... })
        public string Title;
        public string Message;
        public string ConfirmLabel = "OK";
        public string CancelLabel = "Cancel";
        public Action OnConfirm;
        public Action OnCancel;

        public GameObject Root { get; private set; }

        public void Enter(Transform parent)
        {
            Root = new GameObject("ConfirmDialog");
            var rt = Root.AddComponent<RectTransform>();
            rt.SetParent(parent, false);
            rt.anchorMin = Vector2.zero; rt.anchorMax = Vector2.one;
            rt.offsetMin = Vector2.zero; rt.offsetMax = Vector2.zero;

            // Dimmer to block clicks and darken background
            var dim = new GameObject("Dimmer");
            var dimRt = dim.AddComponent<RectTransform>();
            dimRt.SetParent(rt, false);
            dimRt.anchorMin = Vector2.zero; dimRt.anchorMax = Vector2.one;
            dimRt.offsetMin = Vector2.zero; dimRt.offsetMax = Vector2.zero;
            var dimImg = dim.AddComponent<Image>();
            dimImg.color = new Color(0f, 0f, 0f, 0.55f);
            dimImg.raycastTarget = true;

            // Dialog panel (textured surface from UIFactory)
            var prt = UIFactory.CreatePanelSurface(rt, "Panel");
            prt.sizeDelta = new Vector2(520, 280);
            prt.anchorMin = prt.anchorMax = new Vector2(0.5f, 0.5f);
            prt.anchoredPosition = Vector2.zero;
            UIFactory.SetPanelDecorVisible(prt, true);

            var layout = prt.GetComponent<VerticalLayoutGroup>();
            layout.childAlignment = TextAnchor.UpperCenter;
            layout.childControlHeight = true; layout.childControlWidth = true;
            layout.childForceExpandHeight = false; layout.childForceExpandWidth = false;
            layout.padding = new RectOffset(24, 24, 24, 24);
            layout.spacing = 12;

            // Title
            var titleGO = new GameObject("Title");
            titleGO.transform.SetParent(prt, false);
            var titleText = titleGO.AddComponent<Text>();
            titleText.font = Resources.GetBuiltinResource<Font>("Arial.ttf");
            titleText.fontSize = 26; titleText.alignment = TextAnchor.MiddleCenter;
            titleText.color = Color.white;
            titleText.horizontalOverflow = HorizontalWrapMode.Wrap;
            titleText.verticalOverflow = VerticalWrapMode.Truncate;
            titleText.text = string.IsNullOrEmpty(Title) ? "Confirm" : Title;

            // Message
            var msgGO = new GameObject("Message");
            msgGO.transform.SetParent(prt, false);
            var msgText = msgGO.AddComponent<Text>();
            msgText.font = titleText.font;
            msgText.fontSize = 16; msgText.alignment = TextAnchor.MiddleCenter;
            msgText.color = new Color(0.9f, 0.9f, 0.9f, 0.95f);
            msgText.horizontalOverflow = HorizontalWrapMode.Wrap;
            msgText.verticalOverflow = VerticalWrapMode.Overflow;
            msgText.text = string.IsNullOrEmpty(Message) ? string.Empty : Message;

            // Buttons row
            var row = new GameObject("Buttons");
            row.transform.SetParent(prt, false);
            var rowLayout = row.AddComponent<HorizontalLayoutGroup>();
            rowLayout.childAlignment = TextAnchor.MiddleCenter;
            rowLayout.spacing = 16;
            rowLayout.childForceExpandWidth = false;
            rowLayout.childForceExpandHeight = false;
            rowLayout.padding = new RectOffset(0, 0, 8, 0);

            // Cancel / Confirm buttons using UIFactory
            UIFactory.CreateButtonSecondary(row.transform, string.IsNullOrEmpty(CancelLabel) ? "Cancel" : CancelLabel, () =>
            {
                UIRouter.Current?.Pop();
                OnCancel?.Invoke();
            });

            UIFactory.CreateButtonDanger(row.transform, string.IsNullOrEmpty(ConfirmLabel) ? "OK" : ConfirmLabel, () =>
            {
                var router = UIRouter.Current;
                router?.Pop(); // close dialog first so new screens appear above
                OnConfirm?.Invoke();
            });
        }

        public void Exit()
        {
            if (Root != null)
            {
                UnityEngine.Object.Destroy(Root);
                Root = null;
            }
        }
    }
}

// ===== FILE: Assets/Scripts/UI/Screens/MainMenuScreen.cs =====
using UnityEngine;
// using DevTools; // not required; DevLogOverlay is in the global namespace
using FantasyColony.UI.Router;
using FantasyColony.UI.Widgets;
using FantasyColony.UI.Style;
using FantasyColony.Core.Services;
using UnityObject = UnityEngine.Object;
using FantasyColony.Boot;

namespace FantasyColony.UI.Screens
{
    /// <summary>
    /// Main Menu (non-functional for now). Uses Base UI Style, bottom-right vertical stack.
    /// Order: Log, Start, Continue, Load, Options, Mods, Creator, Restart, Quit
    /// </summary>
    public sealed class MainMenuScreen : UIScreenBase
    {
        public override void Enter(Transform parent)
        {
            // Root
            var go = new GameObject("MainMenu", typeof(RectTransform));
            Root = go.GetComponent<RectTransform>();
            Root.SetParent(parent, false);
            Root.anchorMin = Vector2.zero;
            Root.anchorMax = Vector2.one;
            Root.offsetMin = Vector2.zero;
            Root.offsetMax = Vector2.zero;

            // Background (image if present, else solid)
            var bgSprite = Resources.Load<Sprite>("ui/menu/main_menu_bg");
            UIFactory.CreateFullscreenBackground(Root, bgSprite, new Color32(18, 15, 12, 255));

            // Panel stack (bottom-right)
            var panel = UIFactory.CreateBottomRightStack(Root, "MenuPanel");
            // Hide panel chrome so buttons sit directly on the background art (previous behavior)
            UIFactory.SetPanelDecorVisible(panel, false);

            // Buttons (log "Not implemented")
            void NotImpl(string name) => Debug.Log($"BUTTON: {name} (not implemented)");

            UIFactory.CreateButtonSecondary(panel, "Log",        DevLogOverlay.Show);
            var startBtn = UIFactory.CreateButtonPrimary(panel, "Start", () => NotImpl("Start"));
            var btnContinue = UIFactory.CreateButtonSecondary(panel, "Continue", () => NotImpl("Continue"));
            var btnLoad     = UIFactory.CreateButtonSecondary(panel, "Load",     () => NotImpl("Load"));
            UIFactory.CreateButtonSecondary(panel, "Options",    () => NotImpl("Options"));
            UIFactory.CreateButtonSecondary(panel, "Mods",       () => NotImpl("Mods"));
            UIFactory.CreateButtonSecondary(panel, "Creator",    () => NotImpl("Creator"));
            UIFactory.CreateButtonSecondary(panel, "Restart",    ShowRestartConfirm);
            var quitBtn = UIFactory.CreateButtonDanger(panel, "Quit", ShowQuitConfirm);

#if UNITY_EDITOR || DEVELOPMENT_BUILD
            UIFactory.CreateButtonSecondary(panel, "Boot Report", () => UIRouter.Current?.Push<BootReportScreen>());
            UIFactory.CreateButtonSecondary(panel, "Validation: " + (JsonConfigService.Instance.GetValidationMode()==FantasyColony.Core.Defs.Validation.ValidationMode.Strict?"Strict":"Lenient"), ToggleValidationMode);
#endif

            // Disabled rules for now (no save system yet)
            btnContinue.interactable = false;
            btnLoad.interactable = false;
        }

        public override void Exit()
        {
            if (Root != null)
            {
                UnityObject.Destroy(Root.gameObject);
                Root = null;
            }
        }

        private void ShowRestartConfirm()
        {
            UIRouter.Current?.Push<ConfirmDialogScreen>(d =>
            {
                d.Title = "Restart Game?";
                d.Message = "This will restart the application flow.";
                d.ConfirmLabel = "Restart";
                d.CancelLabel = "Cancel";
                d.OnConfirm = () =>
                {
                    UIRouter.Current?.Push<BootScreen>(b => { b.Title = "Loading"; });
                };
            });
        }

        private void ShowQuitConfirm()
        {
            UIRouter.Current?.Push<ConfirmDialogScreen>(d =>
            {
                d.Title = "Quit Game?";
                d.Message = "Are you sure you want to exit?";
                d.ConfirmLabel = "Quit";
                d.CancelLabel = "Cancel";
                d.OnConfirm = QuitGame;
            });
        }

        private void QuitGame()
        {
#if UNITY_EDITOR
            UnityEditor.EditorApplication.ExitPlaymode();
#else
            Application.Quit();
#endif
        }

#if UNITY_EDITOR || DEVELOPMENT_BUILD
        private void ToggleValidationMode()
        {
            var cfg = JsonConfigService.Instance;
            var cur = cfg.GetValidationMode();
            var next = cur == FantasyColony.Core.Defs.Validation.ValidationMode.Strict ? "lenient" : "strict";
            cfg.Set("validation_mode", next);
            UIRouter.Current?.ResetTo<MainMenuScreen>();
        }
#endif
    }
}

// ===== FILE: Assets/Scripts/UI/Style/BaseUIStyle.cs =====
using UnityEngine;

namespace FantasyColony.UI.Style
{
    public static class BaseUIStyle
    {
        // Colors
        public static Color32 Gold            = Hex("#D6B25E");
        public static Color32 GoldHover       = Hex("#E4C77D");
        public static Color32 GoldPressed     = Hex("#B99443");
        public static Color32 PanelSurface    = new Color32(0x1F,0x1A,0x14, (byte)(0.95f * 255));
        // Secondary (dark) fill used for standard buttons - BRIGHTENED for better visibility on dark backgrounds
        // Old values kept in comments for reference
        // Previous: #3B3329 (0.231, 0.200, 0.161)
        public static Color32 SecondaryFill   = Hex("#5E5345"); // #5E5345
        // Secondary (dark) explicit states for visible hover/press
        // Hover: noticeably lighter than base; Pressed: slightly darker than new base
        public static Color32 SecondaryHover  = Hex("#726555"); // #726555
        public static Color32 SecondaryPressed= Hex("#4A4033"); // Slightly darker than new base
        public static Color32 Keyline         = new Color32(0x5A,0x4C,0x38, (byte)(0.60f * 255));
        public static Color32 TextPrimary     = Hex("#F1E9D2");
        public static Color32 TextSecondary   = Hex("#C9BDA2");
        public static Color32 Danger          = Hex("#B34844");
        public static Color32 DangerHover     = Hex("#C8625E");
        public static Color32 DangerPressed   = Hex("#953A37");

        // --- Textured UI assets ---
        // Resource paths (under Assets/Resources)
        public const string WoodTilePath = "ui/sprites/tile/wood_soft_tile";
        public const string DarkBorder9SPath = "ui/sprites/9slice/border_dark_9s";

        // Toggle: grayscale the wood tile before tinting (for faithful palette hues)
        public static bool UseGrayscaleTint = true; // static (not const) to avoid unreachable-code folding

        // Desired on-screen border thickness in device pixels for sliced borders
        // This single value controls both panels and buttons.
        public const float TargetBorderPx = 10f; // default visual = 10px borders

        // --- Tint themes for wood_soft_tile surfaces ---
        public struct TintTheme { public Color32 Base, Hover, Pressed; }

        // Secondary (dark) theme
        public static readonly TintTheme SecondaryTheme = new TintTheme
        {
            Base    = SecondaryFill,
            Hover   = SecondaryHover,
            Pressed = SecondaryPressed
        };

        // Gold (primary/action) theme
        public static readonly TintTheme GoldTheme = new TintTheme
        {
            Base    = Gold,
            Hover   = GoldHover,
            Pressed = GoldPressed
        };

        // Danger theme
        public static readonly TintTheme DangerTheme = new TintTheme
        {
            Base    = Danger,
            Hover   = DangerHover,
            Pressed = DangerPressed
        };

        // Overlay tints for Button.state (applied to a transparent overlay Image)
        // Keep subtle so textures are not washed out
        public static readonly Color HoverOverlay   = new Color(1f, 1f, 1f, 0.06f);
        public static readonly Color PressedOverlay = new Color(0f, 0f, 0f, 0.10f);
        public static readonly Color DisabledOverlay= new Color(0f, 0f, 0f, 0.40f);

        // Sizes
        public const int ButtonHeight = 56;
        public const int ButtonFontSize = 24;
        public const int BodyFontSize = 20;
        public const int CaptionFontSize = 18;
        public const int PanelPadding = 24;
        public const int StackSpacing = 12;
        public const int EdgeOffset = 56;

        public static Color32 Hex(string hex)
        {
            if (ColorUtility.TryParseHtmlString(hex, out var c))
                return c;
            return Color.white;
        }
    }
}

// ===== FILE: Assets/Scripts/UI/Util/GrayscaleSpriteCache.cs =====
using System.Collections.Generic;
using UnityEngine;

namespace FantasyColony.UI.Util
{
    public static class GrayscaleSpriteCache
    {
        // Cache by source texture instanceID + rect
        private static readonly Dictionary<string, Sprite> _cache = new();

        public static Sprite Get(Sprite source)
        {
            if (source == null) return null;
            var key = MakeKey(source);
            if (_cache.TryGetValue(key, out var s)) return s;

            var rect = source.rect;
            var tex = source.texture;
            var x = Mathf.RoundToInt(rect.x);
            var y = Mathf.RoundToInt(rect.y);
            var w = Mathf.RoundToInt(rect.width);
            var h = Mathf.RoundToInt(rect.height);

            // Read pixels from source region
            var tmp = new Texture2D(w, h, TextureFormat.RGBA32, false, false);
            var pixels = tex.GetPixels(x, y, w, h);
            for (int i = 0; i < pixels.Length; i++)
            {
                var c = pixels[i];
                float g = (0.299f * c.r) + (0.587f * c.g) + (0.114f * c.b);
                pixels[i] = new Color(g, g, g, c.a);
            }
            tmp.SetPixels(pixels);
            tmp.Apply(false, true);

            // Create a sprite with same PPU and pivot
            var sp = Sprite.Create(tmp, new Rect(0, 0, w, h), new Vector2(0.5f, 0.5f), source.pixelsPerUnit, 0, SpriteMeshType.FullRect);
            _cache[key] = sp;
            return sp;
        }

        private static string MakeKey(Sprite s)
        {
            var r = s.rect;
            return s.texture.GetInstanceID().ToString() + ":" + r.x + "," + r.y + "," + r.width + "," + r.height + ":" + s.pixelsPerUnit;
        }
    }
}


// ===== FILE: Assets/Scripts/UI/Util/UIPixelSnap.cs =====
using UnityEngine;
using UnityEngine.UI;

namespace FantasyColony.UI.Util
{
    // Keep RectTransforms aligned to the pixel grid to avoid uneven 1px borders on 9-slice images.
    [ExecuteAlways]
    [DisallowMultipleComponent]
    public class UIPixelSnap : MonoBehaviour
    {
        RectTransform _rt;
        Canvas _canvas;

        void OnEnable()
        {
            _rt = GetComponent<RectTransform>();
            _canvas = GetComponentInParent<Canvas>();
            Snap();
        }

        void LateUpdate() => Snap();
        void OnRectTransformDimensionsChange() => Snap();

        void Snap()
        {
            if (_rt == null) return;
            if (_canvas == null) _canvas = GetComponentInParent<Canvas>();
            if (_canvas == null) return;

            float refPPU = _canvas.referencePixelsPerUnit <= 0 ? 100f : _canvas.referencePixelsPerUnit;
            float sf = _canvas.scaleFactor <= 0 ? 1f : _canvas.scaleFactor;
            float unitsPerPixel = 1f / (refPPU * sf);

            // Round anchored position
            var ap = _rt.anchoredPosition;
            ap.x = Mathf.Round(ap.x / unitsPerPixel) * unitsPerPixel;
            ap.y = Mathf.Round(ap.y / unitsPerPixel) * unitsPerPixel;
            _rt.anchoredPosition = ap;

            // Round sizeDelta
            var sd = _rt.sizeDelta;
            sd.x = Mathf.Round(sd.x / unitsPerPixel) * unitsPerPixel;
            sd.y = Mathf.Round(sd.y / unitsPerPixel) * unitsPerPixel;
            _rt.sizeDelta = sd;
        }
    }
}


// ===== FILE: Assets/Scripts/UI/Widgets/UIFactory.cs =====
using UnityEngine;
using UnityEngine.UI;
using System;
using FantasyColony; // for GetHierarchyPath()
using FantasyColony.UI.Style;
using FantasyColony.UI.Util;
using TintTheme = FantasyColony.UI.Style.BaseUIStyle.TintTheme;

namespace FantasyColony.UI.Widgets
{
    public static class UIFactory
    {
        // Cache a symmetrized version of the dark 9-slice border so L/R and T/B are equal.
        private static Sprite _darkBorderSymmetric;
        private static Material _grayscaleTintMat;

        // Ensure the 9-slice border has equal left/right and top/bottom edge sizes.
        // This avoids visual asymmetry when Unity stretches the sliced edges.
        private static Sprite GetSymmetricDarkBorder()
        {
            if (_darkBorderSymmetric != null)
                return _darkBorderSymmetric;

            var src = Resources.Load<Sprite>(BaseUIStyle.DarkBorder9SPath);
            if (src == null)
                return null;

            _darkBorderSymmetric = MakeUniformBorderFromTopBottom(src);
            return _darkBorderSymmetric;
        }

        private static Material GetGrayscaleTintMaterial()
        {
            if (_grayscaleTintMat != null) return _grayscaleTintMat;
            // Load from Resources to ensure inclusion in builds
            var sh = Resources.Load<Shader>("Shaders/UIGrayscaleTint");
            if (sh == null)
            {
                Debug.LogWarning("UIFactory: Shader 'UI/GrayscaleTint' not found in Resources. Will fall back to CPU grayscale.");
                return null;
            }
            _grayscaleTintMat = new Material(sh)
            {
                hideFlags = HideFlags.DontSaveInBuild | HideFlags.DontSaveInEditor
            };
            return _grayscaleTintMat;
        }

        private static void ApplyTintMaterial(Image img)
        {
            if (img == null) return;
            if (!BaseUIStyle.UseGrayscaleTint)
                return; // use default
            var mat = GetGrayscaleTintMaterial();
            if (mat == null)
            {
                // Fallback: CPU grayscale sprite, then let UI/Default tint it
                var src = img.sprite;
                var gray = GrayscaleSpriteCache.Get(src);
                if (gray != null)
                {
                    img.sprite = gray;
                    img.material = null;
                }
                Debug.LogWarning($"UIFactory: Using CPU grayscale fallback on {img.transform.GetHierarchyPath()}.");
                return;
            }
            img.material = new Material(mat); // per-image instance
            img.SetMaterialDirty();
            // Runtime verification (no editor guard):
            var actual = img.materialForRendering != null ? img.materialForRendering.shader.name : "<null>";
            if (actual != "UI/GrayscaleTint")
                Debug.LogWarning($"UIFactory: Expected 'UI/GrayscaleTint' but got '{actual}' on {img.transform.GetHierarchyPath()}.");
            else
                Debug.Log($"UIFactory: GrayscaleTint OK on {img.transform.GetHierarchyPath()}.");
        }

        private static Sprite MakeUniformBorderFromTopBottom(Sprite src)
        {
            // Unity's Sprite.border order: (left, right, top, bottom)
            var b = src.border;
            // Force all four edges to match the thinner of Top/Bottom to keep corners safe
            float tb = Mathf.Min(b.z, b.w);

            // Sprite.Create expects pivot relative to rect (0..1). Convert existing pixel pivot.
            var rect = src.rect;
            var pivotNormalized = new Vector2(
                rect.width  > 0 ? src.pivot.x / rect.width  : 0.5f,
                rect.height > 0 ? src.pivot.y / rect.height : 0.5f
            );

            var sym = Sprite.Create(
                src.texture,
                rect,
                pivotNormalized,
                src.pixelsPerUnit,
                0,
                SpriteMeshType.FullRect,
                new Vector4(tb, tb, tb, tb)
            );
            return sym;
        }

        // Compute a pixelsPerUnitMultiplier that yields a precise on-screen thickness in pixels for the 9-slice edges.
        // Assumes the Sprite has equal borders on all sides (enforced by GetSymmetricDarkBorder).
        // Formula: displayed_px ≈ slice_px / (spritePPU * multiplier) * canvasRefPPU * canvasScaleFactor
        // We solve for multiplier so displayed_px == targetPixels.
        private static float ComputeBorderScale(Sprite s, float targetPixels, float canvasRefPPU, float canvasScaleFactor)
        {
            if (s == null) return 1f;
            float borderPx = s.border.w; // any side; they're equal
            float tpx = Mathf.Max(0.0001f, targetPixels);
            float spritePPU = Mathf.Max(0.0001f, s.pixelsPerUnit);
            float refPPU = Mathf.Max(0.0001f, canvasRefPPU);
            float scale = Mathf.Max(0.0001f, canvasScaleFactor);
            // Solve: targetPixels = borderPx / (spritePPU * m) * refPPU * scale
            float m = (borderPx * refPPU * scale) / (spritePPU * tpx);
            return Mathf.Max(0.0001f, m);
        }

        // Find nearest parent Canvas to get the current Canvas.scaleFactor (for pixel-accurate computation)
        private static float GetCanvasScaleFactor(Transform t)
        {
            var canvas = t.GetComponentInParent<Canvas>();
            if (canvas != null) return canvas.scaleFactor <= 0f ? 1f : canvas.scaleFactor;
            return 1f;
        }

        private static float GetCanvasRefPPU(Transform t)
        {
            var canvas = t.GetComponentInParent<Canvas>();
            if (canvas != null)
            {
                return canvas.referencePixelsPerUnit <= 0f ? 100f : canvas.referencePixelsPerUnit;
            }
            return 100f;
        }

        private static void AttachPixelSnap(Component c)
        {
            if (c == null) return;
            if (c.gameObject.GetComponent<UIPixelSnap>() == null)
                c.gameObject.AddComponent<UIPixelSnap>();
        }

        // PANEL (Textured wood fill + dark 9-slice border)
        public static RectTransform CreatePanelSurface(Transform parent, string name = "Panel", TintTheme? theme = null)
        {
            var go = new GameObject(name, typeof(RectTransform), typeof(CanvasRenderer), typeof(Image), typeof(VerticalLayoutGroup), typeof(ContentSizeFitter));
            go.transform.SetParent(parent, false);

            var rt = go.GetComponent<RectTransform>();
            var rootImg = go.GetComponent<Image>();

            // Layout configuration (unchanged)
            var layout = go.GetComponent<VerticalLayoutGroup>();
            layout.spacing = BaseUIStyle.StackSpacing;
            layout.padding = new RectOffset(BaseUIStyle.PanelPadding, BaseUIStyle.PanelPadding, BaseUIStyle.PanelPadding, BaseUIStyle.PanelPadding);
            layout.childControlWidth = true;
            layout.childControlHeight = true;
            layout.childForceExpandWidth = false;
            layout.childForceExpandHeight = false;
            var fitter = go.GetComponent<ContentSizeFitter>();
            fitter.horizontalFit = ContentSizeFitter.FitMode.PreferredSize;
            fitter.verticalFit = ContentSizeFitter.FitMode.PreferredSize;

            // --- Fill (tiled wood) ---
            var fillGO = new GameObject("BG_Fill", typeof(RectTransform), typeof(CanvasRenderer), typeof(Image), typeof(LayoutElement));
            fillGO.transform.SetParent(go.transform, false);
            var fillRt = fillGO.GetComponent<RectTransform>();
            fillRt.anchorMin = Vector2.zero; fillRt.anchorMax = Vector2.one;
            fillRt.offsetMin = Vector2.zero; fillRt.offsetMax = Vector2.zero;
            var fillImg = fillGO.GetComponent<Image>();
            fillImg.raycastTarget = false;
            var le = fillGO.GetComponent<LayoutElement>();
            le.ignoreLayout = true;
            var wood = Resources.Load<Sprite>("ui/sprites/tiles/wood_soft_tile");
            if (wood == null)
                Debug.LogWarning($"UIFactory: Wood tile sprite missing at ui/sprites/tiles/wood_soft_tile for {fillGO.transform.GetHierarchyPath()}");
            fillImg.sprite = wood;
            fillImg.type = Image.Type.Tiled;
            fillImg.preserveAspect = false;
            ApplyTintMaterial(fillImg);
            var panelTheme = theme ?? BaseUIStyle.SecondaryTheme;
            fillImg.color = panelTheme.Base;
            // --- Pixel-precise frame instead of 9-slice Image ---
            var borderGO = new GameObject("Frame", typeof(RectTransform), typeof(CanvasRenderer), typeof(LayoutElement), typeof(UIFrame));
            borderGO.transform.SetParent(go.transform, false);
            var borderRt = borderGO.GetComponent<RectTransform>();
            borderRt.anchorMin = Vector2.zero; borderRt.anchorMax = Vector2.one;
            borderRt.offsetMin = Vector2.zero; borderRt.offsetMax = Vector2.zero;
            borderGO.GetComponent<LayoutElement>().ignoreLayout = true;
            var frame = borderGO.GetComponent<UIFrame>();
            var border = GetSymmetricDarkBorder();
            frame.Init(border, BaseUIStyle.TargetBorderPx, Color.white);

            // Root image no longer draws visuals; keep it disabled but present for easy toggling
            rootImg.enabled = false;
            rootImg.raycastTarget = false;

            // Pixel snap to avoid uneven vertical vs horizontal edges
            AttachPixelSnap(go.transform);
            AttachPixelSnap(borderGO.transform);

            // Ensure BG_Fill under Frame
            var fill = go.transform.Find("BG_Fill");
            var borderT = go.transform.Find("Frame");
            if (fill) fill.SetSiblingIndex(0);
            if (borderT) borderT.SetSiblingIndex(1);

            return rt;
        }

        // BUTTONS
        public static Button CreateButtonPrimary(Transform parent, string label, Action onClick) => CreateButton(parent, label, BaseUIStyle.TextSecondary, onClick, BaseUIStyle.GoldTheme);
        public static Button CreateButtonSecondary(Transform parent, string label, Action onClick) => CreateButton(parent, label, BaseUIStyle.TextPrimary, onClick, BaseUIStyle.SecondaryTheme);
        public static Button CreateButtonDanger(Transform parent, string label, Action onClick) => CreateButton(parent, label, BaseUIStyle.TextSecondary, onClick, BaseUIStyle.DangerTheme);

        // Textured button: tiled wood fill + 9-slice dark border; wood itself tints for state changes
        private static Button CreateButton(Transform parent, string label, Color textColor, Action onClick, TintTheme theme)
        {
            var go = new GameObject($"Button_{label}", typeof(RectTransform), typeof(CanvasRenderer), typeof(Image), typeof(Button), typeof(LayoutElement));
            go.transform.SetParent(parent, false);

            var rt = go.GetComponent<RectTransform>();
            rt.sizeDelta = new Vector2(380, BaseUIStyle.ButtonHeight);

            // Root image handles raycasts, but does not draw visuals
            var rootImg = go.GetComponent<Image>();
            rootImg.sprite = null; rootImg.color = new Color(0,0,0,0); rootImg.raycastTarget = true;
            var btn = go.GetComponent<Button>();

            // --- Background fill (wood, tiled) ---
            var fillGO = new GameObject("BG_Fill", typeof(RectTransform), typeof(CanvasRenderer), typeof(Image), typeof(LayoutElement));
            fillGO.transform.SetParent(go.transform, false);
            var fillRt = fillGO.GetComponent<RectTransform>();
            fillRt.anchorMin = Vector2.zero; fillRt.anchorMax = Vector2.one;
            fillRt.offsetMin = Vector2.zero; fillRt.offsetMax = Vector2.zero; // full-bleed wood
            var fillImg = fillGO.GetComponent<Image>();
            fillImg.raycastTarget = false;
            fillImg.preserveAspect = false;
            fillGO.GetComponent<LayoutElement>().ignoreLayout = true;
            var wood = Resources.Load<Sprite>("ui/sprites/tiles/wood_soft_tile");
            if (wood == null)
                Debug.LogWarning($"UIFactory: Wood tile sprite missing at ui/sprites/tiles/wood_soft_tile for {fillGO.transform.GetHierarchyPath()}");
            fillImg.sprite = wood;
            fillImg.type = Image.Type.Tiled;
            ApplyTintMaterial(fillImg);
            fillImg.color = theme.Base; // tint the wood itself
            // --- Pixel-precise frame instead of 9-slice Image ---
            var borderGO = new GameObject("Frame", typeof(RectTransform), typeof(CanvasRenderer), typeof(LayoutElement), typeof(UIFrame));
            borderGO.transform.SetParent(go.transform, false);
            var borderRt = borderGO.GetComponent<RectTransform>();
            borderRt.anchorMin = Vector2.zero; borderRt.anchorMax = Vector2.one;
            borderRt.offsetMin = Vector2.zero; borderRt.offsetMax = Vector2.zero;
            borderGO.GetComponent<LayoutElement>().ignoreLayout = true;
            var frame = borderGO.GetComponent<UIFrame>();
            var border = GetSymmetricDarkBorder();
            frame.Init(border, BaseUIStyle.TargetBorderPx, Color.white);

            // Button setup
            btn.transition = Selectable.Transition.ColorTint;
            // Make the wood fill the targetGraphic so the texture itself tints for state changes
            btn.targetGraphic = fillImg;
            var cb = btn.colors;
            cb.colorMultiplier = 1f;
            cb.fadeDuration = 0.08f;
            cb.normalColor      = theme.Base;
            cb.highlightedColor = theme.Hover;
            cb.pressedColor     = theme.Pressed;
            cb.selectedColor    = theme.Base;
            var baseCol = (Color)theme.Base;
            baseCol.a *= 0.6f;
            cb.disabledColor    = baseCol;
            btn.colors = cb;
            btn.onClick.AddListener(() => onClick?.Invoke());

            // Pixel snapping on root & border to keep 1px borders even
            AttachPixelSnap(go.transform);
            AttachPixelSnap(borderGO.transform);

            // Layout sizing so buttons are visible in the stack
            var le = go.GetComponent<LayoutElement>();
            le.preferredWidth = 420;
            le.minHeight = BaseUIStyle.ButtonHeight;
            le.flexibleWidth = 0;
            le.flexibleHeight = 0;

            // Label
            var textGO = new GameObject("Label", typeof(RectTransform), typeof(CanvasRenderer), typeof(Text));
            textGO.transform.SetParent(go.transform, false);
            var trt = textGO.GetComponent<RectTransform>();
            trt.anchorMin = new Vector2(0, 0);
            trt.anchorMax = new Vector2(1, 1);
            trt.offsetMin = Vector2.zero; // true center
            trt.offsetMax = Vector2.zero;
            var txt = textGO.GetComponent<Text>();
            txt.text = label;
            txt.alignment = TextAnchor.MiddleCenter; // center-aligned labels
            txt.fontSize = BaseUIStyle.ButtonFontSize;
            txt.color = textColor;
            // Explicit font (avoid missing-font in builds)
            try { txt.font = Resources.GetBuiltinResource<Font>("Arial.ttf"); } catch {}
            txt.raycastTarget = false;
            txt.horizontalOverflow = HorizontalWrapMode.Overflow;
            txt.verticalOverflow = VerticalWrapMode.Truncate;
            // Subtle outline for readability over busy backgrounds
            var ol = textGO.AddComponent<Outline>();
            ol.effectColor = new Color(0,0,0,0.5f);
            ol.effectDistance = new Vector2(1f, -1f);

            // Explicit layer order (back -> front)
            fillGO.transform.SetSiblingIndex(0);
            borderGO.transform.SetSiblingIndex(1);
            textGO.transform.SetSiblingIndex(2);

            return btn;
        }

        // Toggle panel chrome (fill + border) without affecting layout or children
        public static void SetPanelDecorVisible(RectTransform panel, bool visible)
        {
            if (!panel) return;
            // Root image (should be disabled by CreatePanelSurface, but handle both cases)
            var rootImg = panel.GetComponent<Image>();
            if (rootImg) { rootImg.enabled = false; rootImg.raycastTarget = false; }

            // Child fill
            var fill = panel.Find("BG_Fill");
            if (fill) fill.gameObject.SetActive(visible);

            // Child border
            var border = panel.Find("Frame");
            if (border) border.gameObject.SetActive(visible);
        }

        // STACK CONTAINER (Bottom-right MenuPanel)
        public static RectTransform CreateBottomRightStack(Transform parent, string name = "MenuPanel")
        {
            var panel = CreatePanelSurface(parent, name);
            panel.anchorMin = new Vector2(1, 0);
            panel.anchorMax = new Vector2(1, 0);
            panel.pivot = new Vector2(1, 0);
            panel.anchoredPosition = new Vector2(-BaseUIStyle.EdgeOffset, BaseUIStyle.EdgeOffset);

            var layout = panel.GetComponent<VerticalLayoutGroup>();
            layout.childAlignment = TextAnchor.UpperCenter;

            var le = panel.GetComponent<LayoutElement>();
            if (le == null) le = panel.gameObject.AddComponent<LayoutElement>();
            le.preferredWidth = 420;
            le.flexibleWidth = 0;
            return panel;
        }

        // BACKGROUND IMAGE (full screen)
        public static Image CreateFullscreenBackground(Transform parent, Sprite sprite, Color fallbackColor)
        {
            var go = new GameObject("Background", typeof(RectTransform), typeof(CanvasRenderer), typeof(Image));
            go.transform.SetParent(parent, false);
            var rt = go.GetComponent<RectTransform>();
            rt.anchorMin = Vector2.zero;
            rt.anchorMax = Vector2.one;
            rt.offsetMin = Vector2.zero;
            rt.offsetMax = Vector2.zero;
            var img = go.GetComponent<Image>();
            if (sprite != null)
            {
                img.sprite = sprite;
                img.preserveAspect = true; // Background should not intercept clicks
                img.color = Color.white;
            }
            else
            {
                img.color = fallbackColor;
            }
            img.raycastTarget = false; // never block UI
            return img;
        }

    }
}

// ===== FILE: Assets/Scripts/UI/Widgets/UIFrame.cs =====
using UnityEngine;
using UnityEngine.UI;
using FantasyColony.UI.Style;

namespace FantasyColony.UI.Widgets
{
    // Pixel-precise frame that guarantees identical edge thickness on all sides.
    // Renders four edge Images cut from the source 9-slice sprite; optional corner Images can be added later if needed.
    [ExecuteAlways]
    [DisallowMultipleComponent]
    public class UIFrame : MonoBehaviour
    {
        [SerializeField] private Sprite _sourceNineSlice; // your dark border 9-slice
        [SerializeField] private float _targetBorderPx = 1f; // in screen pixels
        [SerializeField] private Color _tint = Color.white;

        // child images
        Image _top, _bottom, _left, _right;
        RectTransform _rt;
        Canvas _canvas;

        public void Init(Sprite nineSlice, float targetPx, Color tint)
        {
            _sourceNineSlice = nineSlice;
            _targetBorderPx = targetPx;
            _tint = tint;
            EnsureChildren();
            ApplyLook();
            LayoutNow();
        }

        void OnEnable()
        {
            _rt = GetComponent<RectTransform>();
            _canvas = GetComponentInParent<Canvas>();
            EnsureChildren();
            ApplyLook();
            LayoutNow();
        }

        void OnRectTransformDimensionsChange() => LayoutNow();
        void Update()
        {
#if UNITY_EDITOR
            // keep live in editor
            LayoutNow();
#endif
        }

        void EnsureChildren()
        {
            if (_rt == null) _rt = GetComponent<RectTransform>();
            if (_top == null) _top = CreateEdge("Top");
            if (_bottom == null) _bottom = CreateEdge("Bottom");
            if (_left == null) _left = CreateEdge("Left");
            if (_right == null) _right = CreateEdge("Right");
        }

        Image CreateEdge(string name)
        {
            var go = new GameObject(name, typeof(RectTransform), typeof(CanvasRenderer), typeof(Image));
            go.transform.SetParent(transform, false);
            var img = go.GetComponent<Image>();
            img.raycastTarget = false;
            return img;
        }

        void ApplyLook()
        {
            if (_sourceNineSlice == null) return;
            // Build sub-sprites for edges from the 9-slice source using its border rect
            var b = _sourceNineSlice.border; // L,R,T,B (pixels in source texture units)
            var rect = _sourceNineSlice.rect;
            var tex = _sourceNineSlice.texture;
            var ppu = _sourceNineSlice.pixelsPerUnit;

            // Top strip
            _top.sprite = Sprite.Create(tex, new Rect(rect.x, rect.yMax - b.z, rect.width, b.z), new Vector2(0.5f, 1f), ppu, 0, SpriteMeshType.FullRect);
            // Bottom strip
            _bottom.sprite = Sprite.Create(tex, new Rect(rect.x, rect.y, rect.width, b.w), new Vector2(0.5f, 0f), ppu, 0, SpriteMeshType.FullRect);
            // Left strip
            _left.sprite = Sprite.Create(tex, new Rect(rect.x, rect.y, b.x, rect.height), new Vector2(0f, 0.5f), ppu, 0, SpriteMeshType.FullRect);
            // Right strip
            _right.sprite = Sprite.Create(tex, new Rect(rect.xMax - b.y, rect.y, b.y, rect.height), new Vector2(1f, 0.5f), ppu, 0, SpriteMeshType.FullRect);

            _top.color = _bottom.color = _left.color = _right.color = _tint;

            _top.type = _bottom.type = _left.type = _right.type = Image.Type.Tiled;
            _top.preserveAspect = _bottom.preserveAspect = _left.preserveAspect = _right.preserveAspect = false;
        }

        void LayoutNow()
        {
            if (_rt == null) _rt = GetComponent<RectTransform>();
            if (_rt == null || _top == null) return;

            float px = Mathf.Max(0.0f, _targetBorderPx);

            // Top
            var trt = _top.rectTransform;
            trt.anchorMin = new Vector2(0f, 1f);
            trt.anchorMax = new Vector2(1f, 1f);
            trt.pivot = new Vector2(0.5f, 1f);
            trt.anchoredPosition = Vector2.zero;
            trt.sizeDelta = new Vector2(0f, Mathf.Round(px));

            // Bottom
            var brt = _bottom.rectTransform;
            brt.anchorMin = new Vector2(0f, 0f);
            brt.anchorMax = new Vector2(1f, 0f);
            brt.pivot = new Vector2(0.5f, 0f);
            brt.anchoredPosition = Vector2.zero;
            brt.sizeDelta = new Vector2(0f, Mathf.Round(px));

            // Left
            var lrt = _left.rectTransform;
            lrt.anchorMin = new Vector2(0f, 0f);
            lrt.anchorMax = new Vector2(0f, 1f);
            lrt.pivot = new Vector2(0f, 0.5f);
            lrt.anchoredPosition = Vector2.zero;
            lrt.sizeDelta = new Vector2(Mathf.Round(px), 0f);

            // Right
            var rrt = _right.rectTransform;
            rrt.anchorMin = new Vector2(1f, 0f);
            rrt.anchorMax = new Vector2(1f, 1f);
            rrt.pivot = new Vector2(1f, 0.5f);
            rrt.anchoredPosition = Vector2.zero;
            rrt.sizeDelta = new Vector2(Mathf.Round(px), 0f);
        }
    }
}

// ===== FILE: Assets/Scripts/Util/TransformPathExtensions.cs =====
using UnityEngine;

namespace FantasyColony
{
    public static class TransformPathExtensions
    {
        // Helper for readable logs (Editor only usage).
        public static string GetHierarchyPath(this Transform t)
        {
            if (t == null) return "<null>";
            System.Text.StringBuilder sb = new System.Text.StringBuilder(t.name);
            var p = t.parent;
            while (p != null)
            {
                sb.Insert(0, "/");
                sb.Insert(0, p.name);
                p = p.parent;
            }
            return sb.ToString();
        }
    }
}

// ===== FILE: Assets/TutorialInfo/Scripts/Editor/ReadmeEditor.cs =====
﻿using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEditor;
using System;
using System.IO;
using System.Reflection;

[CustomEditor(typeof(Readme))]
[InitializeOnLoad]
public class ReadmeEditor : Editor
{
    static string s_ShowedReadmeSessionStateName = "ReadmeEditor.showedReadme";
    
    static string s_ReadmeSourceDirectory = "Assets/TutorialInfo";

    const float k_Space = 16f;

    static ReadmeEditor()
    {
        EditorApplication.delayCall += SelectReadmeAutomatically;
    }

    static void RemoveTutorial()
    {
        if (EditorUtility.DisplayDialog("Remove Readme Assets",
            
            $"All contents under {s_ReadmeSourceDirectory} will be removed, are you sure you want to proceed?",
            "Proceed",
            "Cancel"))
        {
            if (Directory.Exists(s_ReadmeSourceDirectory))
            {
                FileUtil.DeleteFileOrDirectory(s_ReadmeSourceDirectory);
                FileUtil.DeleteFileOrDirectory(s_ReadmeSourceDirectory + ".meta");
            }
            else
            {
                Debug.Log($"Could not find the Readme folder at {s_ReadmeSourceDirectory}");
            }

            var readmeAsset = SelectReadme();
            if (readmeAsset != null)
            {
                var path = AssetDatabase.GetAssetPath(readmeAsset);
                FileUtil.DeleteFileOrDirectory(path + ".meta");
                FileUtil.DeleteFileOrDirectory(path);
            }

            AssetDatabase.Refresh();
        }
    }

    static void SelectReadmeAutomatically()
    {
        if (!SessionState.GetBool(s_ShowedReadmeSessionStateName, false))
        {
            var readme = SelectReadme();
            SessionState.SetBool(s_ShowedReadmeSessionStateName, true);

            if (readme && !readme.loadedLayout)
            {
                LoadLayout();
                readme.loadedLayout = true;
            }
        }
    }

    static void LoadLayout()
    {
        var assembly = typeof(EditorApplication).Assembly;
        var windowLayoutType = assembly.GetType("UnityEditor.WindowLayout", true);
        var method = windowLayoutType.GetMethod("LoadWindowLayout", BindingFlags.Public | BindingFlags.Static);
        method.Invoke(null, new object[] { Path.Combine(Application.dataPath, "TutorialInfo/Layout.wlt"), false });
    }

    static Readme SelectReadme()
    {
        var ids = AssetDatabase.FindAssets("Readme t:Readme");
        if (ids.Length == 1)
        {
            var readmeObject = AssetDatabase.LoadMainAssetAtPath(AssetDatabase.GUIDToAssetPath(ids[0]));

            Selection.objects = new UnityEngine.Object[] { readmeObject };

            return (Readme)readmeObject;
        }
        else
        {
            Debug.Log("Couldn't find a readme");
            return null;
        }
    }

    protected override void OnHeaderGUI()
    {
        var readme = (Readme)target;
        Init();

        var iconWidth = Mathf.Min(EditorGUIUtility.currentViewWidth / 3f - 20f, 128f);

        GUILayout.BeginHorizontal("In BigTitle");
        {
            if (readme.icon != null)
            {
                GUILayout.Space(k_Space);
                GUILayout.Label(readme.icon, GUILayout.Width(iconWidth), GUILayout.Height(iconWidth));
            }
            GUILayout.Space(k_Space);
            GUILayout.BeginVertical();
            {

                GUILayout.FlexibleSpace();
                GUILayout.Label(readme.title, TitleStyle);
                GUILayout.FlexibleSpace();
            }
            GUILayout.EndVertical();
            GUILayout.FlexibleSpace();
        }
        GUILayout.EndHorizontal();
    }

    public override void OnInspectorGUI()
    {
        var readme = (Readme)target;
        Init();

        foreach (var section in readme.sections)
        {
            if (!string.IsNullOrEmpty(section.heading))
            {
                GUILayout.Label(section.heading, HeadingStyle);
            }

            if (!string.IsNullOrEmpty(section.text))
            {
                GUILayout.Label(section.text, BodyStyle);
            }

            if (!string.IsNullOrEmpty(section.linkText))
            {
                if (LinkLabel(new GUIContent(section.linkText)))
                {
                    Application.OpenURL(section.url);
                }
            }

            GUILayout.Space(k_Space);
        }

        if (GUILayout.Button("Remove Readme Assets", ButtonStyle))
        {
            RemoveTutorial();
        }
    }

    bool m_Initialized;

    GUIStyle LinkStyle
    {
        get { return m_LinkStyle; }
    }

    [SerializeField]
    GUIStyle m_LinkStyle;

    GUIStyle TitleStyle
    {
        get { return m_TitleStyle; }
    }

    [SerializeField]
    GUIStyle m_TitleStyle;

    GUIStyle HeadingStyle
    {
        get { return m_HeadingStyle; }
    }

    [SerializeField]
    GUIStyle m_HeadingStyle;

    GUIStyle BodyStyle
    {
        get { return m_BodyStyle; }
    }

    [SerializeField]
    GUIStyle m_BodyStyle;

    GUIStyle ButtonStyle
    {
        get { return m_ButtonStyle; }
    }

    [SerializeField]
    GUIStyle m_ButtonStyle;

    void Init()
    {
        if (m_Initialized)
            return;
        m_BodyStyle = new GUIStyle(EditorStyles.label);
        m_BodyStyle.wordWrap = true;
        m_BodyStyle.fontSize = 14;
        m_BodyStyle.richText = true;

        m_TitleStyle = new GUIStyle(m_BodyStyle);
        m_TitleStyle.fontSize = 26;

        m_HeadingStyle = new GUIStyle(m_BodyStyle);
        m_HeadingStyle.fontStyle = FontStyle.Bold;
        m_HeadingStyle.fontSize = 18;

        m_LinkStyle = new GUIStyle(m_BodyStyle);
        m_LinkStyle.wordWrap = false;

        // Match selection color which works nicely for both light and dark skins
        m_LinkStyle.normal.textColor = new Color(0x00 / 255f, 0x78 / 255f, 0xDA / 255f, 1f);
        m_LinkStyle.stretchWidth = false;

        m_ButtonStyle = new GUIStyle(EditorStyles.miniButton);
        m_ButtonStyle.fontStyle = FontStyle.Bold;

        m_Initialized = true;
    }

    bool LinkLabel(GUIContent label, params GUILayoutOption[] options)
    {
        var position = GUILayoutUtility.GetRect(label, LinkStyle, options);

        Handles.BeginGUI();
        Handles.color = LinkStyle.normal.textColor;
        Handles.DrawLine(new Vector3(position.xMin, position.yMax), new Vector3(position.xMax, position.yMax));
        Handles.color = Color.white;
        Handles.EndGUI();

        EditorGUIUtility.AddCursorRect(position, MouseCursor.Link);

        return GUI.Button(position, label, LinkStyle);
    }
}

// ===== FILE: Assets/TutorialInfo/Scripts/Readme.cs =====
﻿using System;
using UnityEngine;

public class Readme : ScriptableObject
{
    public Texture2D icon;
    public string title;
    public Section[] sections;
    public bool loadedLayout;

    [Serializable]
    public class Section
    {
        public string heading, text, linkText, url;
    }
}

// ===== FILE: Tools/XmlDefsTools/Emit/SchemaCatalogWriter.cs =====
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Xml.Linq;
using XmlDefsTools.Scan;
using XmlDefsTools.Util;

namespace XmlDefsTools.Emit
{
    /// <summary>
    /// Writes a consolidated catalog file listing all schemas,
    /// their union of attributes and elements, and a canonical template
    /// sample for each schema.
    /// </summary>
    public static class SchemaCatalogWriter
    {
        public static void Write(string outputDir, ScanResult scan,
            IReadOnlyDictionary<string, IList<string>> orderHints)
        {
            Directory.CreateDirectory(outputDir);
            var outPath = Path.Combine(outputDir, "_AllSchemas.xml");

            var configuredSchemas = orderHints.Keys
                .Where(k => !string.Equals(k, "_common", StringComparison.OrdinalIgnoreCase)
                    && !k.StartsWith("//"))
                .ToHashSet(StringComparer.OrdinalIgnoreCase);
            var allSchemas = new HashSet<string>(scan.Schemas, StringComparer.OrdinalIgnoreCase);
            foreach (var s in configuredSchemas) allSchemas.Add(s);

            var doc = new XDocument(
                new XElement("DefSchemas",
                    new XAttribute("generated",
                        DateTime.UtcNow.ToString("yyyy-MM-ddTHH:mm:ssZ")))
            );

            var common = orderHints.TryGetValue("_common", out var commonOrder)
                ? commonOrder
                : Array.Empty<string>();

            foreach (var schema in allSchemas.OrderBy(s => s, StringComparer.OrdinalIgnoreCase))
            {
                var perSchema = orderHints.TryGetValue(schema, out var per)
                    ? per : Array.Empty<string>();
                var precedence = common.Concat(perSchema).ToList();

                // Collect union of fields from discovered defs
                var attrFields = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
                var elemFields = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
                if (scan.DefsBySchema.TryGetValue(schema, out var defs))
                {
                    foreach (var d in defs)
                    {
                        foreach (var a in d.AttributeFields) attrFields.Add(a);
                        foreach (var e in d.ElementFields) elemFields.Add(e);
                    }
                }

                // Seed with configured fields
                foreach (var hinted in perSchema) elemFields.Add(hinted);

                // Attributes for root + ordered element list
                var rootAttrs = NormalizeOrder(attrFields, precedence,
                    keepOnly: new[] { "id", "schema", "name_key", "tags", "version", "requires" });
                var elementNames = NormalizeOrder(
                    elemFields.Except(rootAttrs, StringComparer.OrdinalIgnoreCase), precedence);

                // Build a canonical template element (same rules as TemplateSynthesizer)
                var root = new XElement(schema);
                foreach (var a in rootAttrs)
                {
                    var placeholder = a.Equals("id", StringComparison.OrdinalIgnoreCase) ? "your_id_here"
                        : a.Equals("name_key", StringComparison.OrdinalIgnoreCase) ? "ui.your.key.here"
                        : a.Equals("tags", StringComparison.OrdinalIgnoreCase) ? string.Empty
                        : a.Equals("version", StringComparison.OrdinalIgnoreCase) ? "1"
                        : string.Empty;
                    root.SetAttributeValue(a, placeholder);
                }

                bool HasElem(string name) =>
                    elementNames.Any(n => n.Equals(name, StringComparison.OrdinalIgnoreCase));
                if (HasElem("version") && root.Attribute("version") == null)
                    root.Add(new XElement("version", "1"));
                if (HasElem("requires") && root.Attribute("requires") == null)
                    root.Add(new XElement("requires"));
                if (HasElem("components") ||
                    perSchema.Contains("components", StringComparer.OrdinalIgnoreCase))
                {
                    root.Add(new XElement("components",
                        new XComment(" Add component entries like <Component type=\"...\"/> ")));
                }
                foreach (var el in elementNames)
                {
                    if (string.Equals(el, "components", StringComparison.OrdinalIgnoreCase))
                        continue;
                    if (string.Equals(el, "version", StringComparison.OrdinalIgnoreCase)
                        && root.Elements("version").Any())
                        continue;
                    if (string.Equals(el, "requires", StringComparison.OrdinalIgnoreCase)
                        && root.Elements("requires").Any())
                        continue;
                    root.Add(new XElement(el));
                }
                var canonicalElement = CanonicalXml.CanonicalizeElement(root);

                // Compose catalog node
                var schemaNode = new XElement("Schema",
                    new XAttribute("name", schema),
                    new XElement("Attributes",
                        rootAttrs.Select(a => new XElement("Attr", new XAttribute("name", a)))),
                    new XElement("Elements",
                        elementNames.Select(e => new XElement("El", new XAttribute("name", e)))),
                    new XElement("Template", canonicalElement));

                doc.Root!.Add(schemaNode);
            }

            doc.Save(outPath);
        }

        private static List<string> NormalizeOrder(IEnumerable<string> names,
            IList<string> precedence, IEnumerable<string>? keepOnly = null)
        {
            var all = new HashSet<string>(names, StringComparer.OrdinalIgnoreCase);
            if (keepOnly != null)
            {
                var keep = new HashSet<string>(keepOnly, StringComparer.OrdinalIgnoreCase);
                all.RemoveWhere(n => !keep.Contains(n));
            }

            var ordered = new List<string>();
            foreach (var p in precedence)
            {
                if (all.Remove(p)) ordered.Add(p);
            }
            ordered.AddRange(all.OrderBy(n => n, StringComparer.OrdinalIgnoreCase));
            return ordered;
        }
    }
}


// ===== FILE: Tools/XmlDefsTools/Emit/TemplateSynthesizer.cs =====
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Xml.Linq;
using XmlDefsTools.Scan;
using XmlDefsTools.Util;

namespace XmlDefsTools.Emit
{
    public static class TemplateSynthesizer
    {
        public static void WriteTemplates(string outputDir, ScanResult scan, IReadOnlyDictionary<string, IList<string>> orderHints)
        {
            Directory.CreateDirectory(outputDir);
            // union of discovered schemas and configured schemas (ensures baseline output)
            var configuredSchemas = orderHints.Keys
                .Where(k => !string.Equals(k, "_common", StringComparison.OrdinalIgnoreCase) && !k.StartsWith("//"))
                .ToHashSet(StringComparer.OrdinalIgnoreCase);
            var allSchemas = new HashSet<string>(scan.Schemas, StringComparer.OrdinalIgnoreCase);
            foreach (var s in configuredSchemas) allSchemas.Add(s);

            foreach (var schema in allSchemas.OrderBy(s => s))
            {
                // if no defs discovered, synthesize from hints only
                var defs = scan.DefsBySchema.ContainsKey(schema)
                    ? scan.DefsBySchema[schema]
                    : new List<DefInfo>();

                // union of observed fields (attributes + elements)
                var attrFields = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
                var elemFields = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
                // include configured per-schema fields as elements to seed structure
                if (orderHints.TryGetValue(schema, out var hinted))
                {
                    foreach (var h in hinted) elemFields.Add(h);
                }
                foreach (var d in defs)
                {
                    foreach (var f in d.AttributeFields) attrFields.Add(f);
                    foreach (var f in d.ElementFields) elemFields.Add(f);
                }

                // known/common order
                var common = orderHints.TryGetValue("_common", out var c) ? c : Array.Empty<string>();
                var perSchema = orderHints.TryGetValue(schema, out var s) ? s : Array.Empty<string>();
                var precedence = common.Concat(perSchema).ToList();

                // Attributes to place on root element
                var rootAttrs = NormalizeOrder(attrFields, precedence, keepOnly: new[] { "id","schema","name_key","tags","version","requires" });
                // Remaining element fields (drop those already in attributes)
                var elementNames = NormalizeOrder(elemFields.Except(rootAttrs, StringComparer.OrdinalIgnoreCase),
                                                  precedence);

                bool HasElem(string name) => elementNames.Any(n => n.Equals(name, StringComparison.OrdinalIgnoreCase));

                var sb = new StringBuilder();
                sb.AppendLine($"<!-- Auto-generated default template for {schema}. Edit your copies; this file is regenerated. -->");

                var root = new XElement(schema);
                // Put attributes with placeholders
                foreach (var a in rootAttrs)
                {
                    var placeholder = a.Equals("id", StringComparison.OrdinalIgnoreCase) ? "your_id_here"
                                   : a.Equals("name_key", StringComparison.OrdinalIgnoreCase) ? "ui.your.key.here"
                                   : a.Equals("tags", StringComparison.OrdinalIgnoreCase) ? ""
                                   : a.Equals("version", StringComparison.OrdinalIgnoreCase) ? "1"
                                   : "";
                    root.SetAttributeValue(a, placeholder);
                }

                // Insert version/requires as elements too if heavily used as elements
                if (HasElem("version") && root.Attribute("version") == null)
                    root.Add(new XElement("version", "1"));
                if (HasElem("requires") && root.Attribute("requires") == null)
                    root.Add(new XElement("requires"));

                // Components block if observed
                if (HasElem("components") || perSchema.Contains("components", StringComparer.OrdinalIgnoreCase))
                {
                    root.Add(new XElement("components",
                        new XComment(" Add component entries like <Component type=\"...\"/> ")));
                }

                // Other fields as empty elements
                foreach (var el in elementNames)
                {
                    if (string.Equals(el, "components", StringComparison.OrdinalIgnoreCase)) continue;
                    if (string.Equals(el, "version", StringComparison.OrdinalIgnoreCase) && root.Elements("version").Any()) continue;
                    if (string.Equals(el, "requires", StringComparison.OrdinalIgnoreCase) && root.Elements("requires").Any()) continue;
                    root.Add(new XElement(el));
                }

                // Canonicalize attribute order
                var canonical = CanonicalXml.CanonicalizeElement(root);
                sb.AppendLine(canonical.ToString(SaveOptions.None));

                var outPath = Path.Combine(outputDir, $"{schema}.xml");
                File.WriteAllText(outPath, sb.ToString());
            }
        }

        private static List<string> NormalizeOrder(IEnumerable<string> names, IList<string> precedence, IEnumerable<string>? keepOnly = null)
        {
            var all = new HashSet<string>(names, StringComparer.OrdinalIgnoreCase);
            if (keepOnly != null)
            {
                var keep = new HashSet<string>(keepOnly, StringComparer.OrdinalIgnoreCase);
                all.RemoveWhere(n => !keep.Contains(n));
            }
            var ordered = new List<string>();
            foreach (var p in precedence)
            {
                if (all.Remove(p)) ordered.Add(p);
            }
            ordered.AddRange(all.OrderBy(n => n, StringComparer.OrdinalIgnoreCase));
            return ordered;
        }
    }
}

// ===== FILE: Tools/XmlDefsTools/Emit/XmlIndexWriter.cs =====
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using XmlDefsTools.Scan;

namespace XmlDefsTools.Emit
{
    public static class XmlIndexWriter
    {
        public static void Write(string repoRoot, string outFile, ScanResult scan)
        {
            var sb = new StringBuilder();
            sb.AppendLine("# XML Index (.xml)");
            sb.AppendLine();
            sb.AppendLine($"_Generated: {DateTime.UtcNow:yyyy-MM-dd HH:mm} UTC_");
            sb.AppendLine();
            sb.AppendLine($"**Total files scanned:** {scan.TotalFiles}  ");
            sb.AppendLine($"**Valid XML files:** {scan.ValidFiles}  ");
            sb.AppendLine($"**Defs discovered:** {scan.TotalDefs}  ");
            sb.AppendLine();

            if (scan.Errors.Any())
            {
                sb.AppendLine("## Parse Errors");
                foreach (var err in scan.Errors)
                {
                    sb.AppendLine($"- `{Rel(repoRoot, err.File)}` — {err.Message}");
                }
                sb.AppendLine();
            }

            if (scan.DuplicateIds.Any())
            {
                sb.AppendLine("## Duplicate IDs");
                foreach (var kvp in scan.DuplicateIds.OrderBy(k => k.Key, StringComparer.OrdinalIgnoreCase))
                {
                    sb.AppendLine($"- **{kvp.Key}**");
                    foreach (var item in kvp.Value)
                    {
                        sb.AppendLine($"  - `{item.Schema}` in `{Rel(repoRoot, item.SourceFile)}`");
                    }
                }
                sb.AppendLine();
            }

            // Match Code Index style: bulleted list of files with View · Raw links
            var (repo, branch) = RepoMeta();
            var allXmlFiles = scan.FileDocs.Keys.OrderBy(p => p, StringComparer.OrdinalIgnoreCase).ToList();
            if (allXmlFiles.Count > 0)
            {
                foreach (var file in allXmlFiles)
                {
                    var rel = Rel(repoRoot, file);
                    var webPath = rel.Replace('\\','/'); // ensure URL form
                    var enc = EncodePathSegments(webPath);
                    var viewUrl = $"https://github.com/{repo}/blob/{branch}/{enc}";
                    var rawUrl  = $"https://raw.githubusercontent.com/{repo}/{branch}/{enc}";
                    sb.AppendLine($"- `{webPath}` — [View]({viewUrl}) · [Raw]({rawUrl})");
                }
                sb.AppendLine();
            }

            // Keep the schema summary (below the list) for quick counts
            sb.AppendLine("## Summary by Schema");
            sb.AppendLine();
            sb.AppendLine("| Schema | Def Count | Files |");
            sb.AppendLine("|---|---:|---|");
            foreach (var schema in scan.Schemas.OrderBy(s => s))
            {
                var defs = scan.DefsBySchema[schema];
                var files = defs.Select(d => Rel(repoRoot, d.SourceFile)).Distinct().OrderBy(s => s);
                sb.AppendLine($"| {schema} | {defs.Count} | {string.Join("<br/>", files)} |");
            }
            sb.AppendLine();

            // Per-schema sections unchanged below (list ids + rare fields)

            foreach (var schema in scan.Schemas.OrderBy(s => s))
            {
                var defs = scan.DefsBySchema[schema];
                sb.AppendLine($"### {schema}");
                sb.AppendLine();
                foreach (var d in defs.OrderBy(d => d.Id, StringComparer.OrdinalIgnoreCase))
                {
                    sb.AppendLine($"- `{d.Id}` — `{Rel(repoRoot, d.SourceFile)}`");
                }
                // Any newly observed/rare fields
                var fieldCounts = new Dictionary<string,int>(StringComparer.OrdinalIgnoreCase);
                foreach (var d in defs)
                {
                    foreach (var f in d.AttributeFields.Concat(d.ElementFields))
                        fieldCounts[f] = fieldCounts.TryGetValue(f, out var c) ? c + 1 : 1;
                }
                var rare = fieldCounts.Where(kvp => kvp.Value <= Math.Max(1, defs.Count/5)).Select(kvp => kvp.Key).OrderBy(s=>s, StringComparer.OrdinalIgnoreCase).ToList();
                if (rare.Count > 0)
                {
                    sb.AppendLine();
                    sb.AppendLine("<details><summary>Less common fields</summary>");
                    sb.AppendLine();
                    foreach (var f in rare) sb.AppendLine($"- `{f}`");
                    sb.AppendLine();
                    sb.AppendLine("</details>");
                }
                sb.AppendLine();
            }

            Directory.CreateDirectory(Path.GetDirectoryName(outFile)!);
            File.WriteAllText(outFile, sb.ToString());
        }

        // Encode each path segment to avoid corrupting '/' and handle special characters safely.
        private static string EncodePathSegments(string path)
        {
            var parts = path.Replace('\\','/').Split(new[]{'/'}, StringSplitOptions.RemoveEmptyEntries);
            var encoded = parts.Select(Uri.EscapeDataString);
            return string.Join("/", encoded);
        }

        private static (string repo, string branch) RepoMeta()
        {
            var repo = Environment.GetEnvironmentVariable("GITHUB_REPOSITORY");
            if (string.IsNullOrWhiteSpace(repo)) repo = "Natangry/FantasyColony";
            var branch = Environment.GetEnvironmentVariable("GITHUB_REF_NAME");
            if (string.IsNullOrWhiteSpace(branch)) branch = "main";
            // strip refs/heads/ if present
            branch = branch.Replace("refs/heads/", "");
            return (repo, branch);
        }

        private static string Rel(string root, string path)
        {
            try
            {
                var rp = Path.GetRelativePath(root, path).Replace('\\','/');
                return rp;
            }
            catch
            {
                return path.Replace('\\','/');
            }
        }
    }
}

// ===== FILE: Tools/XmlDefsTools/Emit/XmlSnapshotWriter.cs =====
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Xml.Linq;
using XmlDefsTools.Util;

namespace XmlDefsTools.Emit
{
    public static class XmlSnapshotWriter
    {
        public static void Write(string repoRoot, string outFile, IEnumerable<(string path, XDocument? doc)> docs)
        {
            var sb = new StringBuilder();
            foreach (var (path, doc) in docs.OrderBy(t => t.path, StringComparer.OrdinalIgnoreCase))
            {
                sb.AppendLine($"// ===== FILE: {Rel(repoRoot, path)} =====");
                if (doc == null)
                {
                    sb.AppendLine("// (invalid XML)");
                    sb.AppendLine();
                    continue;
                }
                var normalized = CanonicalXml.Canonicalize(doc);
                sb.AppendLine(normalized);
                sb.AppendLine();
            }
            File.WriteAllText(outFile, sb.ToString());
        }

        private static string Rel(string root, string path)
        {
            try
            {
                var rp = Path.GetRelativePath(root, path).Replace('\\','/');
                return rp;
            }
            catch
            {
                return path.Replace('\\','/');
            }
        }
    }
}

// ===== FILE: Tools/XmlDefsTools/Program.cs =====
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text.Json;
using XmlDefsTools.Emit;
using XmlDefsTools.Scan;

namespace XmlDefsTools
{
    internal static class Program
    {
        private static int Main(string[] args)
        {
            try
            {
                var repoRoot = GetRepoRoot();
                var defsDir = GetDefsDir(repoRoot);
                Console.WriteLine($"[XmlDefsTools] Repo root: {repoRoot}");
                Console.WriteLine($"[XmlDefsTools] Defs dir : {defsDir}");

                var scanner = new XmlDefScanner();
                var scan = scanner.Scan(defsDir);

                // Load order hints
                var hintsPath = Path.Combine(repoRoot, "Tools", "XmlDefsTools", "Config", "SchemaOrder.json");
                var orderHints = File.Exists(hintsPath)
                    ? JsonSerializer.Deserialize<Dictionary<string, IList<string>>>(File.ReadAllText(hintsPath))
                    : new Dictionary<string, IList<string>>(StringComparer.OrdinalIgnoreCase);
                orderHints ??= new Dictionary<string, IList<string>>(StringComparer.OrdinalIgnoreCase);

                // Write index
                var indexPath = Path.Combine(repoRoot, "XML_INDEX.md");
                XmlIndexWriter.Write(repoRoot, indexPath, scan);
                Console.WriteLine($"[XmlDefsTools] Wrote index: {indexPath}");

                // Write snapshot
                var snapshotPath = Path.Combine(repoRoot, "XML_SNAPSHOT.txt");
                var docs = scan.FileDocs.Select(kvp => (kvp.Key, kvp.Value));
                XmlSnapshotWriter.Write(repoRoot, snapshotPath, docs);
                Console.WriteLine($"[XmlDefsTools] Wrote snapshot: {snapshotPath}");

                // Write templates
                var templatesDir = Path.Combine(repoRoot, "Docs", "Templates", "Defs");
                TemplateSynthesizer.WriteTemplates(templatesDir, scan, orderHints);
                Console.WriteLine($"[XmlDefsTools] Wrote templates to: {templatesDir}");

                // Write consolidated schema catalog
                SchemaCatalogWriter.Write(templatesDir, scan, orderHints);
                Console.WriteLine($"[XmlDefsTools] Wrote consolidated catalog: {Path.Combine(templatesDir, "_AllSchemas.xml")}");

                return 0;
            }
            catch (Exception ex)
            {
                Console.Error.WriteLine(ex.ToString());
                return 1;
            }
        }

        private static string GetRepoRoot()
        {
            var env = Environment.GetEnvironmentVariable("FC_REPO_ROOT");
            if (!string.IsNullOrWhiteSpace(env))
                return Path.GetFullPath(env);
            // assume current working directory is repo root (CI) or a subfolder (local)
            var cwd = Directory.GetCurrentDirectory();
            // try to find .git upwards
            var dir = new DirectoryInfo(cwd);
            while (dir != null)
            {
                if (Directory.Exists(Path.Combine(dir.FullName, ".git")))
                    return dir.FullName;
                dir = dir.Parent;
            }
            return cwd;
        }

        private static string GetDefsDir(string repoRoot)
        {
            var env = Environment.GetEnvironmentVariable("FC_DEFS_DIR");
            if (!string.IsNullOrWhiteSpace(env))
            {
                var p = Path.IsPathRooted(env) ? env : Path.Combine(repoRoot, env);
                return Directory.Exists(p) ? p : repoRoot;
            }
            var candidates = new[]
            {
                Path.Combine(repoRoot, "StreamingAssets", "Defs"),
                Path.Combine(repoRoot, "Assets", "StreamingAssets", "Defs"),
                Path.Combine(repoRoot, "GameData", "Defs")
            };
            foreach (var c in candidates)
                if (Directory.Exists(c)) return c;
            // fallback: repo root (will scan, find no files, still emit artifacts)
            return repoRoot;
        }
    }
}

// ===== FILE: Tools/XmlDefsTools/Scan/XmlDefScanner.cs =====
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Xml;
using System.Xml.Linq;

namespace XmlDefsTools.Scan
{
    public sealed class XmlDefScanner
    {
        public ScanResult Scan(string rootDir)
        {
            var res = new ScanResult();
            if (!Directory.Exists(rootDir))
                return res;

            var files = Directory.EnumerateFiles(rootDir, "*.xml", SearchOption.AllDirectories).ToList();
            res.TotalFiles = files.Count;
            foreach (var file in files)
            {
                XDocument? doc = null;
                try
                {
                    var text = File.ReadAllText(file);
                    doc = XDocument.Parse(text, LoadOptions.PreserveWhitespace | LoadOptions.SetLineInfo);
                    res.ValidFiles++;
                    res.FileDocs[file] = doc;
                }
                catch (Exception ex)
                {
                    res.Errors.Add(new ScanError { File = file, Message = ex.GetBaseException().Message });
                    res.FileDocs[file] = null;
                    continue;
                }

                // Collect defs: any element with an 'id' attribute
                var defs = doc.Descendants()
                    .Where(e => e.NodeType == System.Xml.XmlNodeType.Element)
                    .OfType<XElement>()
                    .Where(e => e.Attribute("id") != null)
                    .ToList();

                foreach (var el in defs)
                {
                    var schema = el.Name.LocalName;
                    var id = (string?)el.Attribute("id") ?? "(missing)";
                    var info = new DefInfo
                    {
                        Schema = schema,
                        Id = id,
                        SourceFile = file
                    };

                    // Attribute fields (names only)
                    foreach (var a in el.Attributes())
                    {
                        if (a.IsNamespaceDeclaration) continue;
                        info.AttributeFields.Add(a.Name.LocalName);
                    }

                    // Element fields (direct child element names only)
                    foreach (var child in el.Elements())
                    {
                        info.ElementFields.Add(child.Name.LocalName);
                    }

                    res.TotalDefs++;
                    if (!res.DefsBySchema.TryGetValue(schema, out var list))
                    {
                        list = new List<DefInfo>();
                        res.DefsBySchema[schema] = list;
                        res.Schemas.Add(schema);
                    }
                    list.Add(info);

                    // Track duplicates
                    var dupKey = $"{schema}:{id}";
                    if (!res.DuplicateIds.TryGetValue(dupKey, out var dupList))
                    {
                        dupList = new List<DefInfo>();
                        res.DuplicateIds[dupKey] = dupList;
                    }
                    dupList.Add(info);
                }
            }

            // Remove entries that are not actually duplicates (only one occurrence)
            var toPrune = res.DuplicateIds.Where(kvp => kvp.Value.Count <= 1)
                                          .Select(kvp => kvp.Key).ToList();
            foreach (var k in toPrune) res.DuplicateIds.Remove(k);

            return res;
        }
    }

    public sealed class ScanResult
    {
        public int TotalFiles { get; set; }
        public int ValidFiles { get; set; }
        public int TotalDefs { get; set; }
        public HashSet<string> Schemas { get; } = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
        public Dictionary<string, List<DefInfo>> DefsBySchema { get; } = new Dictionary<string, List<DefInfo>>(StringComparer.OrdinalIgnoreCase);
        public List<ScanError> Errors { get; } = new List<ScanError>();
        public Dictionary<string, XDocument?> FileDocs { get; } = new Dictionary<string, XDocument?>(StringComparer.OrdinalIgnoreCase);
        public Dictionary<string, List<DefInfo>> DuplicateIds { get; } = new Dictionary<string, List<DefInfo>>(StringComparer.OrdinalIgnoreCase);
    }

    public sealed class DefInfo
    {
        public string Schema { get; set; } = "";
        public string Id { get; set; } = "";
        public string SourceFile { get; set; } = "";
        public HashSet<string> AttributeFields { get; } = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
        public HashSet<string> ElementFields { get; } = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
    }

    public sealed class ScanError
    {
        public string File { get; set; } = "";
        public string Message { get; set; } = "";
    }
}

// ===== FILE: Tools/XmlDefsTools/Util/CanonicalXml.cs =====
using System;
using System.IO;
using System.Linq;
using System.Text;
using System.Xml;
using System.Xml.Linq;

namespace XmlDefsTools.Util
{
    public static class CanonicalXml
    {
        private static readonly string[] AttributePrecedence =
        {
            "id","schema","name_key","tags","version","requires"
        };

        public static string Canonicalize(XDocument doc)
        {
            // Remove comments
            foreach (var c in doc.DescendantNodes().OfType<XComment>().ToList())
                c.Remove();

            // Canonicalize elements & attributes
            var root = CanonicalizeElement(doc.Root!);
            var newDoc = new XDocument(root);

            // Save with stable formatting
            var settings = new XmlWriterSettings
            {
                OmitXmlDeclaration = true,
                Indent = true,
                NewLineOnAttributes = false
            };
            var sb = new StringBuilder();
            using (var writer = XmlWriter.Create(sb, settings))
            {
                newDoc.Save(writer);
            }
            return sb.ToString().Trim() + Environment.NewLine;
        }

        public static XElement CanonicalizeElement(XElement el)
        {
            var orderedAttrs = el.Attributes()
                .Where(a => !a.IsNamespaceDeclaration)
                .OrderBy(a => OrderKey(a.Name.LocalName))
                .ThenBy(a => a.Name.LocalName, StringComparer.OrdinalIgnoreCase)
                .ToList();

            var newEl = new XElement(el.Name);
            foreach (var a in orderedAttrs)
                newEl.SetAttributeValue(a.Name.LocalName, a.Value);

            foreach (var node in el.Nodes())
            {
                if (node is XElement child)
                {
                    newEl.Add(CanonicalizeElement(child));
                }
                else if (node is XText t)
                {
                    var v = t.Value;
                    if (!string.IsNullOrWhiteSpace(v))
                        newEl.Add(new XText(NormalizeWhitespace(v)));
                }
                // other node types (comments, processing instructions) are skipped
            }
            return newEl;
        }

        private static int OrderKey(string name)
        {
            for (int i = 0; i < AttributePrecedence.Length; i++)
                if (name.Equals(AttributePrecedence[i], StringComparison.OrdinalIgnoreCase))
                    return i - 1000; // bubble to front
            return 0;
        }

        private static string NormalizeWhitespace(string s)
        {
            // Collapse internal whitespace sequences
            var arr = s.ToCharArray();
            var sb = new StringBuilder(arr.Length);
            bool inWs = false;
            foreach (var ch in arr)
            {
                if (char.IsWhiteSpace(ch))
                {
                    if (!inWs)
                    {
                        sb.Append(' ');
                        inWs = true;
                    }
                }
                else
                {
                    sb.Append(ch);
                    inWs = false;
                }
            }
            return sb.ToString().Trim();
        }
    }
}

