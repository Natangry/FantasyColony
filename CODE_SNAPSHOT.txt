# Auto-generated code snapshot
_Updated_: 2025-08-31 10:26:04 UTC

// ===== FILE: Assets/Editor/SpriteImportDefaults.cs =====
// Editor-only: ensures sprites import with our project defaults (hi-res, crisp pixels).
// - Applies automatically to any texture under a folder named "Sprites" (e.g. Assets/Resources/Sprites/)
// - Adds menu items to (re)apply settings to selected textures or an entire folder
//
// Defaults:
//   TextureType: Sprite (2D and UI)
//   SpriteMode: Single
//   Pixels Per Unit: 64
//   Filter Mode: Point (no filter)
//   Compression: None (Uncompressed)
//   Wrap Mode: Clamp
//   MipMaps: Off
//   sRGB: On
//   Alpha Is Transparency: On (where supported)
//   Pivot: Bottom-Center (0.5, 0.0)

#if UNITY_EDITOR
using System;
using System.Linq;
using UnityEditor;
using UnityEngine;
using System.Reflection;

namespace FantasyColony.EditorTools
{
    public class SpriteImportDefaults : AssetPostprocessor
    {
        const float DefaultPPU = 64f;
        const int   DefaultMaxSize = 1024;

        static bool IsSpritePath(string path)
        {
            if (string.IsNullOrEmpty(path)) return false;
            path = path.Replace('\\', '/').ToLowerInvariant();
            return path.Contains("/sprites/");
        }

        void OnPreprocessTexture()
        {
            if (!IsSpritePath(assetPath)) return;
            var ti = (TextureImporter)assetImporter;
            ApplyDefaults(ti);
        }

        static void ApplyDefaults(TextureImporter ti)
        {
            ti.textureType = TextureImporterType.Sprite;
            ti.spriteImportMode = SpriteImportMode.Single;
            ti.spritePixelsPerUnit = DefaultPPU;
            ti.mipmapEnabled = false;
            ti.filterMode = FilterMode.Point;
            ti.textureCompression = TextureImporterCompression.Uncompressed;
            ti.wrapMode = TextureWrapMode.Clamp;
            ti.maxTextureSize = DefaultMaxSize;

            // Color space & alpha handling
#if UNITY_2019_3_OR_NEWER
            ti.sRGBTexture = true;
#endif
#if !UNITY_2023_1_OR_NEWER
            // In newer versions this field may be hidden/ignored, but it's safe to set where available.
            ti.alphaIsTransparency = true;
#endif
#if UNITY_2021_2_OR_NEWER
            ti.alphaSource = TextureImporterAlphaSource.FromInput;
#endif

            // Pivot: Bottom-Center (Unity 6 removed 'spriteAlignment'; set via spritePivot and
            // use reflection to set alignment to Custom when property exists on older versions)
            SetPivotBottomCenter(ti);
        }

        static void SetPivotBottomCenter(TextureImporter ti)
        {
            // Always set explicit pivot
            ti.spritePivot = new Vector2(0.5f, 0f);

            // Try to set alignment to Custom when the legacy property exists
            try
            {
                var prop = typeof(TextureImporter).GetProperty("spriteAlignment",
                    BindingFlags.Public | BindingFlags.Instance);
                if (prop != null && prop.CanWrite)
                {
                    var enumType = prop.PropertyType;
                    object customVal = null;
                    // If type is an enum that defines "Custom", use it; otherwise fall back to 9
                    if (enumType.IsEnum && Enum.GetNames(enumType).Contains("Custom"))
                        customVal = Enum.Parse(enumType, "Custom");
                    else
                        customVal = Convert.ChangeType(9, enumType); // 9 == SpriteAlignment.Custom in legacy

                    prop.SetValue(ti, customVal);
                }
            }
            catch
            {
                // Safe no-op on newer Unity versions
            }
        }

        // --- Context menus ---------------------------------------------------

        [MenuItem("Assets/Sprites/Apply Sprite Defaults (64 PPU)", true)]
        static bool ValidateApplyToSelection()
        {
            return Selection.assetGUIDs != null && Selection.assetGUIDs.Length > 0;
        }

        [MenuItem("Assets/Sprites/Apply Sprite Defaults (64 PPU)")]
        static void ApplyToSelection()
        {
            int count = 0;
            foreach (var guid in Selection.assetGUIDs)
            {
                var path = AssetDatabase.GUIDToAssetPath(guid);
                if (string.IsNullOrEmpty(path)) continue;
                if (!IsSpritePath(path)) continue;
                var ti = AssetImporter.GetAtPath(path) as TextureImporter;
                if (ti == null) continue;
                ApplyDefaults(ti);
                AssetDatabase.ImportAsset(path, ImportAssetOptions.ForceUpdate);
                count++;
            }
            Debug.Log($"[SpriteImportDefaults] Applied to {count} asset(s).");
        }

        [MenuItem("Assets/Sprites/Apply Defaults To Folder (recursive)", true)]
        static bool ValidateApplyToFolder()
        {
            // Enable when a folder is selected
            return Selection.assetGUIDs.Any(guid =>
            {
                var path = AssetDatabase.GUIDToAssetPath(guid);
                return AssetDatabase.IsValidFolder(path);
            });
        }

        [MenuItem("Assets/Sprites/Apply Defaults To Folder (recursive)")]
        static void ApplyToFolder()
        {
            int total = 0;
            foreach (var guid in Selection.assetGUIDs)
            {
                var folder = AssetDatabase.GUIDToAssetPath(guid);
                if (!AssetDatabase.IsValidFolder(folder)) continue;
                var guids = AssetDatabase.FindAssets("t:Texture2D", new[] { folder });
                foreach (var texGuid in guids)
                {
                    var path = AssetDatabase.GUIDToAssetPath(texGuid);
                    if (!IsSpritePath(path)) continue;
                    var ti = AssetImporter.GetAtPath(path) as TextureImporter;
                    if (ti == null) continue;
                    ApplyDefaults(ti);
                    AssetDatabase.ImportAsset(path, ImportAssetOptions.ForceUpdate);
                    total++;
                }
            }
            Debug.Log($"[SpriteImportDefaults] Applied to {total} asset(s) in folder(s).");
        }
    }
}
#endif

// ===== FILE: Assets/Scripts/Boot/AppBootstrap.cs =====
using System;
using System.Collections;

namespace FantasyColony.Boot
{
    // Minimal bootstrap pipeline. Replace yields with real work as the project grows.
    public static class AppBootstrap
    {
        // setPhase updates the BootScreen subtitle
        public static IEnumerator Run(Action<string> setPhase)
        {
            setPhase?.Invoke("Loading defs…");
            yield return null;

            setPhase?.Invoke("Initializing…");
            yield return null;

            setPhase?.Invoke("Building assets…");
            yield return null;

            setPhase?.Invoke(string.Empty);
        }
    }
}

// ===== FILE: Assets/Scripts/Core/AppBootstrap.cs =====
using UnityEngine;

namespace FantasyColony.Core
{
    /// <summary>
    /// Single entry point. We don't rely on authored Unity scenes; everything is spawned at runtime.
    /// </summary>
    public static class AppBootstrap
    {
        [RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.AfterSceneLoad)]
        private static void Boot()
        {
            // Root host object that survives for the whole app lifetime.
            var root = new GameObject("AppRoot");
            Object.DontDestroyOnLoad(root);
            root.AddComponent<AppHost>();
        }
    }
}

// ===== FILE: Assets/Scripts/Core/AppHost.cs =====
using UnityEngine;
using FantasyColony.UI.Root;
using FantasyColony.UI.Router;
using FantasyColony.Core.Services;
using FantasyColony.UI.Screens;

// Disambiguate our service interfaces from Unity's similarly named types
using FCLogger = FantasyColony.Core.Services.ILogger;
using FCFileLogger = FantasyColony.Core.Services.FileLogger;
using FCConfigService = FantasyColony.Core.Services.IConfigService;
using FCDummyConfig = FantasyColony.Core.Services.DummyConfigService;
using FCEventBus = FantasyColony.Core.Services.IEventBus;
using FCSimpleEventBus = FantasyColony.Core.Services.SimpleEventBus;
using FCAssetProvider = FantasyColony.Core.Services.IAssetProvider;
using FCResourcesProvider = FantasyColony.Core.Services.ResourcesAssetProvider;

namespace FantasyColony.Core
{
    /// <summary>
    /// Lifetime owner. Builds services, creates UIRoot and pushes Main Menu screen.
    /// </summary>
    public class AppHost : MonoBehaviour
    {
        private ServiceRegistry _services;
        private UIRoot _uiRoot;
        private UIRouter _router;

        private void Awake()
        {
            Application.targetFrameRate = 60;
            QualitySettings.vSyncCount = 0;

            _services = new ServiceRegistry();
            _services.Register<FCLogger>(new FCFileLogger());
            _services.Register<FCConfigService>(new FCDummyConfig());
            _services.Register<FCEventBus>(new FCSimpleEventBus());
            _services.Register<FCAssetProvider>(new FCResourcesProvider());

            // Create UI root (Canvas + EventSystem)
            _uiRoot = UIRoot.Create(transform);

            // Router mounts screens under UIRoot
            _router = new UIRouter(_uiRoot.ScreenParent, _services);

            // Show Boot screen first so the UI covers while startup work initializes
            _router.Push<BootScreen>();
        }
    }
}

// ===== FILE: Assets/Scripts/Core/ServiceRegistry.cs =====
using System;
using System.Collections.Generic;

namespace FantasyColony.Core
{
    public sealed class ServiceRegistry
    {
        private readonly Dictionary<Type, object> _map = new();

        public void Register<T>(T impl) where T : class
        {
            _map[typeof(T)] = impl ?? throw new ArgumentNullException(nameof(impl));
        }

        public T Get<T>() where T : class
        {
            if (_map.TryGetValue(typeof(T), out var o) && o is T t)
                return t;
            throw new InvalidOperationException($"Service not registered: {typeof(T).Name}");
        }
    }
}

// ===== FILE: Assets/Scripts/Core/Services/IAssetProvider.cs =====
using UnityEngine;

namespace FantasyColony.Core.Services
{
    public interface IAssetProvider
    {
        Sprite LoadSprite(string virtualPath);
        AudioClip LoadAudio(string virtualPath);
    }

    public sealed class ResourcesAssetProvider : IAssetProvider
    {
        public Sprite LoadSprite(string virtualPath)
        {
            return Resources.Load<Sprite>(virtualPath);
        }

        public AudioClip LoadAudio(string virtualPath)
        {
            return Resources.Load<AudioClip>(virtualPath);
        }
    }
}

// ===== FILE: Assets/Scripts/Core/Services/IConfigService.cs =====
namespace FantasyColony.Core.Services
{
    public interface IConfigService
    {
        string Get(string key, string fallback = "");
        void Set(string key, string value);
        void Save();
    }

    /// <summary>
    /// Minimal no-op config for early boot. Replace later with a JSON-backed service.
    /// </summary>
    public sealed class DummyConfigService : IConfigService
    {
        public string Get(string key, string fallback = "") => fallback;
        public void Set(string key, string value) { }
        public void Save() { }
    }
}

// ===== FILE: Assets/Scripts/Core/Services/IEventBus.cs =====
using System;
using System.Collections.Generic;

namespace FantasyColony.Core.Services
{
    public interface IEventBus
    {
        void Subscribe<T>(Action<T> handler);
        void Unsubscribe<T>(Action<T> handler);
        void Publish<T>(T evt);
    }

    public sealed class SimpleEventBus : IEventBus
    {
        private readonly Dictionary<Type, Delegate> _subs = new();

        public void Subscribe<T>(Action<T> handler)
        {
            if (_subs.TryGetValue(typeof(T), out var d))
                _subs[typeof(T)] = Delegate.Combine(d, handler);
            else
                _subs[typeof(T)] = handler;
        }

        public void Unsubscribe<T>(Action<T> handler)
        {
            if (_subs.TryGetValue(typeof(T), out var d))
            {
                var res = Delegate.Remove(d, handler);
                if (res == null) _subs.Remove(typeof(T));
                else _subs[typeof(T)] = res;
            }
        }

        public void Publish<T>(T evt)
        {
            if (_subs.TryGetValue(typeof(T), out var d) && d is Action<T> a)
            {
                a.Invoke(evt);
            }
        }
    }
}

// ===== FILE: Assets/Scripts/Core/Services/ILogger.cs =====
using System;
using System.IO;
using UnityEngine;

namespace FantasyColony.Core.Services
{
    public interface ILogger
    {
        void Info(string msg);
        void Warn(string msg);
        void Error(string msg, Exception ex = null);
    }

    public sealed class FileLogger : ILogger
    {
        private readonly string _path;

        public FileLogger()
        {
            var dir = Path.Combine(UnityEngine.Application.persistentDataPath, "logs");
            if (!Directory.Exists(dir)) Directory.CreateDirectory(dir);
            _path = Path.Combine(dir, $"log_{DateTime.Now:yyyyMMdd_HHmmss}.txt");
            Info($"FantasyColony boot {UnityEngine.Application.version} Unity {UnityEngine.Application.unityVersion}");
        }

        public void Info(string msg)
        {
            Debug.Log(msg);
            Append("INFO", msg);
        }

        public void Warn(string msg)
        {
            Debug.LogWarning(msg);
            Append("WARN", msg);
        }

        public void Error(string msg, Exception ex = null)
        {
            Debug.LogError(msg);
            if (ex != null) msg += "\n" + ex;
            Append("ERROR", msg);
        }

        private void Append(string level, string msg)
        {
            try
            {
                File.AppendAllText(_path, $"[{DateTime.Now:HH:mm:ss}] {level} {msg}\n");
            }
            catch { /* ignore logging failures */ }
        }
    }
}

// ===== FILE: Assets/Scripts/Dev/DevLogOverlay.cs =====
using System;
using System.Collections.Generic;
using System.Collections.Concurrent;
using System.Text;
using System.Threading;
using UnityEngine;

/// <summary>
/// Lightweight, robust in-game developer log overlay.
/// - Captures all Unity logs via Application.logMessageReceivedThreaded
/// - Thread-safe queue -> main-thread list with ring buffer cap
/// - IMGUI-based so it works without any prefabs/scenes
/// - Filters (Debug/Warning/Errors), Pause, Auto-scroll, Stack Traces
/// - Copy Visible respects current filters
/// </summary>
public class DevLogOverlay : MonoBehaviour
{
    [Serializable]
    public struct LogEntry
    {
        public DateTime time;
        public int frame;
        public int threadId;
        public LogType type;
        public string message;
        public string stackTrace; // may be empty based on policy
        public string contextName; // optional
    }

    private struct QueuedLog
    {
        public DateTime time;
        public int threadId;
        public LogType type;
        public string message;
        public string stackTrace;
        public string contextName;
    }

    private const int DefaultCapacity = 5000;
    private const int WindowPadding = 8;

    private static DevLogOverlay _instance;
    private static readonly object InstanceLock = new object();

    // Threaded producer -> main thread consumer
    private readonly ConcurrentQueue<QueuedLog> _incoming = new ConcurrentQueue<QueuedLog>();
    private readonly List<LogEntry> _entries = new List<LogEntry>(DefaultCapacity + 64);

    [Header("Buffer")]
    [Tooltip("Maximum number of entries kept in memory (oldest are dropped).")]
    public int capacity = DefaultCapacity;

    [Header("Filters")]
    public bool showDebug = true;
    public bool showWarnings = true;
    public bool showErrors = true; // includes Error, Assert, Exception

    [Header("Behavior")]
    public bool paused = false;
    public bool autoScroll = true;
    public bool showStackTraces = false; // toggles display; capture is controlled by Unity's stack trace policy

    private Vector2 _scroll;
    private bool _visible = true;
    private Rect _windowRect;
    private int _dockedCorner = 2; // 0=TL,1=TR,2=BL,3=BR

    private GUIStyle _rowStyle;
    private GUIStyle _rowStyleWarn;
    private GUIStyle _rowStyleError;
    private GUIStyle _tinyLabel;

    private string _search = "";
    private bool _focusSearch;

    // ---------- Public API ----------
    public static void Show()
    {
        EnsureInstance();
        _instance._visible = true;
    }

    public static void Hide()
    {
        if (_instance != null) _instance._visible = false;
    }

    public static void ToggleVisible()
    {
        EnsureInstance();
        _instance._visible = !_instance._visible;
    }

    public static bool IsVisible => _instance != null && _instance._visible;

    public static void Clear()
    {
        if (_instance == null) return;
        _instance._entries.Clear();
    }

    public static IReadOnlyList<LogEntry> Snapshot()
    {
        EnsureInstance();
        return _instance._entries;
    }

    private static void EnsureInstance()
    {
        if (_instance != null) return;
        lock (InstanceLock)
        {
            if (_instance != null) return;
            var go = new GameObject("__DevLogOverlay");
            DontDestroyOnLoad(go);
            _instance = go.AddComponent<DevLogOverlay>();
        }
    }

    // ---------- Unity lifecycle ----------
    private void Awake()
    {
        // Reasonable defaults: errors/exceptions include stacks; others off for perf until toggled
        try
        {
            Application.SetStackTraceLogType(LogType.Log, StackTraceLogType.None);
            Application.SetStackTraceLogType(LogType.Warning, StackTraceLogType.None);
            Application.SetStackTraceLogType(LogType.Error, StackTraceLogType.ScriptOnly);
            Application.SetStackTraceLogType(LogType.Assert, StackTraceLogType.ScriptOnly);
            Application.SetStackTraceLogType(LogType.Exception, StackTraceLogType.ScriptOnly);
        }
        catch { /* Some platforms may not support changing this at runtime */ }

        // Sensible default window size
        var w = Mathf.RoundToInt(Screen.width * 0.6f);
        var h = Mathf.RoundToInt(Screen.height * 0.5f);
        _windowRect = new Rect(WindowPadding, Screen.height - h - WindowPadding, w, h);
    }

    private void OnEnable()
    {
        Application.logMessageReceivedThreaded += OnLogMessageReceivedThreaded;
    }

    private void OnDisable()
    {
        Application.logMessageReceivedThreaded -= OnLogMessageReceivedThreaded;
    }

    private void Update()
    {
        // Drain queue to main-thread list
        while (_incoming.TryDequeue(out var q))
        {
            var e = new LogEntry
            {
                time = q.time,
                frame = Time.frameCount,
                threadId = q.threadId,
                type = q.type,
                message = q.message ?? string.Empty,
                stackTrace = q.stackTrace ?? string.Empty,
                contextName = q.contextName ?? string.Empty
            };

            if (!paused)
            {
                _entries.Add(e);
                if (_entries.Count > Mathf.Max(512, capacity))
                {
                    var over = _entries.Count - capacity;
                    _entries.RemoveRange(0, over);
                }
            }
        }

        if (Input.GetKeyDown(KeyCode.F9))
        {
            ToggleVisible();
        }

        if (Input.GetKeyDown(KeyCode.F10))
        {
            paused = !paused;
        }
    }

    private void OnGUI()
    {
        if (!_visible) return;

        EnsureStyles();

        // Simple draggable/dockable window
        _windowRect = GUI.Window(GetInstanceID(), _windowRect, DrawWindow, "Developer Log");

        // Keep inside screen
        _windowRect.x = Mathf.Clamp(_windowRect.x, WindowPadding, Screen.width - _windowRect.width - WindowPadding);
        _windowRect.y = Mathf.Clamp(_windowRect.y, WindowPadding, Screen.height - _windowRect.height - WindowPadding);
    }

    private void DrawWindow(int id)
    {
        GUILayout.BeginHorizontal();
        if (GUILayout.Button(paused ? "Resume" : "Pause", GUILayout.Height(24))) paused = !paused;
        if (GUILayout.Button("Clear", GUILayout.Height(24))) _entries.Clear();
        if (GUILayout.Button("Copy Visible", GUILayout.Height(24))) CopyVisibleToClipboard();
        if (GUILayout.Button("Close", GUILayout.Height(24))) _visible = false;
        GUILayout.FlexibleSpace();
        autoScroll = GUILayout.Toggle(autoScroll, "Auto-Scroll", GUILayout.Height(24));
        showStackTraces = GUILayout.Toggle(showStackTraces, "Stack Traces", GUILayout.Height(24));
        GUILayout.EndHorizontal();

        GUILayout.Space(4);

        GUILayout.BeginHorizontal();
        showDebug = GUILayout.Toggle(showDebug, "Debug", GUILayout.Width(80));
        showWarnings = GUILayout.Toggle(showWarnings, "Warning", GUILayout.Width(90));
        showErrors = GUILayout.Toggle(showErrors, "Errors", GUILayout.Width(80));

        GUILayout.Space(10);
        GUILayout.Label("Search:", GUILayout.Width(50));
        GUI.SetNextControlName("DevLogSearch");
        _search = GUILayout.TextField(_search ?? string.Empty, GUILayout.MinWidth(120));
        if (_focusSearch)
        {
            _focusSearch = false;
            GUI.FocusControl("DevLogSearch");
        }
        if (GUILayout.Button("×", GUILayout.Width(26))) { _search = string.Empty; GUI.FocusControl(null); }

        GUILayout.FlexibleSpace();
        if (GUILayout.Button("Dock", GUILayout.Width(60))) CycleDock();
        GUILayout.EndHorizontal();

        GUILayout.Space(4);

        // Header line
        GUILayout.BeginHorizontal();
        GUILayout.Label("Time", _tinyLabel, GUILayout.Width(90));
        GUILayout.Label("F", _tinyLabel, GUILayout.Width(36));
        GUILayout.Label("T", _tinyLabel, GUILayout.Width(28));
        GUILayout.Label("Level", _tinyLabel, GUILayout.Width(60));
        GUILayout.Label("Message", _tinyLabel);
        GUILayout.EndHorizontal();

        // List
        _scroll = GUILayout.BeginScrollView(_scroll, GUI.skin.box);

        var countBefore = _entries.Count;
        for (int i = 0; i < _entries.Count; i++)
        {
            var e = _entries[i];
            if (!PassesFilter(e)) continue;
            if (!PassesSearch(e)) continue;

            var style = StyleFor(e.type);
            GUILayout.BeginHorizontal();
            GUILayout.Label(e.time.ToString("HH:mm:ss.fff"), _tinyLabel, GUILayout.Width(90));
            GUILayout.Label(e.frame.ToString(), _tinyLabel, GUILayout.Width(36));
            GUILayout.Label(e.threadId.ToString(), _tinyLabel, GUILayout.Width(28));
            GUILayout.Label(LevelLabel(e.type), _tinyLabel, GUILayout.Width(60));
            GUILayout.Label(e.message, style);
            GUILayout.EndHorizontal();

            if (showStackTraces && HasStack(e))
            {
                GUILayout.BeginHorizontal();
                GUILayout.Space(90 + 36 + 28 + 60 + 8);
                GUILayout.Label(e.stackTrace, GUI.skin.label);
                GUILayout.EndHorizontal();
            }
        }

        if (autoScroll && Event.current.type == EventType.Repaint)
        {
            _scroll.y = float.MaxValue;
        }

        GUILayout.EndScrollView();

        GUI.DragWindow(new Rect(0, 0, 10000, 20));
    }

    private void EnsureStyles()
    {
        if (_rowStyle == null)
        {
            _rowStyle = new GUIStyle(GUI.skin.label) { wordWrap = true };
            _rowStyleWarn = new GUIStyle(_rowStyle);
            _rowStyleError = new GUIStyle(_rowStyle);

            _tinyLabel = new GUIStyle(GUI.skin.label)
            {
                fontSize = 10,
                alignment = TextAnchor.UpperLeft
            };
        }
    }

    private void CycleDock()
    {
        _dockedCorner = (_dockedCorner + 1) % 4;

        var w = _windowRect.width;
        var h = _windowRect.height;

        switch (_dockedCorner)
        {
            case 0: _windowRect.position = new Vector2(WindowPadding, WindowPadding); break; // TL
            case 1: _windowRect.position = new Vector2(Screen.width - w - WindowPadding, WindowPadding); break; // TR
            case 2: _windowRect.position = new Vector2(WindowPadding, Screen.height - h - WindowPadding); break; // BL
            case 3: _windowRect.position = new Vector2(Screen.width - w - WindowPadding, Screen.height - h - WindowPadding); break; // BR
        }
    }

    private GUIStyle StyleFor(LogType t)
    {
        switch (t)
        {
            case LogType.Warning: return _rowStyleWarn;
            case LogType.Error:
            case LogType.Assert:
            case LogType.Exception: return _rowStyleError;
            default: return _rowStyle;
        }
    }

    private static string LevelLabel(LogType t)
    {
        switch (t)
        {
            case LogType.Warning: return "WARN";
            case LogType.Error: return "ERROR";
            case LogType.Assert: return "ASSERT";
            case LogType.Exception: return "EXC";
            default: return "DEBUG";
        }
    }

    private static bool HasStack(in LogEntry e)
    {
        if (string.IsNullOrEmpty(e.stackTrace)) return false;
        // Many non-error logs have empty stack due to policy; only render if provided
        return true;
    }

    private bool PassesFilter(in LogEntry e)
    {
        switch (e.type)
        {
            case LogType.Warning: return showWarnings;
            case LogType.Error:
            case LogType.Assert:
            case LogType.Exception: return showErrors;
            default: return showDebug;
        }
    }

    private bool PassesSearch(in LogEntry e)
    {
        if (string.IsNullOrEmpty(_search)) return true;
        var s = _search.Trim();
        if (s.Length == 0) return true;
        return (e.message?.IndexOf(s, StringComparison.OrdinalIgnoreCase) ?? -1) >= 0
            || (e.stackTrace?.IndexOf(s, StringComparison.OrdinalIgnoreCase) ?? -1) >= 0
            || (e.contextName?.IndexOf(s, StringComparison.OrdinalIgnoreCase) ?? -1) >= 0;
    }

    private void CopyVisibleToClipboard()
    {
        var sb = new StringBuilder(8192);
        foreach (var e in _entries)
        {
            if (!PassesFilter(e)) continue;
            if (!PassesSearch(e)) continue;

            sb.Append('[').Append(e.time.ToString("HH:mm:ss.fff")).Append("] ");
            sb.Append("F=").Append(e.frame).Append(' ');
            sb.Append("T=").Append(e.threadId).Append(' ');
            sb.Append('[').Append(LevelLabel(e.type)).Append("] ");
            if (!string.IsNullOrEmpty(e.contextName))
            {
                sb.Append('{').Append(e.contextName).Append("} ");
            }
            sb.AppendLine(e.message ?? string.Empty);

            if (showStackTraces && HasStack(e))
            {
                sb.AppendLine(e.stackTrace);
            }
        }

        GUIUtility.systemCopyBuffer = sb.ToString();
    }

    private void OnLogMessageReceivedThreaded(string condition, string stacktrace, LogType type)
    {
        var q = new QueuedLog
        {
            time = DateTime.Now,
            threadId = Thread.CurrentThread.ManagedThreadId,
            type = type,
            message = condition,
            stackTrace = stacktrace,
            contextName = string.Empty
        };
        _incoming.Enqueue(q);
    }
}

// Helper component to make it trivial to wire a UI Button to the overlay
// Attach to your "Log" Button (UnityEngine.UI.Button). It will toggle the Dev Log when clicked.
namespace DevTools
{
    using UnityEngine.UI;
    using UnityEngine;

    [RequireComponent(typeof(Button))]
    public class OpenDevLogButton : MonoBehaviour
    {
        public Button button;

        private void Reset()
        {
            if (button == null) button = GetComponent<Button>();
        }

        private void Awake()
        {
            if (button == null) button = GetComponent<Button>();
            if (button != null)
                button.onClick.AddListener(DevLogOverlay.ToggleVisible);
        }
    }
}

// Optional convenience for code callers (e.g., MainMenuScreen) without adding compile-time dependency on UnityEngine.UI
public static class DevLog
{
    public static void Show() => DevLogOverlay.Show();
    public static void Hide() => DevLogOverlay.Hide();
    public static void Toggle() => DevLogOverlay.ToggleVisible();
    public static void Clear() => DevLogOverlay.Clear();
}




// ===== FILE: Assets/Scripts/Dev/OpenDevLogButton.cs =====
using UnityEngine;
using UnityEngine.UI;

/// <summary>
/// Attach this to the Main Menu "Log" button to open/close the Dev Log overlay.
/// Keeps scene/prefab changes minimal and avoids coupling to MainMenuScreen implementation.
/// </summary>
[RequireComponent(typeof(Button))]
public class OpenDevLogButton : MonoBehaviour
{
    [Tooltip("Button that will toggle the Dev Log overlay. If left empty, this component will use the Button on the same GameObject.")]
    public Button button;

    [Tooltip("If true, the overlay will open (Show) instead of toggling when clicked.")]
    public bool openOnly = false;

    private void Reset()
    {
        if (button == null) button = GetComponent<Button>();
    }

    private void Awake()
    {
        if (button == null) button = GetComponent<Button>();
        if (button != null)
        {
            button.onClick.AddListener(OnClick);
        }
    }

    private void OnDestroy()
    {
        if (button != null)
            button.onClick.RemoveListener(OnClick);
    }

    private void OnClick()
    {
        if (openOnly) DevLogOverlay.Show(); else DevLogOverlay.ToggleVisible();
    }
}

// ===== FILE: Assets/Scripts/UI/Root/UIRoot.cs =====
using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.UI;
#if ENABLE_INPUT_SYSTEM
// Only available when the new Input System package/define is enabled
using UnityEngine.InputSystem.UI;
#endif

namespace FantasyColony.UI.Root
{
    public sealed class UIRoot : MonoBehaviour
    {
        public RectTransform ScreenParent { get; private set; }

        public static UIRoot Create(Transform parent)
        {
            var go = new GameObject("UIRoot");
            go.transform.SetParent(parent, false);
            var root = go.AddComponent<UIRoot>();
            root.Build();
            return root;
        }

        private void Build()
        {
            // Canvas
            var canvasGO = new GameObject("Canvas");
            canvasGO.transform.SetParent(transform, false);
            var canvas = canvasGO.AddComponent<Canvas>();
            canvas.renderMode = RenderMode.ScreenSpaceOverlay;
            canvasGO.AddComponent<GraphicRaycaster>();

            var scaler = canvasGO.AddComponent<CanvasScaler>();
            scaler.uiScaleMode = CanvasScaler.ScaleMode.ScaleWithScreenSize;
            scaler.referenceResolution = new Vector2(1920, 1080);
            scaler.matchWidthOrHeight = 0.5f;

            // EventSystem if missing
            bool hasEventSystem = EventSystem.current != null;
#if UNITY_2023_1_OR_NEWER
            if (!hasEventSystem)
                hasEventSystem = (Object.FindFirstObjectByType<EventSystem>() != null);
#else
            if (!hasEventSystem)
                hasEventSystem = (FindObjectOfType<EventSystem>() != null);
#endif
            if (!hasEventSystem)
            {
                // Create EventSystem and attach the correct UI input module
                var es = new GameObject("EventSystem");
                es.AddComponent<EventSystem>();
#if ENABLE_INPUT_SYSTEM
                if (es.GetComponent<InputSystemUIInputModule>() == null)
                {
                    es.AddComponent<InputSystemUIInputModule>();
                }
#else
                if (es.GetComponent<StandaloneInputModule>() == null)
                {
                    es.AddComponent<StandaloneInputModule>();
                }
#endif
            }

            // Screen parent
            var screenParentGO = new GameObject("Screens");
            screenParentGO.transform.SetParent(canvasGO.transform, false);
            ScreenParent = screenParentGO.AddComponent<RectTransform>();
            ScreenParent.anchorMin = Vector2.zero;
            ScreenParent.anchorMax = Vector2.one;
            ScreenParent.offsetMin = Vector2.zero;
            ScreenParent.offsetMax = Vector2.zero;
        }
    }
}

// ===== FILE: Assets/Scripts/UI/Router/IScreen.cs =====
using UnityEngine;

namespace FantasyColony.UI.Router
{
    public interface IScreen
    {
        void Enter(Transform parent);
        void Exit();
    }

    public abstract class UIScreenBase : IScreen
    {
        protected RectTransform Root;
        public abstract void Enter(Transform parent);
        public abstract void Exit();
    }
}

// ===== FILE: Assets/Scripts/UI/Router/UIRouter.cs =====
using System;
using System.Collections.Generic;
using UnityEngine;
using FantasyColony.Core;

namespace FantasyColony.UI.Router
{
    public sealed class UIRouter
    {
        private readonly Transform _parent;
        private readonly ServiceRegistry _services;
        private readonly Stack<IScreen> _stack = new();

        // Global access to the active router (set in ctor)
        public static UIRouter Current { get; private set; }

        public UIRouter(Transform parent, ServiceRegistry services)
        {
            _parent = parent;
            _services = services;
            Current = this;
        }

        public void Push<T>() where T : IScreen, new()
        {
            var screen = new T();
            screen.Enter(_parent);
            _stack.Push(screen);
        }

        // Allow initializing a screen (e.g., dialogs) before entering
        public void Push<T>(Action<T> init) where T : IScreen, new()
        {
            var screen = new T();
            init?.Invoke(screen);
            Push(screen);
        }

        // Push an existing instance
        public void Push(IScreen screen)
        {
            screen.Enter(_parent);
            _stack.Push(screen);
        }

        public void Pop()
        {
            if (_stack.Count == 0) return;
            var top = _stack.Pop();
            top.Exit();
        }

        // --- Restart helpers ---
        public void PopAll()
        {
            while (_stack.Count > 0) Pop();
        }

        public void ResetTo<T>() where T : IScreen, new()
        {
            PopAll();
            Push<T>();
        }
    }
}

// ===== FILE: Assets/Scripts/UI/Screens/BootScreen.cs =====
using System;
using System.Collections;
using UnityEngine;
using UnityEngine.UI;
using FantasyColony.UI.Router;
using FantasyColony.Boot;

namespace FantasyColony.UI.Screens
{
    // Boot screen: shows a cover and phase text while the app boot pipeline runs
    public class BootScreen : IScreen
    {
        public string Title = "Loading";
        public GameObject Root { get; private set; }
        private Text _phaseText;

        public void Enter(Transform parent)
        {
            Root = new GameObject("BootScreen");
            var rt = Root.AddComponent<RectTransform>();
            rt.SetParent(parent, false);
            rt.anchorMin = Vector2.zero; rt.anchorMax = Vector2.one;
            rt.offsetMin = Vector2.zero; rt.offsetMax = Vector2.zero;

            // Solid dark cover (prevents flash)
            var bg = new GameObject("Background");
            var bgrt = bg.AddComponent<RectTransform>();
            bgrt.SetParent(rt, false);
            bgrt.anchorMin = Vector2.zero; bgrt.anchorMax = Vector2.one;
            bgrt.offsetMin = Vector2.zero; bgrt.offsetMax = Vector2.zero;
            var bgImg = bg.AddComponent<Image>();
            bgImg.color = new Color(0.10f, 0.09f, 0.08f, 1f);
            bgImg.raycastTarget = true;

            // Centered title
            var titleGO = new GameObject("Title");
            var tr = titleGO.AddComponent<RectTransform>();
            tr.SetParent(rt, false);
            tr.anchorMin = tr.anchorMax = new Vector2(0.5f, 0.5f);
            tr.anchoredPosition = new Vector2(0f, 24f);
            tr.sizeDelta = new Vector2(640f, 80f);
            var text = titleGO.AddComponent<Text>();
            text.font = Resources.GetBuiltinResource<Font>("Arial.ttf");
            text.fontSize = 24; text.alignment = TextAnchor.MiddleCenter;
            text.color = Color.white;
            text.horizontalOverflow = HorizontalWrapMode.Overflow;
            text.verticalOverflow = VerticalWrapMode.Truncate;
            text.text = string.IsNullOrEmpty(Title) ? "Loading" : Title;

            // Phase text (small subtitle)
            var phaseGO = new GameObject("Phase");
            var pr = phaseGO.AddComponent<RectTransform>();
            pr.SetParent(rt, false);
            pr.anchorMin = pr.anchorMax = new Vector2(0.5f, 0.5f);
            pr.anchoredPosition = new Vector2(0f, -16f);
            pr.sizeDelta = new Vector2(720f, 40f);
            _phaseText = phaseGO.AddComponent<Text>();
            _phaseText.font = text.font;
            _phaseText.fontSize = 18; _phaseText.alignment = TextAnchor.MiddleCenter;
            _phaseText.color = new Color(0.92f, 0.92f, 0.92f, 0.95f);
            _phaseText.horizontalOverflow = HorizontalWrapMode.Overflow;
            _phaseText.verticalOverflow = VerticalWrapMode.Truncate;
            _phaseText.text = string.Empty;

            // Kick off the boot pipeline on the next frame
            var runner = Root.AddComponent<Runner>();
            runner.Begin(() => runner.StartCoroutine(BootCo()));
        }

        public void Exit()
        {
            if (Root != null)
            {
                UnityEngine.Object.Destroy(Root);
                Root = null;
            }
        }

        private IEnumerator BootCo()
        {
            yield return null; // render once so the cover is visible
            yield return AppBootstrap.Run(SetPhase);
            Time.timeScale = 1f;
            UIRouter.Current?.ResetTo<MainMenuScreen>();
        }

        private void SetPhase(string s)
        {
            if (_phaseText != null) _phaseText.text = s ?? string.Empty;
        }

        private class Runner : MonoBehaviour
        {
            public void Begin(Action onReady) { onReady?.Invoke(); }
        }
    }
}

// ===== FILE: Assets/Scripts/UI/Screens/ConfirmDialogScreen.cs =====
using System;
using UnityEngine;
using UnityEngine.UI;
using FantasyColony.UI.Router;
using FantasyColony.UI.Widgets;

namespace FantasyColony.UI.Screens
{
    // Simple reusable confirmation dialog with a dimming overlay
    public class ConfirmDialogScreen : IScreen
    {
        // Configure via UIRouter.Current.Push<ConfirmDialogScreen>(init => { ... })
        public string Title;
        public string Message;
        public string ConfirmLabel = "OK";
        public string CancelLabel = "Cancel";
        public Action OnConfirm;
        public Action OnCancel;

        public GameObject Root { get; private set; }

        public void Enter(Transform parent)
        {
            Root = new GameObject("ConfirmDialog");
            var rt = Root.AddComponent<RectTransform>();
            rt.SetParent(parent, false);
            rt.anchorMin = Vector2.zero; rt.anchorMax = Vector2.one;
            rt.offsetMin = Vector2.zero; rt.offsetMax = Vector2.zero;

            // Dimmer to block clicks and darken background
            var dim = new GameObject("Dimmer");
            var dimRt = dim.AddComponent<RectTransform>();
            dimRt.SetParent(rt, false);
            dimRt.anchorMin = Vector2.zero; dimRt.anchorMax = Vector2.one;
            dimRt.offsetMin = Vector2.zero; dimRt.offsetMax = Vector2.zero;
            var dimImg = dim.AddComponent<Image>();
            dimImg.color = new Color(0f, 0f, 0f, 0.55f);
            dimImg.raycastTarget = true;

            // Dialog panel
            var panel = new GameObject("Panel");
            var prt = panel.AddComponent<RectTransform>();
            prt.SetParent(rt, false);
            prt.sizeDelta = new Vector2(520, 280);
            prt.anchorMin = prt.anchorMax = new Vector2(0.5f, 0.5f);
            prt.anchoredPosition = Vector2.zero;
            var panelImg = panel.AddComponent<Image>();
            panelImg.color = new Color(0.231f, 0.200f, 0.161f); // matches SecondaryFill-ish

            var layout = panel.AddComponent<VerticalLayoutGroup>();
            layout.childAlignment = TextAnchor.UpperCenter;
            layout.childControlHeight = true; layout.childControlWidth = true;
            layout.childForceExpandHeight = false; layout.childForceExpandWidth = false;
            layout.padding = new RectOffset(24, 24, 24, 24);
            layout.spacing = 12;

            // Title
            var titleGO = new GameObject("Title");
            titleGO.transform.SetParent(panel.transform, false);
            var titleText = titleGO.AddComponent<Text>();
            titleText.font = Resources.GetBuiltinResource<Font>("Arial.ttf");
            titleText.fontSize = 26; titleText.alignment = TextAnchor.MiddleCenter;
            titleText.color = Color.white;
            titleText.horizontalOverflow = HorizontalWrapMode.Wrap;
            titleText.verticalOverflow = VerticalWrapMode.Truncate;
            titleText.text = string.IsNullOrEmpty(Title) ? "Confirm" : Title;

            // Message
            var msgGO = new GameObject("Message");
            msgGO.transform.SetParent(panel.transform, false);
            var msgText = msgGO.AddComponent<Text>();
            msgText.font = titleText.font;
            msgText.fontSize = 16; msgText.alignment = TextAnchor.MiddleCenter;
            msgText.color = new Color(0.9f, 0.9f, 0.9f, 0.95f);
            msgText.horizontalOverflow = HorizontalWrapMode.Wrap;
            msgText.verticalOverflow = VerticalWrapMode.Overflow;
            msgText.text = string.IsNullOrEmpty(Message) ? string.Empty : Message;

            // Buttons row
            var row = new GameObject("Buttons");
            row.transform.SetParent(panel.transform, false);
            var rowLayout = row.AddComponent<HorizontalLayoutGroup>();
            rowLayout.childAlignment = TextAnchor.MiddleCenter;
            rowLayout.spacing = 16;
            rowLayout.childForceExpandWidth = false;
            rowLayout.childForceExpandHeight = false;
            rowLayout.padding = new RectOffset(0, 0, 8, 0);

            // Cancel / Confirm buttons using UIFactory
            UIFactory.CreateButtonSecondary(row.transform, string.IsNullOrEmpty(CancelLabel) ? "Cancel" : CancelLabel, () =>
            {
                UIRouter.Current?.Pop();
                OnCancel?.Invoke();
            });

            UIFactory.CreateButtonDanger(row.transform, string.IsNullOrEmpty(ConfirmLabel) ? "OK" : ConfirmLabel, () =>
            {
                var router = UIRouter.Current;
                router?.Pop(); // close dialog first so new screens appear above
                OnConfirm?.Invoke();
            });
        }

        public void Exit()
        {
            if (Root != null)
            {
                UnityEngine.Object.Destroy(Root);
                Root = null;
            }
        }
    }
}

// ===== FILE: Assets/Scripts/UI/Screens/MainMenuScreen.cs =====
using UnityEngine;
using UnityEngine.UI;
// using DevTools; // not required; DevLogOverlay is in the global namespace
using System;
using FantasyColony.UI.Router;
using FantasyColony.UI.Widgets;
using FantasyColony.UI.Style;
using FantasyColony.Core.Services;
using UnityObject = UnityEngine.Object;
using FantasyColony.Boot;

namespace FantasyColony.UI.Screens
{
    /// <summary>
    /// Main Menu (non-functional for now). Uses Base UI Style, bottom-right vertical stack.
    /// Order: Log, Start, Continue, Load, Options, Mods, Creator, Restart, Quit
    /// </summary>
    public sealed class MainMenuScreen : UIScreenBase
    {
        public override void Enter(Transform parent)
        {
            // Root
            var go = new GameObject("MainMenu", typeof(RectTransform));
            Root = go.GetComponent<RectTransform>();
            Root.SetParent(parent, false);
            Root.anchorMin = Vector2.zero;
            Root.anchorMax = Vector2.one;
            Root.offsetMin = Vector2.zero;
            Root.offsetMax = Vector2.zero;

            // Background (image if present, else solid)
            var bgSprite = Resources.Load<Sprite>("ui/menu/main_menu_bg");
            UIFactory.CreateFullscreenBackground(Root, bgSprite, new Color32(18, 15, 12, 255));

            // Panel stack (bottom-right)
            var panel = UIFactory.CreateBottomRightStack(Root, "MenuPanel");
            // Make panel background transparent (no shadow panel), keep layout behavior
            var panelImg = panel.GetComponent<Image>();
            if (panelImg)
            {
                panelImg.color = new Color(0,0,0,0);
                panelImg.raycastTarget = false; // do not block button mouse events
            }
            panel.SetAsLastSibling();

            // Buttons (log "Not implemented")
            void NotImpl(string name) => Debug.Log($"BUTTON: {name} (not implemented)");

            UIFactory.CreateButtonSecondary(panel, "Log",        DevLogOverlay.Show);
            UIFactory.CreateButtonPrimary(panel,   "Start",      () => NotImpl("Start"));
            var btnContinue = UIFactory.CreateButtonSecondary(panel, "Continue", () => NotImpl("Continue"));
            var btnLoad     = UIFactory.CreateButtonSecondary(panel, "Load",     () => NotImpl("Load"));
            UIFactory.CreateButtonSecondary(panel, "Options",    () => NotImpl("Options"));
            UIFactory.CreateButtonSecondary(panel, "Mods",       () => NotImpl("Mods"));
            UIFactory.CreateButtonSecondary(panel, "Creator",    () => NotImpl("Creator"));
            UIFactory.CreateButtonSecondary(panel, "Restart",    ShowRestartConfirm);
            UIFactory.CreateButtonDanger(panel,     "Quit",      ShowQuitConfirm);

            // Disabled rules for now (no save system yet)
            btnContinue.interactable = false;
            btnLoad.interactable = false;
        }

        public override void Exit()
        {
            if (Root != null)
            {
                UnityObject.Destroy(Root.gameObject);
                Root = null;
            }
        }

        private void ShowRestartConfirm()
        {
            UIRouter.Current?.Push<ConfirmDialogScreen>(d =>
            {
                d.Title = "Restart Game?";
                d.Message = "This will restart the application flow.";
                d.ConfirmLabel = "Restart";
                d.CancelLabel = "Cancel";
                d.OnConfirm = () =>
                {
                    UIRouter.Current?.Push<BootScreen>(b => { b.Title = "Loading"; });
                };
            });
        }

        private void ShowQuitConfirm()
        {
            UIRouter.Current?.Push<ConfirmDialogScreen>(d =>
            {
                d.Title = "Quit Game?";
                d.Message = "Are you sure you want to exit?";
                d.ConfirmLabel = "Quit";
                d.CancelLabel = "Cancel";
                d.OnConfirm = QuitGame;
            });
        }

        private void RestartGame()
        {
            // (Old direct restart path retained for reference; unused now)
            Time.timeScale = 1f;
            UIRouter.Current?.ResetTo<MainMenuScreen>();
            Resources.UnloadUnusedAssets();
            System.GC.Collect();
        }

        private void QuitGame()
        {
        #if UNITY_EDITOR
            UnityEditor.EditorApplication.ExitPlaymode();
        #else
            Application.Quit();
        #endif
        }
    }
}

// ===== FILE: Assets/Scripts/UI/Style/BaseUIStyle.cs =====
using UnityEngine;

namespace FantasyColony.UI.Style
{
    public static class BaseUIStyle
    {
        // Colors
        public static Color32 Gold            = Hex("#D6B25E");
        public static Color32 GoldHover       = Hex("#E4C77D");
        public static Color32 GoldPressed     = Hex("#B99443");
        public static Color32 PanelSurface    = new Color32(0x1F,0x1A,0x14, (byte)(0.95f * 255));
        // Secondary (dark) fill used for standard buttons - BRIGHTENED for better visibility on dark backgrounds
        // Old values kept in comments for reference
        // Previous: #3B3329 (0.231, 0.200, 0.161)
        public static Color32 SecondaryFill   = Hex("#5E5345"); // #5E5345
        // Secondary (dark) explicit states for visible hover/press
        // Hover: noticeably lighter than base; Pressed: slightly darker than new base
        public static Color32 SecondaryHover  = Hex("#726555"); // #726555
        public static Color32 SecondaryPressed= Hex("#4A4033"); // Slightly darker than new base
        public static Color32 Keyline         = new Color32(0x5A,0x4C,0x38, (byte)(0.60f * 255));
        public static Color32 TextPrimary     = Hex("#F1E9D2");
        public static Color32 TextSecondary   = Hex("#C9BDA2");
        public static Color32 Danger          = Hex("#B34844");
        public static Color32 DangerHover     = Hex("#C8625E");
        public static Color32 DangerPressed   = Hex("#953A37");

        // Sizes
        public const int ButtonHeight = 56;
        public const int ButtonFontSize = 24;
        public const int BodyFontSize = 20;
        public const int CaptionFontSize = 18;
        public const int PanelPadding = 24;
        public const int StackSpacing = 12;
        public const int EdgeOffset = 56;

        public static Color32 Hex(string hex)
        {
            if (ColorUtility.TryParseHtmlString(hex, out var c))
                return c;
            return Color.white;
        }
    }
}

// ===== FILE: Assets/Scripts/UI/Widgets/UIFactory.cs =====
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.EventSystems;
using FantasyColony.UI.Style;
using System;

namespace FantasyColony.UI.Widgets
{
    public static class UIFactory
    {
        // PANEL
        public static RectTransform CreatePanelSurface(Transform parent, string name = "Panel")
        {
            var go = new GameObject(name, typeof(RectTransform), typeof(CanvasRenderer), typeof(Image), typeof(VerticalLayoutGroup), typeof(ContentSizeFitter));
            go.transform.SetParent(parent, false);
            var rt = go.GetComponent<RectTransform>();
            var img = go.GetComponent<Image>();
            img.color = BaseUIStyle.PanelSurface;

            var layout = go.GetComponent<VerticalLayoutGroup>();
            layout.spacing = BaseUIStyle.StackSpacing;
            layout.padding = new RectOffset(BaseUIStyle.PanelPadding, BaseUIStyle.PanelPadding, BaseUIStyle.PanelPadding, BaseUIStyle.PanelPadding);
            // Ensure children (buttons) get proper space and panel wraps to content reliably
            layout.childControlWidth = true;
            layout.childControlHeight = true;
            layout.childForceExpandWidth = false;
            layout.childForceExpandHeight = false;

            var fitter = go.GetComponent<ContentSizeFitter>();
            fitter.horizontalFit = ContentSizeFitter.FitMode.PreferredSize;
            fitter.verticalFit = ContentSizeFitter.FitMode.PreferredSize;
            return rt;
        }

        // BUTTONS
        public static Button CreateButtonPrimary(Transform parent, string label, Action onClick) =>
            CreateButton(parent, label, BaseUIStyle.Gold, BaseUIStyle.TextSecondary, onClick);

        public static Button CreateButtonSecondary(Transform parent, string label, Action onClick) =>
            CreateButton(parent, label, BaseUIStyle.SecondaryFill, BaseUIStyle.TextPrimary, onClick);

        public static Button CreateButtonDanger(Transform parent, string label, Action onClick) =>
            CreateButton(parent, label, BaseUIStyle.Danger, BaseUIStyle.TextSecondary, onClick, isDanger:true);

        private static Button CreateButton(Transform parent, string label, Color fill, Color textColor, Action onClick, bool isDanger = false)
        {
            var go = new GameObject($"Button_{label}", typeof(RectTransform), typeof(CanvasRenderer), typeof(Image), typeof(Button), typeof(LayoutElement));
            go.transform.SetParent(parent, false);
            var rt = go.GetComponent<RectTransform>();
            rt.sizeDelta = new Vector2(380, BaseUIStyle.ButtonHeight);

            var img = go.GetComponent<Image>();
            img.color = fill;

            var btn = go.GetComponent<Button>();
            btn.transition = Selectable.Transition.ColorTint;
            btn.targetGraphic = img;
            var colors = btn.colors;
            colors.normalColor = fill;

            // Use explicit palette values to guarantee visible state changes for known fills
            if (isDanger)
            {
                colors.highlightedColor = BaseUIStyle.DangerHover;
                colors.pressedColor = BaseUIStyle.DangerPressed;
            }
            else if (fill == BaseUIStyle.Gold)
            {
                colors.highlightedColor = BaseUIStyle.GoldHover;
                colors.pressedColor = BaseUIStyle.GoldPressed;
            }
            else if (fill == BaseUIStyle.SecondaryFill)
            {
                colors.highlightedColor = BaseUIStyle.SecondaryHover;
                colors.pressedColor = BaseUIStyle.SecondaryPressed;
            }
            else
            {
                colors.highlightedColor = Multiply(fill, 1.15f);
                colors.pressedColor = Multiply(fill, 0.80f);
            }

            // Ensure selected state does not appear "stuck pressed" after click
            colors.selectedColor = colors.normalColor;
            colors.disabledColor = new Color(fill.r, fill.g, fill.b, 0.35f);
            colors.colorMultiplier = 1f;
            colors.fadeDuration = 0.08f;
            btn.colors = colors;
            btn.onClick.AddListener(() => onClick?.Invoke());

            // Layout sizing so buttons are visible in the stack
            var le = go.GetComponent<LayoutElement>();
            le.preferredWidth = 420;
            le.minHeight = BaseUIStyle.ButtonHeight;
            le.flexibleWidth = 0; le.flexibleHeight = 0;

            // Label
            var textGO = new GameObject("Label", typeof(RectTransform), typeof(CanvasRenderer), typeof(Text));
            textGO.transform.SetParent(go.transform, false);
            var trt = textGO.GetComponent<RectTransform>();
            trt.anchorMin = new Vector2(0, 0);
            trt.anchorMax = new Vector2(1, 1);
            trt.offsetMin = new Vector2(16, 0);
            trt.offsetMax = new Vector2(-16, 0);

            var txt = textGO.GetComponent<Text>();
            txt.text = label;
            txt.alignment = TextAnchor.MiddleLeft;
            txt.fontSize = BaseUIStyle.ButtonFontSize;
            txt.color = textColor;
            // Use default Arial to avoid TMP dependency; can swap later.
            txt.font = Resources.GetBuiltinResource<Font>("Arial.ttf");

            return btn;
        }

        // STACK CONTAINER (Bottom-right MenuPanel)
        public static RectTransform CreateBottomRightStack(Transform parent, string name = "MenuPanel")
        {
            var panel = CreatePanelSurface(parent, name);
            panel.anchorMin = new Vector2(1, 0);
            panel.anchorMax = new Vector2(1, 0);
            panel.pivot = new Vector2(1, 0);
            panel.anchoredPosition = new Vector2(-BaseUIStyle.EdgeOffset, BaseUIStyle.EdgeOffset);

            var layout = panel.GetComponent<VerticalLayoutGroup>();
            layout.childAlignment = TextAnchor.UpperCenter;

            var le = panel.GetComponent<LayoutElement>();
            if (le == null) le = panel.gameObject.AddComponent<LayoutElement>();
            le.preferredWidth = 420;
            le.flexibleWidth = 0;
            return panel;
        }

        // BACKGROUND IMAGE (full screen)
        public static Image CreateFullscreenBackground(Transform parent, Sprite sprite, Color fallbackColor)
        {
            var go = new GameObject("Background", typeof(RectTransform), typeof(CanvasRenderer), typeof(Image));
            go.transform.SetParent(parent, false);
            var rt = go.GetComponent<RectTransform>();
            rt.anchorMin = Vector2.zero;
            rt.anchorMax = Vector2.one;
            rt.offsetMin = Vector2.zero;
            rt.offsetMax = Vector2.zero;
            var img = go.GetComponent<Image>();
            if (sprite != null)
            {
                img.sprite = sprite;
                img.preserveAspect = true; // Background should not intercept clicks
                img.color = Color.white;
            }
            else
            {
                img.color = fallbackColor;
            }
            img.raycastTarget = false; // never block UI
            return img;
        }

        private static Color Multiply(Color c, float f) => new Color(c.r * f, c.g * f, c.b * f, c.a);

        private static void ClearSelectionIfMouseClick()
        {
            var es = EventSystem.current;
            if (es != null && Input.mousePresent)
            {
                es.SetSelectedGameObject(null);
            }
        }
    }
}

// ===== FILE: Assets/TutorialInfo/Scripts/Editor/ReadmeEditor.cs =====
﻿using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEditor;
using System;
using System.IO;
using System.Reflection;

[CustomEditor(typeof(Readme))]
[InitializeOnLoad]
public class ReadmeEditor : Editor
{
    static string s_ShowedReadmeSessionStateName = "ReadmeEditor.showedReadme";
    
    static string s_ReadmeSourceDirectory = "Assets/TutorialInfo";

    const float k_Space = 16f;

    static ReadmeEditor()
    {
        EditorApplication.delayCall += SelectReadmeAutomatically;
    }

    static void RemoveTutorial()
    {
        if (EditorUtility.DisplayDialog("Remove Readme Assets",
            
            $"All contents under {s_ReadmeSourceDirectory} will be removed, are you sure you want to proceed?",
            "Proceed",
            "Cancel"))
        {
            if (Directory.Exists(s_ReadmeSourceDirectory))
            {
                FileUtil.DeleteFileOrDirectory(s_ReadmeSourceDirectory);
                FileUtil.DeleteFileOrDirectory(s_ReadmeSourceDirectory + ".meta");
            }
            else
            {
                Debug.Log($"Could not find the Readme folder at {s_ReadmeSourceDirectory}");
            }

            var readmeAsset = SelectReadme();
            if (readmeAsset != null)
            {
                var path = AssetDatabase.GetAssetPath(readmeAsset);
                FileUtil.DeleteFileOrDirectory(path + ".meta");
                FileUtil.DeleteFileOrDirectory(path);
            }

            AssetDatabase.Refresh();
        }
    }

    static void SelectReadmeAutomatically()
    {
        if (!SessionState.GetBool(s_ShowedReadmeSessionStateName, false))
        {
            var readme = SelectReadme();
            SessionState.SetBool(s_ShowedReadmeSessionStateName, true);

            if (readme && !readme.loadedLayout)
            {
                LoadLayout();
                readme.loadedLayout = true;
            }
        }
    }

    static void LoadLayout()
    {
        var assembly = typeof(EditorApplication).Assembly;
        var windowLayoutType = assembly.GetType("UnityEditor.WindowLayout", true);
        var method = windowLayoutType.GetMethod("LoadWindowLayout", BindingFlags.Public | BindingFlags.Static);
        method.Invoke(null, new object[] { Path.Combine(Application.dataPath, "TutorialInfo/Layout.wlt"), false });
    }

    static Readme SelectReadme()
    {
        var ids = AssetDatabase.FindAssets("Readme t:Readme");
        if (ids.Length == 1)
        {
            var readmeObject = AssetDatabase.LoadMainAssetAtPath(AssetDatabase.GUIDToAssetPath(ids[0]));

            Selection.objects = new UnityEngine.Object[] { readmeObject };

            return (Readme)readmeObject;
        }
        else
        {
            Debug.Log("Couldn't find a readme");
            return null;
        }
    }

    protected override void OnHeaderGUI()
    {
        var readme = (Readme)target;
        Init();

        var iconWidth = Mathf.Min(EditorGUIUtility.currentViewWidth / 3f - 20f, 128f);

        GUILayout.BeginHorizontal("In BigTitle");
        {
            if (readme.icon != null)
            {
                GUILayout.Space(k_Space);
                GUILayout.Label(readme.icon, GUILayout.Width(iconWidth), GUILayout.Height(iconWidth));
            }
            GUILayout.Space(k_Space);
            GUILayout.BeginVertical();
            {

                GUILayout.FlexibleSpace();
                GUILayout.Label(readme.title, TitleStyle);
                GUILayout.FlexibleSpace();
            }
            GUILayout.EndVertical();
            GUILayout.FlexibleSpace();
        }
        GUILayout.EndHorizontal();
    }

    public override void OnInspectorGUI()
    {
        var readme = (Readme)target;
        Init();

        foreach (var section in readme.sections)
        {
            if (!string.IsNullOrEmpty(section.heading))
            {
                GUILayout.Label(section.heading, HeadingStyle);
            }

            if (!string.IsNullOrEmpty(section.text))
            {
                GUILayout.Label(section.text, BodyStyle);
            }

            if (!string.IsNullOrEmpty(section.linkText))
            {
                if (LinkLabel(new GUIContent(section.linkText)))
                {
                    Application.OpenURL(section.url);
                }
            }

            GUILayout.Space(k_Space);
        }

        if (GUILayout.Button("Remove Readme Assets", ButtonStyle))
        {
            RemoveTutorial();
        }
    }

    bool m_Initialized;

    GUIStyle LinkStyle
    {
        get { return m_LinkStyle; }
    }

    [SerializeField]
    GUIStyle m_LinkStyle;

    GUIStyle TitleStyle
    {
        get { return m_TitleStyle; }
    }

    [SerializeField]
    GUIStyle m_TitleStyle;

    GUIStyle HeadingStyle
    {
        get { return m_HeadingStyle; }
    }

    [SerializeField]
    GUIStyle m_HeadingStyle;

    GUIStyle BodyStyle
    {
        get { return m_BodyStyle; }
    }

    [SerializeField]
    GUIStyle m_BodyStyle;

    GUIStyle ButtonStyle
    {
        get { return m_ButtonStyle; }
    }

    [SerializeField]
    GUIStyle m_ButtonStyle;

    void Init()
    {
        if (m_Initialized)
            return;
        m_BodyStyle = new GUIStyle(EditorStyles.label);
        m_BodyStyle.wordWrap = true;
        m_BodyStyle.fontSize = 14;
        m_BodyStyle.richText = true;

        m_TitleStyle = new GUIStyle(m_BodyStyle);
        m_TitleStyle.fontSize = 26;

        m_HeadingStyle = new GUIStyle(m_BodyStyle);
        m_HeadingStyle.fontStyle = FontStyle.Bold;
        m_HeadingStyle.fontSize = 18;

        m_LinkStyle = new GUIStyle(m_BodyStyle);
        m_LinkStyle.wordWrap = false;

        // Match selection color which works nicely for both light and dark skins
        m_LinkStyle.normal.textColor = new Color(0x00 / 255f, 0x78 / 255f, 0xDA / 255f, 1f);
        m_LinkStyle.stretchWidth = false;

        m_ButtonStyle = new GUIStyle(EditorStyles.miniButton);
        m_ButtonStyle.fontStyle = FontStyle.Bold;

        m_Initialized = true;
    }

    bool LinkLabel(GUIContent label, params GUILayoutOption[] options)
    {
        var position = GUILayoutUtility.GetRect(label, LinkStyle, options);

        Handles.BeginGUI();
        Handles.color = LinkStyle.normal.textColor;
        Handles.DrawLine(new Vector3(position.xMin, position.yMax), new Vector3(position.xMax, position.yMax));
        Handles.color = Color.white;
        Handles.EndGUI();

        EditorGUIUtility.AddCursorRect(position, MouseCursor.Link);

        return GUI.Button(position, label, LinkStyle);
    }
}

// ===== FILE: Assets/TutorialInfo/Scripts/Readme.cs =====
﻿using System;
using UnityEngine;

public class Readme : ScriptableObject
{
    public Texture2D icon;
    public string title;
    public Section[] sections;
    public bool loadedLayout;

    [Serializable]
    public class Section
    {
        public string heading, text, linkText, url;
    }
}

// ===== FILE: Tools/XmlDefsTools/Emit/SchemaCatalogWriter.cs =====
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Xml.Linq;
using XmlDefsTools.Scan;
using XmlDefsTools.Util;

namespace XmlDefsTools.Emit
{
    /// <summary>
    /// Writes a consolidated catalog file listing all schemas,
    /// their union of attributes and elements, and a canonical template
    /// sample for each schema.
    /// </summary>
    public static class SchemaCatalogWriter
    {
        public static void Write(string outputDir, ScanResult scan,
            IReadOnlyDictionary<string, IList<string>> orderHints)
        {
            Directory.CreateDirectory(outputDir);
            var outPath = Path.Combine(outputDir, "_AllSchemas.xml");

            var configuredSchemas = orderHints.Keys
                .Where(k => !string.Equals(k, "_common", StringComparison.OrdinalIgnoreCase)
                    && !k.StartsWith("//"))
                .ToHashSet(StringComparer.OrdinalIgnoreCase);
            var allSchemas = new HashSet<string>(scan.Schemas, StringComparer.OrdinalIgnoreCase);
            foreach (var s in configuredSchemas) allSchemas.Add(s);

            var doc = new XDocument(
                new XElement("DefSchemas",
                    new XAttribute("generated",
                        DateTime.UtcNow.ToString("yyyy-MM-ddTHH:mm:ssZ")))
            );

            var common = orderHints.TryGetValue("_common", out var commonOrder)
                ? commonOrder
                : Array.Empty<string>();

            foreach (var schema in allSchemas.OrderBy(s => s, StringComparer.OrdinalIgnoreCase))
            {
                var perSchema = orderHints.TryGetValue(schema, out var per)
                    ? per : Array.Empty<string>();
                var precedence = common.Concat(perSchema).ToList();

                // Collect union of fields from discovered defs
                var attrFields = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
                var elemFields = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
                if (scan.DefsBySchema.TryGetValue(schema, out var defs))
                {
                    foreach (var d in defs)
                    {
                        foreach (var a in d.AttributeFields) attrFields.Add(a);
                        foreach (var e in d.ElementFields) elemFields.Add(e);
                    }
                }

                // Seed with configured fields
                foreach (var hinted in perSchema) elemFields.Add(hinted);

                // Attributes for root + ordered element list
                var rootAttrs = NormalizeOrder(attrFields, precedence,
                    keepOnly: new[] { "id", "schema", "name_key", "tags", "version", "requires" });
                var elementNames = NormalizeOrder(
                    elemFields.Except(rootAttrs, StringComparer.OrdinalIgnoreCase), precedence);

                // Build a canonical template element (same rules as TemplateSynthesizer)
                var root = new XElement(schema);
                foreach (var a in rootAttrs)
                {
                    var placeholder = a.Equals("id", StringComparison.OrdinalIgnoreCase) ? "your_id_here"
                        : a.Equals("name_key", StringComparison.OrdinalIgnoreCase) ? "ui.your.key.here"
                        : a.Equals("tags", StringComparison.OrdinalIgnoreCase) ? string.Empty
                        : a.Equals("version", StringComparison.OrdinalIgnoreCase) ? "1"
                        : string.Empty;
                    root.SetAttributeValue(a, placeholder);
                }

                bool HasElem(string name) =>
                    elementNames.Any(n => n.Equals(name, StringComparison.OrdinalIgnoreCase));
                if (HasElem("version") && root.Attribute("version") == null)
                    root.Add(new XElement("version", "1"));
                if (HasElem("requires") && root.Attribute("requires") == null)
                    root.Add(new XElement("requires"));
                if (HasElem("components") ||
                    perSchema.Contains("components", StringComparer.OrdinalIgnoreCase))
                {
                    root.Add(new XElement("components",
                        new XComment(" Add component entries like <Component type=\"...\"/> ")));
                }
                foreach (var el in elementNames)
                {
                    if (string.Equals(el, "components", StringComparison.OrdinalIgnoreCase))
                        continue;
                    if (string.Equals(el, "version", StringComparison.OrdinalIgnoreCase)
                        && root.Elements("version").Any())
                        continue;
                    if (string.Equals(el, "requires", StringComparison.OrdinalIgnoreCase)
                        && root.Elements("requires").Any())
                        continue;
                    root.Add(new XElement(el));
                }
                var canonicalElement = CanonicalXml.CanonicalizeElement(root);

                // Compose catalog node
                var schemaNode = new XElement("Schema",
                    new XAttribute("name", schema),
                    new XElement("Attributes",
                        rootAttrs.Select(a => new XElement("Attr", new XAttribute("name", a)))),
                    new XElement("Elements",
                        elementNames.Select(e => new XElement("El", new XAttribute("name", e)))),
                    new XElement("Template", canonicalElement));

                doc.Root!.Add(schemaNode);
            }

            doc.Save(outPath);
        }

        private static List<string> NormalizeOrder(IEnumerable<string> names,
            IList<string> precedence, IEnumerable<string>? keepOnly = null)
        {
            var all = new HashSet<string>(names, StringComparer.OrdinalIgnoreCase);
            if (keepOnly != null)
            {
                var keep = new HashSet<string>(keepOnly, StringComparer.OrdinalIgnoreCase);
                all.RemoveWhere(n => !keep.Contains(n));
            }

            var ordered = new List<string>();
            foreach (var p in precedence)
            {
                if (all.Remove(p)) ordered.Add(p);
            }
            ordered.AddRange(all.OrderBy(n => n, StringComparer.OrdinalIgnoreCase));
            return ordered;
        }
    }
}


// ===== FILE: Tools/XmlDefsTools/Emit/TemplateSynthesizer.cs =====
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Xml.Linq;
using XmlDefsTools.Scan;
using XmlDefsTools.Util;

namespace XmlDefsTools.Emit
{
    public static class TemplateSynthesizer
    {
        public static void WriteTemplates(string outputDir, ScanResult scan, IReadOnlyDictionary<string, IList<string>> orderHints)
        {
            Directory.CreateDirectory(outputDir);
            // union of discovered schemas and configured schemas (ensures baseline output)
            var configuredSchemas = orderHints.Keys
                .Where(k => !string.Equals(k, "_common", StringComparison.OrdinalIgnoreCase) && !k.StartsWith("//"))
                .ToHashSet(StringComparer.OrdinalIgnoreCase);
            var allSchemas = new HashSet<string>(scan.Schemas, StringComparer.OrdinalIgnoreCase);
            foreach (var s in configuredSchemas) allSchemas.Add(s);

            foreach (var schema in allSchemas.OrderBy(s => s))
            {
                // if no defs discovered, synthesize from hints only
                var defs = scan.DefsBySchema.ContainsKey(schema)
                    ? scan.DefsBySchema[schema]
                    : new List<DefInfo>();

                // union of observed fields (attributes + elements)
                var attrFields = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
                var elemFields = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
                // include configured per-schema fields as elements to seed structure
                if (orderHints.TryGetValue(schema, out var hinted))
                {
                    foreach (var h in hinted) elemFields.Add(h);
                }
                foreach (var d in defs)
                {
                    foreach (var f in d.AttributeFields) attrFields.Add(f);
                    foreach (var f in d.ElementFields) elemFields.Add(f);
                }

                // known/common order
                var common = orderHints.TryGetValue("_common", out var c) ? c : Array.Empty<string>();
                var perSchema = orderHints.TryGetValue(schema, out var s) ? s : Array.Empty<string>();
                var precedence = common.Concat(perSchema).ToList();

                // Attributes to place on root element
                var rootAttrs = NormalizeOrder(attrFields, precedence, keepOnly: new[] { "id","schema","name_key","tags","version","requires" });
                // Remaining element fields (drop those already in attributes)
                var elementNames = NormalizeOrder(elemFields.Except(rootAttrs, StringComparer.OrdinalIgnoreCase),
                                                  precedence);

                bool HasElem(string name) => elementNames.Any(n => n.Equals(name, StringComparison.OrdinalIgnoreCase));

                var sb = new StringBuilder();
                sb.AppendLine($"<!-- Auto-generated default template for {schema}. Edit your copies; this file is regenerated. -->");

                var root = new XElement(schema);
                // Put attributes with placeholders
                foreach (var a in rootAttrs)
                {
                    var placeholder = a.Equals("id", StringComparison.OrdinalIgnoreCase) ? "your_id_here"
                                   : a.Equals("name_key", StringComparison.OrdinalIgnoreCase) ? "ui.your.key.here"
                                   : a.Equals("tags", StringComparison.OrdinalIgnoreCase) ? ""
                                   : a.Equals("version", StringComparison.OrdinalIgnoreCase) ? "1"
                                   : "";
                    root.SetAttributeValue(a, placeholder);
                }

                // Insert version/requires as elements too if heavily used as elements
                if (HasElem("version") && root.Attribute("version") == null)
                    root.Add(new XElement("version", "1"));
                if (HasElem("requires") && root.Attribute("requires") == null)
                    root.Add(new XElement("requires"));

                // Components block if observed
                if (HasElem("components") || perSchema.Contains("components", StringComparer.OrdinalIgnoreCase))
                {
                    root.Add(new XElement("components",
                        new XComment(" Add component entries like <Component type=\"...\"/> ")));
                }

                // Other fields as empty elements
                foreach (var el in elementNames)
                {
                    if (string.Equals(el, "components", StringComparison.OrdinalIgnoreCase)) continue;
                    if (string.Equals(el, "version", StringComparison.OrdinalIgnoreCase) && root.Elements("version").Any()) continue;
                    if (string.Equals(el, "requires", StringComparison.OrdinalIgnoreCase) && root.Elements("requires").Any()) continue;
                    root.Add(new XElement(el));
                }

                // Canonicalize attribute order
                var canonical = CanonicalXml.CanonicalizeElement(root);
                sb.AppendLine(canonical.ToString(SaveOptions.None));

                var outPath = Path.Combine(outputDir, $"{schema}.xml");
                File.WriteAllText(outPath, sb.ToString());
            }
        }

        private static List<string> NormalizeOrder(IEnumerable<string> names, IList<string> precedence, IEnumerable<string>? keepOnly = null)
        {
            var all = new HashSet<string>(names, StringComparer.OrdinalIgnoreCase);
            if (keepOnly != null)
            {
                var keep = new HashSet<string>(keepOnly, StringComparer.OrdinalIgnoreCase);
                all.RemoveWhere(n => !keep.Contains(n));
            }
            var ordered = new List<string>();
            foreach (var p in precedence)
            {
                if (all.Remove(p)) ordered.Add(p);
            }
            ordered.AddRange(all.OrderBy(n => n, StringComparer.OrdinalIgnoreCase));
            return ordered;
        }
    }
}

// ===== FILE: Tools/XmlDefsTools/Emit/XmlIndexWriter.cs =====
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using XmlDefsTools.Scan;

namespace XmlDefsTools.Emit
{
    public static class XmlIndexWriter
    {
        public static void Write(string repoRoot, string outFile, ScanResult scan)
        {
            var sb = new StringBuilder();
            sb.AppendLine("# XML Index (.xml)");
            sb.AppendLine();
            sb.AppendLine($"_Generated: {DateTime.UtcNow:yyyy-MM-dd HH:mm} UTC_");
            sb.AppendLine();
            sb.AppendLine($"**Total files scanned:** {scan.TotalFiles}  ");
            sb.AppendLine($"**Valid XML files:** {scan.ValidFiles}  ");
            sb.AppendLine($"**Defs discovered:** {scan.TotalDefs}  ");
            sb.AppendLine();

            if (scan.Errors.Any())
            {
                sb.AppendLine("## Parse Errors");
                foreach (var err in scan.Errors)
                {
                    sb.AppendLine($"- `{Rel(repoRoot, err.File)}` — {err.Message}");
                }
                sb.AppendLine();
            }

            if (scan.DuplicateIds.Any())
            {
                sb.AppendLine("## Duplicate IDs");
                foreach (var kvp in scan.DuplicateIds.OrderBy(k => k.Key, StringComparer.OrdinalIgnoreCase))
                {
                    sb.AppendLine($"- **{kvp.Key}**");
                    foreach (var item in kvp.Value)
                    {
                        sb.AppendLine($"  - `{item.Schema}` in `{Rel(repoRoot, item.SourceFile)}`");
                    }
                }
                sb.AppendLine();
            }

            // Match Code Index style: bulleted list of files with View · Raw links
            var (repo, branch) = RepoMeta();
            var allXmlFiles = scan.FileDocs.Keys.OrderBy(p => p, StringComparer.OrdinalIgnoreCase).ToList();
            if (allXmlFiles.Count > 0)
            {
                foreach (var file in allXmlFiles)
                {
                    var rel = Rel(repoRoot, file);
                    var webPath = rel.Replace('\\','/'); // ensure URL form
                    var enc = EncodePathSegments(webPath);
                    var viewUrl = $"https://github.com/{repo}/blob/{branch}/{enc}";
                    var rawUrl  = $"https://raw.githubusercontent.com/{repo}/{branch}/{enc}";
                    sb.AppendLine($"- `{webPath}` — [View]({viewUrl}) · [Raw]({rawUrl})");
                }
                sb.AppendLine();
            }

            // Keep the schema summary (below the list) for quick counts
            sb.AppendLine("## Summary by Schema");
            sb.AppendLine();
            sb.AppendLine("| Schema | Def Count | Files |");
            sb.AppendLine("|---|---:|---|");
            foreach (var schema in scan.Schemas.OrderBy(s => s))
            {
                var defs = scan.DefsBySchema[schema];
                var files = defs.Select(d => Rel(repoRoot, d.SourceFile)).Distinct().OrderBy(s => s);
                sb.AppendLine($"| {schema} | {defs.Count} | {string.Join("<br/>", files)} |");
            }
            sb.AppendLine();

            // Per-schema sections unchanged below (list ids + rare fields)

            foreach (var schema in scan.Schemas.OrderBy(s => s))
            {
                var defs = scan.DefsBySchema[schema];
                sb.AppendLine($"### {schema}");
                sb.AppendLine();
                foreach (var d in defs.OrderBy(d => d.Id, StringComparer.OrdinalIgnoreCase))
                {
                    sb.AppendLine($"- `{d.Id}` — `{Rel(repoRoot, d.SourceFile)}`");
                }
                // Any newly observed/rare fields
                var fieldCounts = new Dictionary<string,int>(StringComparer.OrdinalIgnoreCase);
                foreach (var d in defs)
                {
                    foreach (var f in d.AttributeFields.Concat(d.ElementFields))
                        fieldCounts[f] = fieldCounts.TryGetValue(f, out var c) ? c + 1 : 1;
                }
                var rare = fieldCounts.Where(kvp => kvp.Value <= Math.Max(1, defs.Count/5)).Select(kvp => kvp.Key).OrderBy(s=>s, StringComparer.OrdinalIgnoreCase).ToList();
                if (rare.Count > 0)
                {
                    sb.AppendLine();
                    sb.AppendLine("<details><summary>Less common fields</summary>");
                    sb.AppendLine();
                    foreach (var f in rare) sb.AppendLine($"- `{f}`");
                    sb.AppendLine();
                    sb.AppendLine("</details>");
                }
                sb.AppendLine();
            }

            Directory.CreateDirectory(Path.GetDirectoryName(outFile)!);
            File.WriteAllText(outFile, sb.ToString());
        }

        // Encode each path segment to avoid corrupting '/' and handle special characters safely.
        private static string EncodePathSegments(string path)
        {
            var parts = path.Replace('\\','/').Split(new[]{'/'}, StringSplitOptions.RemoveEmptyEntries);
            var encoded = parts.Select(Uri.EscapeDataString);
            return string.Join("/", encoded);
        }

        private static (string repo, string branch) RepoMeta()
        {
            var repo = Environment.GetEnvironmentVariable("GITHUB_REPOSITORY");
            if (string.IsNullOrWhiteSpace(repo)) repo = "Natangry/FantasyColony";
            var branch = Environment.GetEnvironmentVariable("GITHUB_REF_NAME");
            if (string.IsNullOrWhiteSpace(branch)) branch = "main";
            // strip refs/heads/ if present
            branch = branch.Replace("refs/heads/", "");
            return (repo, branch);
        }

        private static string Rel(string root, string path)
        {
            try
            {
                var rp = Path.GetRelativePath(root, path).Replace('\\','/');
                return rp;
            }
            catch
            {
                return path.Replace('\\','/');
            }
        }
    }
}

// ===== FILE: Tools/XmlDefsTools/Emit/XmlSnapshotWriter.cs =====
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Xml.Linq;
using XmlDefsTools.Util;

namespace XmlDefsTools.Emit
{
    public static class XmlSnapshotWriter
    {
        public static void Write(string repoRoot, string outFile, IEnumerable<(string path, XDocument? doc)> docs)
        {
            var sb = new StringBuilder();
            foreach (var (path, doc) in docs.OrderBy(t => t.path, StringComparer.OrdinalIgnoreCase))
            {
                sb.AppendLine($"// ===== FILE: {Rel(repoRoot, path)} =====");
                if (doc == null)
                {
                    sb.AppendLine("// (invalid XML)");
                    sb.AppendLine();
                    continue;
                }
                var normalized = CanonicalXml.Canonicalize(doc);
                sb.AppendLine(normalized);
                sb.AppendLine();
            }
            File.WriteAllText(outFile, sb.ToString());
        }

        private static string Rel(string root, string path)
        {
            try
            {
                var rp = Path.GetRelativePath(root, path).Replace('\\','/');
                return rp;
            }
            catch
            {
                return path.Replace('\\','/');
            }
        }
    }
}

// ===== FILE: Tools/XmlDefsTools/Program.cs =====
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text.Json;
using XmlDefsTools.Emit;
using XmlDefsTools.Scan;

namespace XmlDefsTools
{
    internal static class Program
    {
        private static int Main(string[] args)
        {
            try
            {
                var repoRoot = GetRepoRoot();
                var defsDir = GetDefsDir(repoRoot);
                Console.WriteLine($"[XmlDefsTools] Repo root: {repoRoot}");
                Console.WriteLine($"[XmlDefsTools] Defs dir : {defsDir}");

                var scanner = new XmlDefScanner();
                var scan = scanner.Scan(defsDir);

                // Load order hints
                var hintsPath = Path.Combine(repoRoot, "Tools", "XmlDefsTools", "Config", "SchemaOrder.json");
                var orderHints = File.Exists(hintsPath)
                    ? JsonSerializer.Deserialize<Dictionary<string, IList<string>>>(File.ReadAllText(hintsPath))
                    : new Dictionary<string, IList<string>>(StringComparer.OrdinalIgnoreCase);
                orderHints ??= new Dictionary<string, IList<string>>(StringComparer.OrdinalIgnoreCase);

                // Write index
                var indexPath = Path.Combine(repoRoot, "XML_INDEX.md");
                XmlIndexWriter.Write(repoRoot, indexPath, scan);
                Console.WriteLine($"[XmlDefsTools] Wrote index: {indexPath}");

                // Write snapshot
                var snapshotPath = Path.Combine(repoRoot, "XML_SNAPSHOT.txt");
                var docs = scan.FileDocs.Select(kvp => (kvp.Key, kvp.Value));
                XmlSnapshotWriter.Write(repoRoot, snapshotPath, docs);
                Console.WriteLine($"[XmlDefsTools] Wrote snapshot: {snapshotPath}");

                // Write templates
                var templatesDir = Path.Combine(repoRoot, "Docs", "Templates", "Defs");
                TemplateSynthesizer.WriteTemplates(templatesDir, scan, orderHints);
                Console.WriteLine($"[XmlDefsTools] Wrote templates to: {templatesDir}");

                // Write consolidated schema catalog
                var catalogPath = Path.Combine(templatesDir, "_AllSchemas.xml");
                SchemaCatalogWriter.Write(templatesDir, scan, orderHints);
                Console.WriteLine($"[XmlDefsTools] Wrote consolidated catalog: {catalogPath}");

                return 0;
            }
            catch (Exception ex)
            {
                Console.Error.WriteLine(ex.ToString());
                return 1;
            }
        }

        private static string GetRepoRoot()
        {
            var env = Environment.GetEnvironmentVariable("FC_REPO_ROOT");
            if (!string.IsNullOrWhiteSpace(env))
                return Path.GetFullPath(env);
            // assume current working directory is repo root (CI) or a subfolder (local)
            var cwd = Directory.GetCurrentDirectory();
            // try to find .git upwards
            var dir = new DirectoryInfo(cwd);
            while (dir != null)
            {
                if (Directory.Exists(Path.Combine(dir.FullName, ".git")))
                    return dir.FullName;
                dir = dir.Parent;
            }
            return cwd;
        }

        private static string GetDefsDir(string repoRoot)
        {
            var env = Environment.GetEnvironmentVariable("FC_DEFS_DIR");
            if (!string.IsNullOrWhiteSpace(env))
            {
                var p = Path.IsPathRooted(env) ? env : Path.Combine(repoRoot, env);
                return Directory.Exists(p) ? p : repoRoot;
            }
            var candidates = new[]
            {
                Path.Combine(repoRoot, "StreamingAssets", "Defs"),
                Path.Combine(repoRoot, "Assets", "StreamingAssets", "Defs"),
                Path.Combine(repoRoot, "GameData", "Defs")
            };
            foreach (var c in candidates)
                if (Directory.Exists(c)) return c;
            // fallback: repo root (will scan, find no files, still emit artifacts)
            return repoRoot;
        }
    }
}

// ===== FILE: Tools/XmlDefsTools/Scan/XmlDefScanner.cs =====
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Xml;
using System.Xml.Linq;

namespace XmlDefsTools.Scan
{
    public sealed class XmlDefScanner
    {
        public ScanResult Scan(string rootDir)
        {
            var res = new ScanResult();
            if (!Directory.Exists(rootDir))
                return res;

            var files = Directory.EnumerateFiles(rootDir, "*.xml", SearchOption.AllDirectories).ToList();
            res.TotalFiles = files.Count;
            foreach (var file in files)
            {
                XDocument? doc = null;
                try
                {
                    var text = File.ReadAllText(file);
                    doc = XDocument.Parse(text, LoadOptions.PreserveWhitespace | LoadOptions.SetLineInfo);
                    res.ValidFiles++;
                    res.FileDocs[file] = doc;
                }
                catch (Exception ex)
                {
                    res.Errors.Add(new ScanError { File = file, Message = ex.GetBaseException().Message });
                    res.FileDocs[file] = null;
                    continue;
                }

                // Collect defs: any element with an 'id' attribute
                var defs = doc.Descendants()
                    .Where(e => e.NodeType == System.Xml.XmlNodeType.Element)
                    .OfType<XElement>()
                    .Where(e => e.Attribute("id") != null)
                    .ToList();

                foreach (var el in defs)
                {
                    var schema = el.Name.LocalName;
                    var id = (string?)el.Attribute("id") ?? "(missing)";
                    var info = new DefInfo
                    {
                        Schema = schema,
                        Id = id,
                        SourceFile = file
                    };

                    // Attribute fields (names only)
                    foreach (var a in el.Attributes())
                    {
                        if (a.IsNamespaceDeclaration) continue;
                        info.AttributeFields.Add(a.Name.LocalName);
                    }

                    // Element fields (direct child element names only)
                    foreach (var child in el.Elements())
                    {
                        info.ElementFields.Add(child.Name.LocalName);
                    }

                    res.TotalDefs++;
                    if (!res.DefsBySchema.TryGetValue(schema, out var list))
                    {
                        list = new List<DefInfo>();
                        res.DefsBySchema[schema] = list;
                        res.Schemas.Add(schema);
                    }
                    list.Add(info);

                    // Track duplicates
                    var dupKey = id;
                    if (!res.DuplicateIds.TryGetValue(dupKey, out var dupList))
                    {
                        dupList = new List<DefInfo>();
                        res.DuplicateIds[dupKey] = dupList;
                    }
                    dupList.Add(info);
                }
            }

            // Remove entries that are not actually duplicates (only one occurrence)
            var toPrune = res.DuplicateIds.Where(kvp => kvp.Value.Count <= 1)
                                          .Select(kvp => kvp.Key).ToList();
            foreach (var k in toPrune) res.DuplicateIds.Remove(k);

            return res;
        }
    }

    public sealed class ScanResult
    {
        public int TotalFiles { get; set; }
        public int ValidFiles { get; set; }
        public int TotalDefs { get; set; }
        public HashSet<string> Schemas { get; } = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
        public Dictionary<string, List<DefInfo>> DefsBySchema { get; } = new Dictionary<string, List<DefInfo>>(StringComparer.OrdinalIgnoreCase);
        public List<ScanError> Errors { get; } = new List<ScanError>();
        public Dictionary<string, XDocument?> FileDocs { get; } = new Dictionary<string, XDocument?>(StringComparer.OrdinalIgnoreCase);
        public Dictionary<string, List<DefInfo>> DuplicateIds { get; } = new Dictionary<string, List<DefInfo>>(StringComparer.OrdinalIgnoreCase);
    }

    public sealed class DefInfo
    {
        public string Schema { get; set; } = "";
        public string Id { get; set; } = "";
        public string SourceFile { get; set; } = "";
        public HashSet<string> AttributeFields { get; } = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
        public HashSet<string> ElementFields { get; } = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
    }

    public sealed class ScanError
    {
        public string File { get; set; } = "";
        public string Message { get; set; } = "";
    }
}

// ===== FILE: Tools/XmlDefsTools/Util/CanonicalXml.cs =====
using System;
using System.IO;
using System.Linq;
using System.Text;
using System.Xml;
using System.Xml.Linq;

namespace XmlDefsTools.Util
{
    public static class CanonicalXml
    {
        private static readonly string[] AttributePrecedence =
        {
            "id","schema","name_key","tags","version","requires"
        };

        public static string Canonicalize(XDocument doc)
        {
            // Remove comments
            foreach (var c in doc.DescendantNodes().OfType<XComment>().ToList())
                c.Remove();

            // Canonicalize elements & attributes
            var root = CanonicalizeElement(doc.Root!);
            var newDoc = new XDocument(root);

            // Save with stable formatting
            var settings = new XmlWriterSettings
            {
                OmitXmlDeclaration = true,
                Indent = true,
                NewLineOnAttributes = false
            };
            var sb = new StringBuilder();
            using (var writer = XmlWriter.Create(sb, settings))
            {
                newDoc.Save(writer);
            }
            return sb.ToString().Trim() + Environment.NewLine;
        }

        public static XElement CanonicalizeElement(XElement el)
        {
            var orderedAttrs = el.Attributes()
                .Where(a => !a.IsNamespaceDeclaration)
                .OrderBy(a => OrderKey(a.Name.LocalName))
                .ThenBy(a => a.Name.LocalName, StringComparer.OrdinalIgnoreCase)
                .ToList();

            var newEl = new XElement(el.Name);
            foreach (var a in orderedAttrs)
                newEl.SetAttributeValue(a.Name.LocalName, a.Value);

            foreach (var node in el.Nodes())
            {
                if (node is XElement child)
                {
                    newEl.Add(CanonicalizeElement(child));
                }
                else if (node is XText t)
                {
                    var v = t.Value;
                    if (!string.IsNullOrWhiteSpace(v))
                        newEl.Add(new XText(NormalizeWhitespace(v)));
                }
                // other node types (comments, processing instructions) are skipped
            }
            return newEl;
        }

        private static int OrderKey(string name)
        {
            for (int i = 0; i < AttributePrecedence.Length; i++)
                if (name.Equals(AttributePrecedence[i], StringComparison.OrdinalIgnoreCase))
                    return i - 1000; // bubble to front
            return 0;
        }

        private static string NormalizeWhitespace(string s)
        {
            // Collapse internal whitespace sequences
            var arr = s.ToCharArray();
            var sb = new StringBuilder(arr.Length);
            bool inWs = false;
            foreach (var ch in arr)
            {
                if (char.IsWhiteSpace(ch))
                {
                    if (!inWs)
                    {
                        sb.Append(' ');
                        inWs = true;
                    }
                }
                else
                {
                    sb.Append(ch);
                    inWs = false;
                }
            }
            return sb.ToString().Trim();
        }
    }
}

