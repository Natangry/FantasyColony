# Auto-generated code snapshot
_Updated_: 2025-09-04 04:33:22 UTC

// ===== FILE: Assets/Editor/SpriteImportDefaults.cs =====
// Editor-only: ensures sprites import with our project defaults (hi-res, crisp pixels).
// - Applies automatically to any texture under a folder named "Sprites" (e.g. Assets/Resources/Sprites/)
// - Adds menu items to (re)apply settings to selected textures or an entire folder
//
// Defaults:
//   TextureType: Sprite (2D and UI)
//   SpriteMode: Single
//   Pixels Per Unit: 64
//   Filter Mode: Point (no filter)
//   Compression: None (Uncompressed)
//   Wrap Mode: Clamp
//   MipMaps: Off
//   sRGB: On
//   Alpha Is Transparency: On (where supported)
//   Pivot: Bottom-Center (0.5, 0.0)

#if UNITY_EDITOR
using System;
using System.Linq;
using UnityEditor;
using UnityEngine;
using System.Reflection;

namespace FantasyColony.EditorTools
{
    public class SpriteImportDefaults : AssetPostprocessor
    {
        const float DefaultPPU = 64f;
        const int   DefaultMaxSize = 1024;

        static bool IsSpritePath(string path)
        {
            if (string.IsNullOrEmpty(path)) return false;
            path = path.Replace('\\', '/').ToLowerInvariant();
            return path.Contains("/sprites/");
        }

        void OnPreprocessTexture()
        {
            if (!IsSpritePath(assetPath)) return;
            var ti = (TextureImporter)assetImporter;
            ApplyDefaults(ti);
        }

        static void ApplyDefaults(TextureImporter ti)
        {
            ti.textureType = TextureImporterType.Sprite;
            ti.spriteImportMode = SpriteImportMode.Single;
            ti.spritePixelsPerUnit = DefaultPPU;
            ti.mipmapEnabled = false;
            ti.filterMode = FilterMode.Point;
            ti.textureCompression = TextureImporterCompression.Uncompressed;
            ti.wrapMode = TextureWrapMode.Clamp;
            ti.maxTextureSize = DefaultMaxSize;

            // Color space & alpha handling
#if UNITY_2019_3_OR_NEWER
            ti.sRGBTexture = true;
#endif
#if !UNITY_2023_1_OR_NEWER
            // In newer versions this field may be hidden/ignored, but it's safe to set where available.
            ti.alphaIsTransparency = true;
#endif
#if UNITY_2021_2_OR_NEWER
            ti.alphaSource = TextureImporterAlphaSource.FromInput;
#endif

            // Pivot: Bottom-Center (Unity 6 removed 'spriteAlignment'; set via spritePivot and
            // use reflection to set alignment to Custom when property exists on older versions)
            SetPivotBottomCenter(ti);
        }

        static void SetPivotBottomCenter(TextureImporter ti)
        {
            // Always set explicit pivot
            ti.spritePivot = new Vector2(0.5f, 0f);

            // Try to set alignment to Custom when the legacy property exists
            try
            {
                var prop = typeof(TextureImporter).GetProperty("spriteAlignment",
                    BindingFlags.Public | BindingFlags.Instance);
                if (prop != null && prop.CanWrite)
                {
                    var enumType = prop.PropertyType;
                    object customVal = null;
                    // If type is an enum that defines "Custom", use it; otherwise fall back to 9
                    if (enumType.IsEnum && Enum.GetNames(enumType).Contains("Custom"))
                        customVal = Enum.Parse(enumType, "Custom");
                    else
                        customVal = Convert.ChangeType(9, enumType); // 9 == SpriteAlignment.Custom in legacy

                    prop.SetValue(ti, customVal);
                }
            }
            catch
            {
                // Safe no-op on newer Unity versions
            }
        }

        // --- Context menus ---------------------------------------------------

        [MenuItem("Assets/Sprites/Apply Sprite Defaults (64 PPU)", true)]
        static bool ValidateApplyToSelection()
        {
            return Selection.assetGUIDs != null && Selection.assetGUIDs.Length > 0;
        }

        [MenuItem("Assets/Sprites/Apply Sprite Defaults (64 PPU)")]
        static void ApplyToSelection()
        {
            int count = 0;
            foreach (var guid in Selection.assetGUIDs)
            {
                var path = AssetDatabase.GUIDToAssetPath(guid);
                if (string.IsNullOrEmpty(path)) continue;
                if (!IsSpritePath(path)) continue;
                var ti = AssetImporter.GetAtPath(path) as TextureImporter;
                if (ti == null) continue;
                ApplyDefaults(ti);
                AssetDatabase.ImportAsset(path, ImportAssetOptions.ForceUpdate);
                count++;
            }
            Debug.Log($"[SpriteImportDefaults] Applied to {count} asset(s).");
        }

        [MenuItem("Assets/Sprites/Apply Defaults To Folder (recursive)", true)]
        static bool ValidateApplyToFolder()
        {
            // Enable when a folder is selected
            return Selection.assetGUIDs.Any(guid =>
            {
                var path = AssetDatabase.GUIDToAssetPath(guid);
                return AssetDatabase.IsValidFolder(path);
            });
        }

        [MenuItem("Assets/Sprites/Apply Defaults To Folder (recursive)")]
        static void ApplyToFolder()
        {
            int total = 0;
            foreach (var guid in Selection.assetGUIDs)
            {
                var folder = AssetDatabase.GUIDToAssetPath(guid);
                if (!AssetDatabase.IsValidFolder(folder)) continue;
                var guids = AssetDatabase.FindAssets("t:Texture2D", new[] { folder });
                foreach (var texGuid in guids)
                {
                    var path = AssetDatabase.GUIDToAssetPath(texGuid);
                    if (!IsSpritePath(path)) continue;
                    var ti = AssetImporter.GetAtPath(path) as TextureImporter;
                    if (ti == null) continue;
                    ApplyDefaults(ti);
                    AssetDatabase.ImportAsset(path, ImportAssetOptions.ForceUpdate);
                    total++;
                }
            }
            Debug.Log($"[SpriteImportDefaults] Applied to {total} asset(s) in folder(s).");
        }
    }
}
#endif

// ===== FILE: Assets/Scripts/Boot/BootPipeline.cs =====
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using FantasyColony.Core.Services;
using FantasyColony.Core.Mods;

namespace FantasyColony.Boot {
    /// <summary>
    /// Modular boot pipeline. Each step is an IBootTask for extensibility and robust error handling.
    /// </summary>
    public static class BootPipeline {
        public static IEnumerator Run(Action<string> setPhase) {
            var report = new Boot.BootReport();
            var ctx = new Boot.BootContext { Report = report };

            foreach (var task in Boot.BootTaskRegistry.DefaultTasks()) {
                setPhase?.Invoke(task.Title);
                yield return task.Execute(ctx);
            }

            // Ready
            setPhase?.Invoke("Ready");
            Boot.BootReport.Last = report;
        }
    }

    // --- Boot framework ---------------------------------------------------
    public interface IBootTask {
        string Title { get; }
        IEnumerator Execute(BootContext ctx);
    }

    public sealed class BootContext {
        public List<ModInfo> Mods = new List<ModInfo>();
        public DefRegistry Defs => DefRegistry.Instance;
        public JsonConfigService Config => JsonConfigService.Instance;
        public BootReport Report;
    }

    public sealed class BootReport {
        public struct Step { public string title; public float seconds; public string warn; public string error; }
        public readonly List<Step> steps = new();
        public static BootReport Last { get; internal set; }
        internal void Add(string title, float dt, string warn = null, string error = null) {
            steps.Add(new Step { title = title, seconds = dt, warn = warn, error = error });
        }
    }

    public static class BootTaskRegistry {
        public static IEnumerable<IBootTask> DefaultTasks() {
            yield return new ConfigTask();
            yield return new DiscoverModsTask();
            yield return new LoadDefsTask();
            yield return new ValidateAndMigrateDefsTask();
            yield return new InitServicesTask();
            yield return new WarmAssetsTask();
        }
    }

    // --- Concrete tasks ---------------------------------------------------
    sealed class ConfigTask : IBootTask {
        public string Title => "Loading configuration...";
        public IEnumerator Execute(BootContext ctx) {
            var t0 = Time.realtimeSinceStartup;
            string warn = null, err = null;
            try { ctx.Config.Load(); }
            catch (Exception e) { warn = $"Config load failed, defaults used: {e.Message}"; Debug.LogWarning(warn); }
            ctx.Report?.Add(Title, Time.realtimeSinceStartup - t0, warn, err);
            yield return null;
        }
    }

    sealed class DiscoverModsTask : IBootTask {
        public string Title => "Discovering mods...";
        public IEnumerator Execute(BootContext ctx) {
            var t0 = Time.realtimeSinceStartup;
            string warn = null;
            try { ctx.Mods = ModDiscovery.Discover(); Debug.Log($"Mods discovered: {ctx.Mods.Count}"); }
            catch (Exception e) { warn = $"Mod discovery failed: {e.Message}"; Debug.LogWarning(warn); ctx.Mods = new List<ModInfo>(); }
            ctx.Report?.Add(Title, Time.realtimeSinceStartup - t0, warn, null);
            yield return null;
        }
    }

    sealed class LoadDefsTask : IBootTask {
        public string Title => "Loading defs...";
        public IEnumerator Execute(BootContext ctx) {
            var t0 = Time.realtimeSinceStartup;
            string warn = null;
            try {
                var errors = new List<DefError>();
                XmlDefLoader.Load(ctx.Mods, ctx.Defs, errors);
                if (errors.Count > 0) warn = $"Defs loaded with {errors.Count} issues. See log.";
                if (ctx.Defs.ConflictCount > 0) {
                    var note = $"Conflicts={ctx.Defs.ConflictCount}";
                    warn = string.IsNullOrEmpty(warn) ? note : ($"{warn} | {note}");
                }
                Debug.Log($"Defs loaded. Count={ctx.Defs.Count}");
            } catch (Exception e) { warn = $"Def loading failed (lenient): {e.Message}"; Debug.LogWarning(warn); }
            ctx.Report?.Add(Title, Time.realtimeSinceStartup - t0, warn, null);
            yield return null;
        }
    }

    sealed class ValidateAndMigrateDefsTask : IBootTask {
        public string Title => "Validating & migrating defs...";
        public IEnumerator Execute(BootContext ctx) {
            var t0 = Time.realtimeSinceStartup;
            string warn = null;
            int warnCount = 0, migCount = 0;
            try {
                // Build index first, then load schemas from StreamingAssets and from each mod root inferred via index
                var index = FantasyColony.Core.Defs.DefIndex.Build(ctx.Mods, ctx.Defs);
                FantasyColony.Core.Defs.Validation.SchemaCatalog.EnsureLoadedFromIndex(index);
                var results = FantasyColony.Core.Defs.Validation.DefValidator.Run(index);
                foreach (var r in results) { Debug.LogWarning($"[Defs] {r}"); }
                warnCount = results.Count;
                migCount = FantasyColony.Core.Defs.Migrations.MigrationEngine.Run(index);
                if (warnCount > 0 || migCount > 0) {
                    warn = $"Validation warnings={warnCount}, migrations={migCount}";
                }
            } catch (Exception e) {
                warn = $"Validation phase had issues: {e.Message}";
                Debug.LogWarning(warn);
            }
            ctx.Report?.Add(Title, Time.realtimeSinceStartup - t0, warn, null);
            yield return null;
        }
    }

    sealed class InitServicesTask : IBootTask {
        public string Title => "Initializing services...";
        public IEnumerator Execute(BootContext ctx) {
            var t0 = Time.realtimeSinceStartup;
            string warn = null;
            try {
                var cfg = ctx.Config;
                var lang = cfg.Get("language", "en");
                LocService.Instance.SetLanguage(lang);
                float vMaster = Parse01(cfg.Get("vol_master", "1"));
                float vMusic  = Parse01(cfg.Get("vol_music", "1"));
                float vSfx    = Parse01(cfg.Get("vol_sfx", "1"));
                AudioService.Instance.SetVolume("master", vMaster);
                AudioService.Instance.SetVolume("music", vMusic);
                AudioService.Instance.SetVolume("sfx", vSfx);
                JsonSaveService.Instance.RefreshCache();
            } catch (Exception e) { warn = $"Service init had issues: {e.Message}"; Debug.LogWarning(warn); }
            ctx.Report?.Add(Title, Time.realtimeSinceStartup - t0, warn, null);
            yield return null;
        }
        private static float Parse01(string s) {
            if (float.TryParse(s, out var v)) {
                if (float.IsNaN(v) || float.IsInfinity(v)) return 1f;
                return Mathf.Clamp01(v);
            }
            return 1f;
        }
    }

    sealed class WarmAssetsTask : IBootTask {
        public string Title => "Warming assets...";
        public IEnumerator Execute(BootContext ctx) {
            var t0 = Time.realtimeSinceStartup;
#if ADDRESSABLES
            try {
                var handle = UnityEngine.AddressableAssets.Addressables.InitializeAsync();
                yield return handle;
            } catch { /* fail-soft */ }
#else
            yield return null;
#endif
            ctx.Report?.Add(Title, Time.realtimeSinceStartup - t0, null, null);
        }
    }
}


// ===== FILE: Assets/Scripts/Core/AppBootstrap.cs =====
using UnityEngine;

namespace FantasyColony.Core
{
    /// <summary>
    /// Single entry point. We don't rely on authored Unity scenes; everything is spawned at runtime.
    /// </summary>
    public static class AppBootstrap
    {
        [RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]
        private static void Boot()
        {
            // Guard against duplicates (domain reloads, additive loads)
#if UNITY_2023_1_OR_NEWER
            if (Object.FindFirstObjectByType<AppHost>() != null) return;
#else
            if (Object.FindObjectOfType<AppHost>() != null) return;
#endif
            // Root host object that survives for the whole app lifetime.
            var root = new GameObject("AppRoot");
            Object.DontDestroyOnLoad(root);
            root.AddComponent<AppHost>();
        }
    }
}

// ===== FILE: Assets/Scripts/Core/AppFlow.cs =====
using System.Collections;
using UnityEngine;
using FantasyColony.UI.Router;
using FantasyColony.UI.Screens;
using FantasyColony.UI.Util;

namespace FantasyColony.Core {
    /// <summary>
    /// Centralized app-level flows (Restart, Quit) so buttons/screens don't need to know wiring.
    /// </summary>
    public class AppFlow : MonoBehaviour {
        private UIRouter _router;

        public static AppFlow Instance { get; private set; }

        private void Awake() {
            if (Instance != null && Instance != this) {
                Destroy(gameObject);
                return;
            }
            Instance = this;
            DontDestroyOnLoad(gameObject);
        }

        internal void Initialize(UIRouter router) {
            _router = router;
        }

        /// <summary>
        /// Cleanly restarts to the Boot screen, re-running the boot pipeline.
        /// </summary>
        public void Restart() {
            if (_router == null) return;
            StartCoroutine(RestartCo());
        }

        private IEnumerator RestartCo() {
            // Cover with Boot screen first
            _router.PopAll();
            _router.Push<BootScreen>();

            // Give UI one frame to present cover
            yield return null;

            GrayscaleSpriteCache.Clear();
            // Free anything not referenced anymore
            yield return Resources.UnloadUnusedAssets();
            System.GC.Collect();
        }

        public void Quit() {
            Application.Quit();
        }
    }
}

namespace FantasyColony.UI.Screens {
    // Convenience shim to keep existing UI button bindings simple
    public static class AppFlowCommands {
        public static void Restart() => FantasyColony.Core.AppFlow.Instance?.Restart();
        public static void Quit() => FantasyColony.Core.AppFlow.Instance?.Quit();
    }
}

// ===== FILE: Assets/Scripts/Core/AppHost.cs =====
using UnityEngine;
using FantasyColony.UI.Root;
using FantasyColony.UI.Router;
using FantasyColony.Core.Services;
using FantasyColony.UI.Screens;
using FantasyColony.UI.Util;

// Disambiguate our service interfaces from Unity's similarly named types
using FCLogger = FantasyColony.Core.Services.ILogger;
using FCFileLogger = FantasyColony.Core.Services.FileLogger;
using FCConfigService = FantasyColony.Core.Services.IConfigService;
using FCEventBus = FantasyColony.Core.Services.IEventBus;
using FCSimpleEventBus = FantasyColony.Core.Services.SimpleEventBus;
using FCAssetProvider = FantasyColony.Core.Services.IAssetProvider;
using FCResourcesProvider = FantasyColony.Core.Services.ResourcesAssetProvider;
using FCJsonConfig = FantasyColony.Core.Services.JsonConfigService;

namespace FantasyColony.Core
{
    /// <summary>
    /// Lifetime owner.
    /// Builds services, creates UIRoot and pushes Main Menu screen.
    /// </summary>
    public class AppHost : MonoBehaviour
    {
        public static AppHost Instance { get; private set; }
        public ServiceRegistry Services => _services;
        public UIRouter Router => _router;

        private ServiceRegistry _services;
        private UIRoot _uiRoot;
        private UIRouter _router;

        private void Awake()
        {
            // Duplicate guard: prefer the first instance
            if (Instance != null && Instance != this) { Destroy(gameObject); return; }
            Instance = this;

            _services = new ServiceRegistry();
            _services.Register<FCLogger>(new FCFileLogger());
            // Use JSON-backed config as the single source of truth
            var cfg = FCJsonConfig.Instance;
            cfg.Load();
            _services.Register<FCConfigService>(cfg);
            _services.Register<FCEventBus>(new FCSimpleEventBus());
            _services.Register<FCAssetProvider>(new FCResourcesProvider());
            // Make AudioService discoverable via the registry
            _services.Register<AudioService>(AudioService.Instance);

            // Apply desktop frame pacing from config (defaults: vsync=1, target_fps=-1)
            int vsync = 1; int targetFps = -1;
            System.Int32.TryParse(cfg.Get("video.vsync", "1"), out vsync);
            System.Int32.TryParse(cfg.Get("video.target_fps", "-1"), out targetFps);
            QualitySettings.vSyncCount = Mathf.Max(0, vsync);
            Application.targetFrameRate = targetFps;

            // Create UI root (Canvas + EventSystem)
            _uiRoot = UIRoot.Create(transform);

            // Router mounts screens under UIRoot
            _router = new UIRouter(_uiRoot.ScreenParent, _services);

            // Attach AppFlow helper to manage restart/quit across the app
            var flow = gameObject.GetComponent<AppFlow>();
            if (flow == null) flow = gameObject.AddComponent<AppFlow>();
            flow.Initialize(_router);

            // Global shortcuts (e.g., F9 to open Boot Report) available in all builds
            var shortcuts = gameObject.GetComponent<GlobalShortcuts>();
            if (shortcuts == null) shortcuts = gameObject.AddComponent<GlobalShortcuts>();

            // Show Boot screen first so the UI covers while startup work initializes
            _router.Push<BootScreen>();
        }

        private void OnDestroy()
        {
            if (Instance == this)
            {
                Instance = null;
                GrayscaleSpriteCache.Clear();
            }
        }
    }
}

// ===== FILE: Assets/Scripts/Core/BuildInfo.cs =====
namespace FantasyColony.Core
{
    /// <summary>
    /// Static build info for diagnostics; can be auto-generated later by an Editor script.
    /// </summary>
    public static class BuildInfo
    {
        public const string Version = "0.1.0";
        public const string Commit = "local";
        public const string Unity = "AUTO"; // can be filled at runtime via UnityEngine.Application.unityVersion
    }
}

namespace FantasyColony.Core.Services
{
    public static class BuildInfoRuntime
    {
        public static string Describe() => $"v{FantasyColony.Core.BuildInfo.Version} ({FantasyColony.Core.BuildInfo.Commit}) | Unity {UnityEngine.Application.unityVersion}";
    }
}

// ===== FILE: Assets/Scripts/Core/Defs/DefId.cs =====
using System;

namespace FantasyColony.Core.Defs {
    /// <summary>
    /// Canonical string id shape: modid.DefType.Name
    /// </summary>
    public struct DefId {
        public string Mod; public string Type; public string Name;
        public bool IsEmpty => string.IsNullOrEmpty(Mod) || string.IsNullOrEmpty(Type) || string.IsNullOrEmpty(Name);
        public override string ToString() => string.IsNullOrEmpty(Mod) ? $"{Type}.{Name}" : $"{Mod}.{Type}.{Name}";

        public static bool TryParse(string value, out DefId id) {
            id = default;
            if (string.IsNullOrEmpty(value)) return false;
            var parts = value.Split('.');
            if (parts.Length == 2) { // Type.Name (allowed for intra-pack refs)
                id = new DefId { Mod = string.Empty, Type = parts[0], Name = parts[1] };
                return true;
            }
            if (parts.Length == 3) {
                id = new DefId { Mod = parts[0], Type = parts[1], Name = parts[2] };
                return true;
            }
            return false;
        }
    }
}

// ===== FILE: Assets/Scripts/Core/Defs/DefIndex.cs =====
using System.Collections.Generic;
using System.Xml;
using FantasyColony.Core.Mods;
using FantasyColony.Core.Services;

namespace FantasyColony.Core.Defs {
    /// <summary>
    /// Builds a read-only index of defs from the registry + quick XML header reads.
    /// </summary>
    public sealed class DefIndex {
        public readonly List<DefMeta> Items = new();
        private readonly Dictionary<string, List<DefMeta>> _byType = new();
        private readonly Dictionary<string, DefMeta> _byKey = new(); // Type.Id (no mod prefix)

        public IEnumerable<DefMeta> OfType(string type) => _byType.TryGetValue(type, out var list) ? list : System.Array.Empty<DefMeta>();
        public DefMeta Find(string type, string id) => _byKey.TryGetValue(type + "." + id, out var m) ? m : null;

        public static DefIndex Build(List<ModInfo> mods, DefRegistry registry) {
            var index = new DefIndex();
            foreach (var entry in registry.All()) {
                // entry: (Type, Id, Path, ModId)
                var meta = new DefMeta {
                    Type = entry.Type,
                    Id = entry.Id,
                    Path = entry.Path,
                    ModId = entry.ModId,
                    Schema = null,
                    SchemaVersion = 0
                };

                // Quick read root attrs for schema/schema_version without loading entire doc
                try {
                    using var reader = XmlReader.Create(entry.Path, new XmlReaderSettings { IgnoreComments = true, IgnoreWhitespace = true, DtdProcessing = DtdProcessing.Ignore });
                    reader.MoveToContent();
                    if (reader.HasAttributes) {
                        var schemaAttr = reader.GetAttribute("schema");
                        if (!string.IsNullOrEmpty(schemaAttr)) meta.Schema = schemaAttr;
                        var svAttr = reader.GetAttribute("schema_version");
                        if (!string.IsNullOrEmpty(svAttr) && int.TryParse(svAttr, out var sv)) meta.SchemaVersion = sv;
                        else if (!string.IsNullOrEmpty(meta.Schema)) {
                            var at = meta.Schema.LastIndexOf('@');
                            if (at >= 0 && int.TryParse(meta.Schema.Substring(at + 1), out var sv2)) meta.SchemaVersion = sv2;
                        }
                    }
                } catch { /* ignore per-file errors here; validator will surface issues */ }

                index.Items.Add(meta);
                if (!index._byType.TryGetValue(meta.Type, out var list)) index._byType[meta.Type] = list = new List<DefMeta>(4);
                list.Add(meta);
                index._byKey[meta.Type + "." + meta.Id] = meta;
            }
            return index;
        }
    }
}

// ===== FILE: Assets/Scripts/Core/Defs/DefMeta.cs =====
namespace FantasyColony.Core.Defs {
    /// <summary>
    /// Lightweight metadata about a def used for validation and migrations.
    /// </summary>
    public sealed class DefMeta {
        public string Type;            // e.g., FactionDef
        public string Id;              // canonical id string
        public string Path;            // source file path
        public string ModId;           // owning mod
        public string Schema;          // e.g., "FactionDef@1" or null
        public int SchemaVersion;      // parsed version (fallback from Schema)
    }
}

// ===== FILE: Assets/Scripts/Core/Defs/Migrations/MigrationEngine.cs =====
using System;
using FantasyColony.Core.Services;
using UnityEngine;

namespace FantasyColony.Core.Defs.Migrations {
    public static class MigrationEngine {
        /// <summary>
        /// Returns number of defs that were logically migrated (metadata-only for now).
        /// </summary>
        public static int Run(Defs.DefIndex index) {
            int migrated = 0;
            foreach (var m in index.Items) {
                var (ok, current) = SchemaRegistry.TryGetCurrentVersion(m.Type);
                if (!ok) continue; // unknown types are allowed
                if (m.SchemaVersion == 0) continue; // missing handled by validator; do not auto-set
                if (m.SchemaVersion < current) {
                    migrated++;
                    Debug.Log($"[Defs] Migrated {m.Type}.{m.Id} from v{m.SchemaVersion} to v{current}");
                    // Future: data transforms on DOM; for now, we only log logical migration
                }
            }
            return migrated;
        }
    }
}

// ===== FILE: Assets/Scripts/Core/Defs/Migrations/SchemaRegistry.cs =====
using System.Collections.Generic;

namespace FantasyColony.Core.Defs.Migrations {
    /// <summary>
    /// Known def types and their current schema versions.
    /// Extend as new def families are introduced.
    /// </summary>
    public static class SchemaRegistry {
        private static readonly Dictionary<string, int> _current = new Dictionary<string, int> {
            { "FactionDef", 1 },
            { "ItemDef", 1 },
            { "BiomeDef", 1 },
            { "RecipeDef", 1 },
        };

        public static (bool ok, int version) TryGetCurrentVersion(string defType) {
            if (_current.TryGetValue(defType, out var v)) return (true, v);
            return (false, 0);
        }
    }
}

// ===== FILE: Assets/Scripts/Core/Defs/Validation/DefValidator.cs =====
using System.Collections.Generic;
using System.Xml;

namespace FantasyColony.Core.Defs.Validation {
    public static class DefValidator {
        public sealed class Result { public string Path; public string Message; public override string ToString()=> $"{Path}: {Message}"; }

        public static List<Result> Run(Defs.DefIndex index) {
            var results = new List<Result>();

            // R0: Duplicates within (Type, Id) across all mods
            var seen = new HashSet<string>();
            foreach (var m in index.Items) {
                var key = m.Type + "." + m.Id;
                if (!seen.Add(key)) results.Add(new Result { Path = m.Path, Message = $"Duplicate id for {m.Type}: '{m.Id}'" });
            }

            // Spec-driven validation
            foreach (var m in index.Items) {
                // Basic ID shape
                if (string.IsNullOrEmpty(m.Id) || !Defs.DefId.TryParse(m.Id.Contains('.') ? m.Id : $"{m.Type}.{m.Id}", out _)) {
                    results.Add(new Result { Path = m.Path, Message = $"Id not well-formed: '{m.Id}' (expected modid.{m.Type}.Name or {m.Type}.Name)" });
                    continue; // other checks will be noisy without an id
                }

                // Pick spec: declared version or current known
                SchemaSpec spec = null;
                if (m.SchemaVersion > 0) {
                    SchemaCatalog.TryGet(m.Type, m.SchemaVersion, out spec);
                } else {
                    SchemaCatalog.TryGetCurrent(m.Type, out spec);
                }

                // Version sanity vs current
                var (curOk, curVer) = Defs.Migrations.SchemaRegistry.TryGetCurrentVersion(m.Type);
                if (m.SchemaVersion > 0 && curOk && m.SchemaVersion > curVer) {
                    results.Add(new Result { Path = m.Path, Message = $"Schema version {m.SchemaVersion} ahead of supported {curVer} for {m.Type}" });
                }

                // Read minimal XML into attr/elem maps (root + first-level children)
                var attrs = new Dictionary<string,string>();
                var elems = new Dictionary<string,string>();
                try {
                    using var xr = XmlReader.Create(m.Path, new XmlReaderSettings { IgnoreComments = true, IgnoreWhitespace = true, DtdProcessing = DtdProcessing.Ignore });
                    xr.MoveToContent();
                    if (xr.HasAttributes) {
                        while (xr.MoveToNextAttribute()) attrs[xr.Name] = xr.Value;
                        xr.MoveToElement();
                    }
                    if (!xr.IsEmptyElement) {
                        xr.ReadStartElement();
                        int depth0 = xr.Depth;
                        while (!xr.EOF && xr.Depth <= depth0 + 1) {
                            if (xr.NodeType == XmlNodeType.Element) {
                                var name = xr.Name;
                                string val = string.Empty;
                                if (!xr.IsEmptyElement) val = xr.ReadElementContentAsString(); else xr.Read();
                                if (!elems.ContainsKey(name)) elems[name] = val;
                                continue;
                            }
                            xr.Read();
                        }
                    }
                } catch { /* per-file parsing issues are tolerated in lenient mode */ }

                if (spec == null) {
                    // No spec found; warn once for this file, but don't block
                    results.Add(new Result { Path = m.Path, Message = $"No schema spec found for {m.Type}@{(m.SchemaVersion>0?m.SchemaVersion:0)}; skipping spec checks" });
                    continue;
                }

                // Required fields present
                if (spec.required != null && spec.required.Length > 0) {
                    for (int i = 0; i < spec.required.Length; i++) {
                        var reqName = spec.required[i];
                        var fs = FindField(spec, reqName);
                        bool present = false;
                        if (fs != null && fs.kind == "attr") present = attrs.ContainsKey(reqName);
                        else if (fs != null && fs.kind == "elem") present = elems.ContainsKey(reqName);
                        else
                            present = attrs.ContainsKey(reqName) || elems.ContainsKey(reqName);
                        if (!present) results.Add(new Result { Path = m.Path, Message = $"Missing required field '{reqName}'" });
                    }
                }

                // Field type checks where present
                if (spec.fields != null) {
                    for (int i = 0; i < spec.fields.Count; i++) {
                        var fs = spec.fields[i];
                        string v = null; bool has = false;
                        if (fs.kind == "attr") { has = attrs.TryGetValue(fs.name, out v); }
                        else { has = elems.TryGetValue(fs.name, out v); }
                        if (!has) continue; // not present; required handling above
                        var (ok, err) = TypeChecks.Check(fs, v, index);
                        if (!ok) results.Add(new Result { Path = m.Path, Message = $"Field '{fs.name}': {err}" });
                    }
                }
            }

            return results;
        }

        private static FieldSpec FindField(SchemaSpec spec, string name) {
            if (spec.fields == null) return null;
            for (int i=0;i<spec.fields.Count;i++) if (spec.fields[i].name == name) return spec.fields[i];
            return null;
        }
    }
}

// ===== FILE: Assets/Scripts/Core/Defs/Validation/SchemaCatalog.cs =====
using System;
using System.Collections.Generic;
using System.IO;
using UnityEngine;

namespace FantasyColony.Core.Defs.Validation {
    /// <summary>
    /// Loads and caches per-type schema files located in StreamingAssets and Mods.
    /// </summary>
    public static class SchemaCatalog {
        private static readonly Dictionary<string, Dictionary<int, SchemaSpec>> _map = new(); // type -> version -> spec
        private static bool _loaded;

        public static void EnsureLoadedFromIndex(Defs.DefIndex index) {
            if (_loaded) return;
            try {
                // Game-bundled schemas
                var gameDir = Path.Combine(Application.streamingAssetsPath, "Defs", "Schemas");
                LoadFromDir(gameDir);

                // Mod-provided schemas (infer mod root from def file paths in index)
                if (index != null) {
                    var roots = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
                    foreach (var m in index.Items) {
                        var root = FindDefsRoot(Path.GetDirectoryName(m.Path));
                        if (!string.IsNullOrEmpty(root) && roots.Add(root)) {
                            var dir = Path.Combine(root, "Defs", "Schemas");
                            LoadFromDir(dir);
                        }
                    }
                }
            } catch (Exception e) {
                Debug.LogWarning($"SchemaCatalog load issue: {e.Message}");
            }
            _loaded = true;
        }

        private static void LoadFromDir(string dir) {
            if (string.IsNullOrEmpty(dir) || !Directory.Exists(dir)) return;
            var files = Directory.GetFiles(dir, "*.schema.json", SearchOption.AllDirectories);
            for (int i = 0; i < files.Length; i++) LoadFile(files[i]);
        }

        private static string FindDefsRoot(string startDir) {
            try {
                var dir = startDir;
                while (!string.IsNullOrEmpty(dir)) {
                    var defsDir = Path.Combine(dir, "Defs");
                    if (Directory.Exists(defsDir)) return dir;
                    dir = Path.GetDirectoryName(dir);
                }
            } catch { }
            return null;
        }

        private static void LoadFile(string path) {
            try {
                var json = File.ReadAllText(path);
                var spec = JsonUtility.FromJson<SchemaSpec>(json);
                if (spec == null || string.IsNullOrEmpty(spec.type) || spec.version <= 0) return;

                // Mark presence of numeric bounds so zero is enforceable
                try {
                    if (spec.fields != null) {
                        foreach (var fs in spec.fields) {
                            if (string.IsNullOrEmpty(fs.name)) continue;
                            var nameEsc = System.Text.RegularExpressions.Regex.Escape(fs.name);
                            var rx = new System.Text.RegularExpressions.Regex("{[^{}]*\\\"name\\\"\\s*:\\s*\\\"" + nameEsc + "\\\"[^{}]*}", System.Text.RegularExpressions.RegexOptions.CultureInvariant);
                            var m = rx.Match(json);
                            if (m.Success) {
                                var slice = m.Value;
                                fs.hasMin = slice.Contains("\\\"min\\\"");
                                fs.hasMax = slice.Contains("\\\"max\\\"");
                            }
                        }
                    }
                } catch { /* best-effort; missing flags default to false */ }
                var tkey = spec.type;
                if (!_map.TryGetValue(tkey, out var byVer)) _map[tkey] = byVer = new Dictionary<int, SchemaSpec>();
                // First-in wins; later duplicates are ignored but warned
                if (byVer.ContainsKey(spec.version)) {
                    Debug.LogWarning($"Duplicate schema {spec.type}@{spec.version} at {path}; keeping first loaded.");
                    return;
                }
                byVer[spec.version] = spec;
            } catch (Exception e) {
                Debug.LogWarning($"Failed to load schema '{path}': {e.Message}");
            }
        }

        public static bool TryGet(string defType, int version, out SchemaSpec spec) {
            spec = null;
            if (string.IsNullOrEmpty(defType) || version <= 0) return false;
            if (_map.TryGetValue(defType, out var byVer) && byVer.TryGetValue(version, out spec)) return true;
            return false;
        }

        public static bool TryGetCurrent(string defType, out SchemaSpec spec) {
            spec = null;
            var (ok, v) = FantasyColony.Core.Defs.Migrations.SchemaRegistry.TryGetCurrentVersion(defType);
            if (!ok) return false;
            return TryGet(defType, v, out spec);
        }
    }
}

// ===== FILE: Assets/Scripts/Core/Defs/Validation/SchemaSpec.cs =====
using System;
using System.Collections.Generic;

namespace FantasyColony.Core.Defs.Validation {
    /// <summary>
    /// JSON-deserializable schema spec for a single Def type & version.
    /// Stored as StreamingAssets/Defs/Schemas/<DefType>@<version>.schema.json
    /// </summary>
    [Serializable]
    public sealed class SchemaSpec {
        public string type;      // e.g., "FactionDef"
        public int version;      // e.g., 1
        public string[] required; // names of required fields
        public List<FieldSpec> fields; // all declared fields
    }

    [Serializable]
    public sealed class FieldSpec {
        public string name;      // field name as it appears in XML
        public string kind;      // "attr" or "elem"
        public string type;      // string|int|float|bool|color|enum|defref|id|list
        public string of;        // element type for lists (optional)
        public string target;    // for defref: target DefType
        public string[] values;  // for enum: allowed values
        public int min;          // numeric bounds (optional)
        public int max;
        public int minLength;    // for string
        [NonSerialized] public bool hasMin; // runtime: whether 'min' was present in JSON
        [NonSerialized] public bool hasMax; // runtime: whether 'max' was present in JSON
        public string @default;  // optional default as text
    }
}

// ===== FILE: Assets/Scripts/Core/Defs/Validation/TypeChecks.cs =====
using System;
using System.Globalization;

namespace FantasyColony.Core.Defs.Validation {
    internal static class TypeChecks {
        public static (bool ok, string err) Check(FieldSpec fs, string value, Defs.DefIndex index) {
            var t = (fs.type ?? "string").ToLowerInvariant();
            switch (t) {
                case "string": return CheckString(value, fs);
                case "id":     return CheckId(value);
                case "int":    return CheckInt(value, fs);
                case "float":  return CheckFloat(value, fs);
                case "bool":   return CheckBool(value);
                case "color":  return CheckColor(value);
                case "enum":   return CheckEnum(value, fs);
                case "defref": return CheckDefRef(value, fs, index);
                case "list":   return (true, null); // future: validate list items
                default:        return (true, null);
            }
        }

        private static (bool,string) CheckString(string v, FieldSpec fs) {
            if (v == null) return (false, "missing string");
            if (fs.minLength > 0 && v.Length < fs.minLength) return (false, $"string too short (min {fs.minLength})");
            return (true, null);
        }
        private static (bool,string) CheckId(string v) {
            if (string.IsNullOrEmpty(v)) return (false, "missing id");
            return (FantasyColony.Core.Defs.DefId.TryParse(v, out _)) ? (true, null) : (false, "id not well-formed");
        }
        private static (bool,string) CheckInt(string v, FieldSpec fs) {
            if (!int.TryParse(v, NumberStyles.Integer, CultureInfo.InvariantCulture, out var i)) return (false, "not an int");
            if (fs.hasMin && i < fs.min) return (false, $"int < min {fs.min}");
            if (fs.hasMax && i > fs.max) return (false, $"int > max {fs.max}");
            return (true, null);
        }
        private static (bool,string) CheckFloat(string v, FieldSpec fs) {
            if (!float.TryParse(v, NumberStyles.Float, CultureInfo.InvariantCulture, out var f)) return (false, "not a float");
            if (fs.hasMin && f < fs.min) return (false, $"float < min {fs.min}");
            if (fs.hasMax && f > fs.max) return (false, $"float > max {fs.max}");
            return (true, null);
        }
        private static (bool,string) CheckBool(string v) {
            if (!bool.TryParse(v, out _)) return (false, "not a bool");
            return (true, null);
        }
        private static (bool,string) CheckColor(string v) {
            if (string.IsNullOrEmpty(v)) return (false, "missing color");
            // Accept #RRGGBB or #RRGGBBAA
            if (v.StartsWith("#") && (v.Length == 7 || v.Length == 9)) return (true, null);
            return (false, "color must be #RRGGBB or #RRGGBBAA");
        }
        private static (bool,string) CheckEnum(string v, FieldSpec fs) {
            if (fs.values == null || fs.values.Length == 0) return (true, null);
            for (int i=0;i<fs.values.Length;i++) if (string.Equals(v, fs.values[i], StringComparison.Ordinal)) return (true, null);
            return (false, $"enum value '{v}' not in [{string.Join(",", fs.values)}]");
        }
        private static (bool,string) CheckDefRef(string v, FieldSpec fs, Defs.DefIndex index) {
            if (string.IsNullOrEmpty(v)) return (false, "missing defref");
            string type, id;
            var parts = v.Split('.');
            if (parts.Length == 2) { type = parts[0]; id = parts[1]; }
            else if (parts.Length == 3) { type = parts[1]; id = parts[2]; }
            else return (false, "defref must be Type.Id or modid.Type.Name");
            if (!string.IsNullOrEmpty(fs.target) && !string.Equals(type, fs.target, StringComparison.Ordinal))
                return (false, $"defref type '{type}' expected '{fs.target}'");
            var ok = index.Find(type, id) != null;
            return ok ? (true, null) : (false, $"missing target {type}.{id}");
        }
    }
}

// ===== FILE: Assets/Scripts/Core/Defs/Validation/ValidationMode.cs =====
namespace FantasyColony.Core.Defs.Validation {
    /// <summary>
    /// Controls how strict validation is treated at runtime.
    /// Lenient is default for player builds; Strict is useful in Editor/CI.
    /// </summary>
    public enum ValidationMode {
        Lenient = 0,
        Strict = 1,
    }
}

// ===== FILE: Assets/Scripts/Core/GlobalShortcuts.cs =====
using UnityEngine;
using FantasyColony.UI.Router;
using FantasyColony.UI.Screens;
#if ENABLE_INPUT_SYSTEM
using UnityEngine.InputSystem;
#endif

namespace FantasyColony.Core {
    /// <summary>
    /// Lightweight global hotkeys available in all builds.
    /// F9: Boot Report  |  F10: UI Creator (stub)
    /// </summary>
    public sealed class GlobalShortcuts : MonoBehaviour {
        private void Awake() {
            // Attach to AppHost GameObject; keep across restarts
            DontDestroyOnLoad(gameObject);
        }

        private void Update() {
            // Open Boot Report (F9)
            bool pressed = false;
#if ENABLE_INPUT_SYSTEM
            var kb = Keyboard.current;
            if (kb != null && kb.f9Key.wasPressedThisFrame) pressed = true;
#endif
#if ENABLE_LEGACY_INPUT_MANAGER
            if (!pressed && UnityEngine.Input.GetKeyDown(KeyCode.F9)) pressed = true;
#endif
            if (pressed) {
                var router = UIRouter.Current;
                if (router == null) {
                    // Fallback if static Current isn't set yet
                    var host = AppHost.Instance;
                    router = host != null ? host.Router : null;
                }
                if (router != null) router.Push<BootReportScreen>();
                else Debug.LogWarning("[GlobalShortcuts] No UIRouter available to open Boot Report.");
            }

            // Toggle UI Creator (F10)
            bool toggleCreator = false;
#if ENABLE_INPUT_SYSTEM
            var kb2 = Keyboard.current;
            if (kb2 != null && kb2.f10Key.wasPressedThisFrame) toggleCreator = true;
#endif
#if ENABLE_LEGACY_INPUT_MANAGER
            if (!toggleCreator && UnityEngine.Input.GetKeyDown(KeyCode.F10)) toggleCreator = true;
#endif
            if (toggleCreator) {
                var router = UIRouter.Current;
                if (router == null) {
                    var host = AppHost.Instance;
                    router = host != null ? host.Router : null;
                }
                if (router != null) {
                    if (FantasyColony.UI.Screens.UICreatorScreen.IsOpen) {
                        Debug.Log("[UICreator] F10 pressed -> close Creator");
                        router.Pop();
                    } else {
                        Debug.Log("[UICreator] F10 pressed -> open Creator");
                        router.Push(new FantasyColony.UI.Screens.UICreatorScreen());
                    }
                }
                else Debug.LogWarning("[GlobalShortcuts] No UIRouter available to open UI Creator.");
            }
        }
    }
}

// ===== FILE: Assets/Scripts/Core/Input/InputRouter.cs =====
using UnityEngine;

namespace FantasyColony.Core.Input
{
    /// <summary>
    /// Placeholder router for the new Input System. No-ops if the package is missing.
    /// </summary>
    public static class InputRouter
    {
        public static void EnableMenuMap()
        {
#if ENABLE_INPUT_SYSTEM
            // Hook up your InputActionAsset and enable the UI/menu action map here.
#endif
        }

        public static void DisableAll()
        {
#if ENABLE_INPUT_SYSTEM
            // Disable action maps here.
#endif
        }
    }
}

// ===== FILE: Assets/Scripts/Core/Mods/ModDiscovery.cs =====
using System;
using System.Collections.Generic;
using System.IO;
using UnityEngine;

namespace FantasyColony.Core.Mods
{
    public class ModInfo
    {
        public string id;
        public string path;
        public override string ToString() => id;
    }

    public static class ModDiscovery
    {
        /// <summary>
        /// Discover mods in StreamingAssets/Mods and persistentDataPath/Mods. Non-fatal on errors.
        /// </summary>
        public static List<ModInfo> Discover()
        {
            var list = new List<ModInfo>();
            TryDiscover(Path.Combine(Application.streamingAssetsPath, "Mods"), list);
            TryDiscover(Path.Combine(Application.persistentDataPath, "Mods"), list);
            return list;
        }

        private static void TryDiscover(string root, List<ModInfo> into)
        {
            try
            {
                if (string.IsNullOrEmpty(root) || !Directory.Exists(root)) return;
                foreach (var dir in Directory.GetDirectories(root))
                {
                    var id = Path.GetFileName(dir);
                    into.Add(new ModInfo { id = id, path = dir });
                }
            }
            catch (Exception e)
            {
                Debug.LogWarning($"Mod discovery error at {root}: {e.Message}");
            }
        }
    }
}

// ===== FILE: Assets/Scripts/Core/Mods/XmlDefLoader.cs =====
using System;
using System.Collections.Generic;
using UnityEngine;
using FantasyColony.Core.Services;

namespace FantasyColony.Core.Mods {
    public class DefError {
        public string Path;
        public string Message;
        public override string ToString() => $"{Path}: {Message}";
    }

    /// <summary>
    /// Lenient XML loader: scans *.xml under each mod and registers their root elements by name+id.
    /// </summary>
    public static class XmlDefLoader {
        // Existing signature used by boot pipeline
        public static void Load(List<ModInfo> mods, DefRegistry registry, List<DefError> errors) {
            // current: iterate XML files under each mod's Defs folder, register Type/Id → path
            // note: per-file schema metadata is now collected later by DefIndex for validation/migrations
            foreach (var mod in mods) {
                var dir = System.IO.Path.Combine(mod.path, "Defs");
                if (!System.IO.Directory.Exists(dir)) continue;
                foreach (var file in System.IO.Directory.EnumerateFiles(dir, "*.xml", System.IO.SearchOption.AllDirectories)) {
                    try {
                        using var xr = System.Xml.XmlReader.Create(file, new System.Xml.XmlReaderSettings { IgnoreComments = true, IgnoreWhitespace = true, DtdProcessing = System.Xml.DtdProcessing.Ignore });
                        xr.MoveToContent();
                        var type = xr.Name; // root element name is type
                        var id = xr.GetAttribute("id") ?? string.Empty;
                        if (string.IsNullOrEmpty(id)) {
                            errors?.Add(new DefError { Path = file, Message = $"Missing id for type '{type}'" });
                            continue;
                        }
                        registry.Register(type, id, file, mod.id);
                    } catch (Exception e) {
                        errors?.Add(new DefError { Path = file, Message = e.Message });
                    }
                }
            }
        }
    }
}

// ===== FILE: Assets/Scripts/Core/ServiceRegistry.cs =====
using System;
using System.Collections.Generic;

namespace FantasyColony.Core
{
    public sealed class ServiceRegistry
    {
        private readonly Dictionary<Type, object> _map = new();

        public void Register<T>(T impl) where T : class
        {
            _map[typeof(T)] = impl ?? throw new ArgumentNullException(nameof(impl));
        }

        public T Get<T>() where T : class
        {
            if (_map.TryGetValue(typeof(T), out var o) && o is T t)
                return t;
            throw new InvalidOperationException($"Service not registered: {typeof(T).Name}");
        }

        /// <summary>
        /// Non-throwing lookup for fail-soft flows (player builds).
        /// </summary>
        public bool TryGet<T>(out T service) where T : class
        {
            if (_map.TryGetValue(typeof(T), out var o) && o is T t)
            {
                service = t;
                return true;
            }
            service = null;
            return false;
        }

        /// <summary>
        /// Returns true if a service of type T is registered.
        /// </summary>
        public bool Has<T>() where T : class => _map.ContainsKey(typeof(T));

        /// <summary>
        /// Optional unregistration helper. Returns true if removed.
        /// </summary>
        public bool Unregister<T>() where T : class => _map.Remove(typeof(T));
    }
}

// ===== FILE: Assets/Scripts/Core/Services/AddressablesAssetProvider.cs =====
#if ADDRESSABLES
using UnityEngine;
using UnityEngine.AddressableAssets;
using UnityEngine.ResourceManagement.AsyncOperations;

namespace FantasyColony.Core.Services {
    /// <summary>
    /// Optional Addressables-backed asset provider.
    /// Compiles only when ADDRESSABLES define is present.
    /// </summary>
    public sealed class AddressablesAssetProvider : IAssetProvider {
        private static bool _initialized;

        public static void EnsureInitialized() {
            if (_initialized) return;
            try {
                var h = Addressables.InitializeAsync();
                h.Completed += _ => { _initialized = true; };
            } catch { /* swallow; fail-soft */ }
        }

        public Sprite LoadSprite(string virtualPath) {
            EnsureInitialized();
            return LoadSync<Sprite>(virtualPath);
        }

        public AudioClip LoadAudio(string virtualPath) {
            EnsureInitialized();
            return LoadSync<AudioClip>(virtualPath);
        }

        public TextAsset LoadText(string virtualPath) {
            EnsureInitialized();
            return LoadSync<TextAsset>(virtualPath);
        }

        private static T LoadSync<T>(string key) where T : UnityEngine.Object {
            try {
                AsyncOperationHandle<T> handle = Addressables.LoadAssetAsync<T>(key);
                return handle.WaitForCompletion();
            } catch { return null; }
        }
    }
}
#endif

// ===== FILE: Assets/Scripts/Core/Services/AudioService.cs =====
using System;
using UnityEngine;

namespace FantasyColony.Core.Services
{
    /// <summary>
    /// Lightweight audio bootstrap: one BGM source and one-shot SFX source.
    /// No Addressables; uses Resources for now. Safe no-ops if assets are missing.
    /// </summary>
    public class AudioService : MonoBehaviour
    {
        private static AudioService _instance;
        public static AudioService Instance
        {
            get
            {
                if (_instance == null)
                {
                    var go = new GameObject("__AudioService");
                    DontDestroyOnLoad(go);
                    _instance = go.AddComponent<AudioService>();
                }
                return _instance;
            }
        }

        private AudioSource _bgm;
        private AudioSource _sfx;

        private float _volMaster = 1f, _volMusic = 1f, _volSfx = 1f;

        private void Awake()
        {
            // Duplicate guard: prefer the first instance
            if (_instance != null && _instance != this)
            {
                Destroy(gameObject);
                return;
            }
            _instance = this;

            _bgm = gameObject.AddComponent<AudioSource>();
            _bgm.loop = true;
            _bgm.playOnAwake = false;

            _sfx = gameObject.AddComponent<AudioSource>();
            _sfx.loop = false;
            _sfx.playOnAwake = false;
        }

        public void SetVolume(string channel, float linear01)
        {
            linear01 = Mathf.Clamp01(linear01);
            switch (channel)
            {
                case "master": _volMaster = linear01; break;
                case "music": _volMusic = linear01; break;
                case "sfx": _volSfx = linear01; break;
            }
            ApplyVolumes();
        }

        private void ApplyVolumes()
        {
            if (_bgm != null) _bgm.volume = _volMaster * _volMusic;
            if (_sfx != null) _sfx.volume = _volMaster * _volSfx;
        }

        public void PlayBgm(string resourceKey)
        {
            try
            {
                var clip = Resources.Load<AudioClip>(resourceKey);
                if (clip == null)
                {
                    Debug.LogWarning($"AudioService: BGM not found at Resources/{resourceKey}");
                    return;
                }
                _bgm.clip = clip;
                ApplyVolumes();
                _bgm.Play();
            }
            catch (Exception e)
            {
                Debug.LogWarning($"AudioService PlayBgm error: {e.Message}");
            }
        }

        public void StopBgm()
        {
            if (_bgm != null) _bgm.Stop();
        }

        public void PlaySfx(string resourceKey)
        {
            try
            {
                var clip = Resources.Load<AudioClip>(resourceKey);
                if (clip == null)
                {
                    Debug.LogWarning($"AudioService: SFX not found at Resources/{resourceKey}");
                    return;
                }
                ApplyVolumes();
                _sfx.PlayOneShot(clip);
            }
            catch (Exception e)
            {
                Debug.LogWarning($"AudioService PlaySfx error: {e.Message}");
            }
        }
    }
}

// ===== FILE: Assets/Scripts/Core/Services/DefRegistry.cs =====
using System;
using System.Collections.Generic;
using UnityEngine;

namespace FantasyColony.Core.Services {
    /// <summary>
    /// Definition registry keyed by type then id, storing file path and mod id.
    /// </summary>
    public class DefRegistry {
        private static DefRegistry _instance;
        public static DefRegistry Instance => _instance ?? (_instance = new DefRegistry());

        public struct Entry {
            public string Type;
            public string Id;
            public string Path;
            public string ModId;
        }

        private readonly Dictionary<string, Dictionary<string, Entry>> _map = new(StringComparer.OrdinalIgnoreCase);

        public int Count { get; private set; }
        public int ConflictCount { get; private set; }

        public void Register(string type, string id, string filePath, string modId) {
            if (string.IsNullOrEmpty(type) || string.IsNullOrEmpty(id)) return;
            if (!_map.TryGetValue(type, out var inner)) {
                inner = new Dictionary<string, Entry>(StringComparer.OrdinalIgnoreCase);
                _map[type] = inner;
            }
            if (inner.TryGetValue(id, out var existing)) {
                ConflictCount++;
                Debug.LogWarning($"[Defs] Conflict for {type}/{id}: {existing.ModId} -> {modId} (file: {filePath})");
            }
            else { Count++; }
            inner[id] = new Entry { Type = type, Id = id, Path = filePath ?? string.Empty, ModId = modId };
        }

        // Legacy Add signature for backward compatibility
        public void Add(string type, string id, string filePath) => Register(type, id, filePath, string.Empty);

        public bool TryGetPath(string type, string id, out string path) {
            path = null;
            if (string.IsNullOrEmpty(type) || string.IsNullOrEmpty(id)) return false;
            if (_map.TryGetValue(type, out var inner) && inner.TryGetValue(id, out var e)) {
                path = e.Path;
                return true;
            }
            return false;
        }

        public IEnumerable<Entry> All() {
            foreach (var inner in _map.Values)
                foreach (var e in inner.Values)
                    yield return e;
        }

        public IEnumerable<string> Types() => _map.Keys;

        public IEnumerable<string> Ids(string type) {
            if (_map.TryGetValue(type, out var inner)) return inner.Keys;
            return Array.Empty<string>();
        }
    }
}

// ===== FILE: Assets/Scripts/Core/Services/IAssetProvider.cs =====
using UnityEngine;

namespace FantasyColony.Core.Services
{
    public interface IAssetProvider
    {
        Sprite LoadSprite(string virtualPath);
        AudioClip LoadAudio(string virtualPath);
        TextAsset LoadText(string virtualPath);
    }

    public sealed class ResourcesAssetProvider : IAssetProvider
    {
        public Sprite LoadSprite(string virtualPath)
        {
            return Resources.Load<Sprite>(virtualPath);
        }

        public AudioClip LoadAudio(string virtualPath)
        {
            return Resources.Load<AudioClip>(virtualPath);
        }

        public TextAsset LoadText(string virtualPath)
        {
            return Resources.Load<TextAsset>(virtualPath);
        }
    }
}

// ===== FILE: Assets/Scripts/Core/Services/IConfigService.cs =====
namespace FantasyColony.Core.Services
{
    public interface IConfigService
    {
        string Get(string key, string fallback = "");
        void Set(string key, string value);
        void Save();
    }

    /// <summary>
    /// Minimal no-op config for early boot. Replace later with a JSON-backed service.
    /// </summary>
    public sealed class DummyConfigService : IConfigService
    {
        public string Get(string key, string fallback = "") => fallback;
        public void Set(string key, string value) { }
        public void Save() { }
    }
}

// ===== FILE: Assets/Scripts/Core/Services/IEventBus.cs =====
using System;
using System.Collections.Generic;

namespace FantasyColony.Core.Services
{
    public interface IEventBus
    {
        void Subscribe<T>(Action<T> handler);
        void Unsubscribe<T>(Action<T> handler);
        void Publish<T>(T evt);
    }

    public sealed class SimpleEventBus : IEventBus
    {
        private readonly Dictionary<Type, Delegate> _subs = new();

        public void Subscribe<T>(Action<T> handler)
        {
            if (_subs.TryGetValue(typeof(T), out var d))
                _subs[typeof(T)] = Delegate.Combine(d, handler);
            else
                _subs[typeof(T)] = handler;
        }

        public void Unsubscribe<T>(Action<T> handler)
        {
            if (_subs.TryGetValue(typeof(T), out var d))
            {
                var res = Delegate.Remove(d, handler);
                if (res == null) _subs.Remove(typeof(T));
                else _subs[typeof(T)] = res;
            }
        }

        public void Publish<T>(T evt)
        {
            if (_subs.TryGetValue(typeof(T), out var d) && d is Action<T> a)
            {
                a.Invoke(evt);
            }
        }
    }
}

// ===== FILE: Assets/Scripts/Core/Services/ILogger.cs =====
using System;
using System.IO;
using UnityEngine;

namespace FantasyColony.Core.Services
{
    public interface ILogger
    {
        void Info(string msg);
        void Warn(string msg);
        void Error(string msg, Exception ex = null);
    }

    public sealed class FileLogger : ILogger
    {
        private readonly string _path;

        public FileLogger()
        {
            var dir = Path.Combine(UnityEngine.Application.persistentDataPath, "logs");
            if (!Directory.Exists(dir)) Directory.CreateDirectory(dir);
            _path = Path.Combine(dir, $"log_{DateTime.Now:yyyyMMdd_HHmmss}.txt");
            Info($"FantasyColony boot {UnityEngine.Application.version} Unity {UnityEngine.Application.unityVersion}");
        }

        public void Info(string msg)
        {
            Debug.Log(msg);
            Append("INFO", msg);
        }

        public void Warn(string msg)
        {
            Debug.LogWarning(msg);
            Append("WARN", msg);
        }

        public void Error(string msg, Exception ex = null)
        {
            Debug.LogError(msg);
            if (ex != null) msg += "\n" + ex;
            Append("ERROR", msg);
        }

        private void Append(string level, string msg)
        {
            try
            {
                File.AppendAllText(_path, $"[{DateTime.Now:HH:mm:ss}] {level} {msg}\n");
            }
            catch { /* ignore logging failures */ }
        }
    }
}

// ===== FILE: Assets/Scripts/Core/Services/JsonConfigService.cs =====
using System;
using System.Collections.Generic;
using System.IO;
using UnityEngine;

namespace FantasyColony.Core.Services
{
    /// <summary>
    /// Minimal JSON-backed config service with string Get/Set to avoid API churn.
    /// </summary>
    public class JsonConfigService : IConfigService
    {
        private static JsonConfigService _instance;
        public static JsonConfigService Instance => _instance ?? (_instance = new JsonConfigService());

        private readonly Dictionary<string, string> _map = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
        private string Path => System.IO.Path.Combine(Application.persistentDataPath, "config.json");

        public void Load()
        {
            try
            {
                if (!File.Exists(Path)) return;
                var json = File.ReadAllText(Path);
                var data = JsonUtility.FromJson<Bag>(json);
                _map.Clear();
                if (data != null && data.keys != null)
                {
                    for (int i = 0; i < data.keys.Length; i++)
                    {
                        var k = data.keys[i];
                        var v = (data.values != null && i < data.values.Length) ? data.values[i] : string.Empty;
                        if (!string.IsNullOrEmpty(k)) _map[k] = v ?? string.Empty;
                    }
                }
            }
            catch (Exception e)
            {
                Debug.LogWarning($"JsonConfigService load error: {e.Message}");
            }
        }

        public void Save()
        {
            try
            {
                var bag = new Bag
                {
                    keys = new string[_map.Count],
                    values = new string[_map.Count]
                };
                int idx = 0;
                foreach (var kv in _map)
                {
                    bag.keys[idx] = kv.Key;
                    bag.values[idx] = kv.Value;
                    idx++;
                }
                var json = JsonUtility.ToJson(bag, true);
                var dir = System.IO.Path.GetDirectoryName(Path);
                if (!string.IsNullOrEmpty(dir)) Directory.CreateDirectory(dir);
                var tmp = Path + ".tmp";
                try
                {
                    File.WriteAllText(tmp, json);
                    // Atomic replace when available (PC platforms)
#if UNITY_2021_2_OR_NEWER
                    var bak = Path + ".bak";
                    File.Replace(tmp, Path, bak, true);
#else
                    // Fallback: best-effort replace
                    if (File.Exists(Path)) File.Delete(Path);
                    File.Move(tmp, Path);
#endif
                }
                finally { if (File.Exists(tmp)) { try { File.Delete(tmp); } catch { } } }
            }
            catch (Exception e)
            {
                Debug.LogWarning($"JsonConfigService save error: {e.Message}");
            }
        }

        public string Get(string key, string fallback = "")
        {
            if (string.IsNullOrEmpty(key)) return fallback;
            return _map.TryGetValue(key, out var v) ? v : fallback;
        }

        public FantasyColony.Core.Defs.Validation.ValidationMode GetValidationMode()
        {
            var s = Get("validation_mode", "lenient").ToLowerInvariant();
            return (s == "strict") ? FantasyColony.Core.Defs.Validation.ValidationMode.Strict : FantasyColony.Core.Defs.Validation.ValidationMode.Lenient;
        }

        public void Set(string key, string value) {
            _map[key] = value ?? string.Empty;
            // Optional: persist to disk here if desired.
        }

        [Serializable]
        private class Bag
        {
            public string[] keys;
            public string[] values;
        }
    }
}

// ===== FILE: Assets/Scripts/Core/Services/JsonSaveService.cs =====
using System;
using System.Collections.Generic;
using System.IO;
using System.Globalization;
using UnityEngine;

namespace FantasyColony.Core.Services
{
    public struct SaveSlotMeta
    {
        public string slotId;
        public string displayName;
        public DateTime lastPlayedUtc;
        public string version;
    }

    /// <summary>
    /// Skeleton save service: only reads metadata from disk so the Main Menu can react.
    /// </summary>
    public class JsonSaveService
    {
        private static JsonSaveService _instance;
        public static JsonSaveService Instance => _instance ?? (_instance = new JsonSaveService());

        private readonly List<SaveSlotMeta> _cache = new List<SaveSlotMeta>();
        public IReadOnlyList<SaveSlotMeta> Slots => _cache;

        private string Root => Path.Combine(Application.persistentDataPath, "saves");

        public void RefreshCache()
        {
            _cache.Clear();
            try
            {
                if (!Directory.Exists(Root)) return;
                foreach (var dir in Directory.GetDirectories(Root))
                {
                    var slotId = Path.GetFileName(dir);
                    var metaPath = Path.Combine(dir, "meta.json");
                    if (!File.Exists(metaPath)) continue;
                    try
                    {
                        var json = File.ReadAllText(metaPath);
                        var meta = JsonUtility.FromJson<SlotBag>(json) ?? new SlotBag();
                        var when = DateTimeOffset.TryParseExact(meta.lastPlayedUtc, "O", CultureInfo.InvariantCulture, DateTimeStyles.AssumeUniversal, out var dto)
                            ? dto.UtcDateTime : DateTime.UtcNow;
                        _cache.Add(new SaveSlotMeta
                        {
                            slotId = slotId,
                            displayName = string.IsNullOrEmpty(meta.displayName) ? slotId : meta.displayName,
                            lastPlayedUtc = when,
                            version = meta.version ?? "unknown"
                        });
                    }
                    catch (Exception e)
                    {
                        Debug.LogWarning($"Bad save meta in {dir}: {e.Message}");
                    }
                }
                _cache.Sort((a, b) => b.lastPlayedUtc.CompareTo(a.lastPlayedUtc));
            }
            catch (Exception e)
            {
                Debug.LogWarning($"Save discovery error: {e.Message}");
            }
        }

        public bool HasAnySaves() => _cache.Count > 0;

        [Serializable]
        private class SlotBag
        {
            public string displayName;
            public string lastPlayedUtc;
            public string version;
        }
    }
}

// ===== FILE: Assets/Scripts/Core/Services/LocService.cs =====
using System;
using System.Collections.Generic;
using UnityEngine;
using FantasyColony.Core;

namespace FantasyColony.Core.Services
{
    /// <summary>
    /// Minimal localization service. Loads Resources/Localization/{lang}/strings.json (TextAsset).
    /// Falls back to English or the key itself.
    /// </summary>
    public class LocService
    {
        private static LocService _instance;
        public static LocService Instance => _instance ?? (_instance = new LocService());

        private readonly Dictionary<string, string> _map = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
        public string Language { get; private set; } = "en";

        public void SetLanguage(string lang)
        {
            Language = string.IsNullOrEmpty(lang) ? "en" : lang;
            Load(Language);
        }

        public string Get(string key)
        {
            if (string.IsNullOrEmpty(key)) return string.Empty;
            return _map.TryGetValue(key, out var v) ? v : key;
        }

        private void Load(string lang)
        {
            _map.Clear();
            // Try target language
            if (!TryLoadInto(lang))
            {
                // Fallback to English
                if (!string.Equals(lang, "en", StringComparison.OrdinalIgnoreCase))
                {
                    TryLoadInto("en");
                }
            }
        }

        private bool TryLoadInto(string lang)
        {
            try
            {
                var path = $"Localization/{lang}/strings";
                TextAsset ta = null;
                // Prefer provider if available (mod- and backend-friendly)
                var host = AppHost.Instance;
                if (host != null && host.Services != null && host.Services.TryGet<IAssetProvider>(out var provider))
                {
                    ta = provider.LoadText(path);
                }
                // Fallback to Resources for safety
                if (ta == null)
                {
                    ta = Resources.Load<TextAsset>(path);
                }
                if (ta == null) return false;
                var bag = JsonUtility.FromJson<LocBag>(ta.text);
                if (bag?.entries != null)
                {
                    foreach (var e in bag.entries)
                    {
                        if (!string.IsNullOrEmpty(e.key)) _map[e.key] = e.value ?? string.Empty;
                    }
                }
                return true;
            }
            catch (Exception e)
            {
                Debug.LogWarning($"LocService load error: {e.Message}");
                return false;
            }
        }

        [Serializable]
        private class LocBag
        {
            public Entry[] entries;
        }

        [Serializable]
        private class Entry
        {
            public string key;
            public string value;
        }
    }
}

// ===== FILE: Assets/Scripts/Dev/DevLogOverlay.cs =====
using System;
using System.Collections.Generic;
using System.Collections.Concurrent;
using System.Text;
using System.Threading;
using UnityEngine;
//#if is allowed to safely reference the new Input System only when present
#if ENABLE_INPUT_SYSTEM
using UnityEngine.InputSystem;
#endif

/// <summary>
/// Lightweight, robust in-game developer log overlay.
/// - Captures all Unity logs via Application.logMessageReceivedThreaded
/// - Thread-safe queue -> main-thread list with ring buffer cap
/// - IMGUI-based so it works without any prefabs/scenes
/// - Filters (Debug/Warning/Errors), Pause, Auto-scroll, Stack Traces
/// - Copy Visible respects current filters
/// </summary>
public class DevLogOverlay : MonoBehaviour
{
    [Serializable]
    public struct LogEntry
    {
        public DateTime time;
        public int frame;
        public int threadId;
        public LogType type;
        public string message;
        public string stackTrace; // may be empty based on policy
        public string contextName; // optional
        public int count; // number of additional consecutive occurrences collapsed into this entry
    }

    private struct QueuedLog
    {
        public DateTime time;
        public int threadId;
        public LogType type;
        public string message;
        public string stackTrace;
        public string contextName;
    }

    private const int DefaultCapacity = 5000;
    private const int WindowPadding = 8;

    private static DevLogOverlay _instance;
    private static readonly object InstanceLock = new object();

    // Threaded producer -> main thread consumer
    private readonly ConcurrentQueue<QueuedLog> _incoming = new ConcurrentQueue<QueuedLog>();
    private readonly List<LogEntry> _entries = new List<LogEntry>(DefaultCapacity + 64);

    [Header("Buffer")]
    [Tooltip("Maximum number of entries kept in memory (oldest are dropped).")]
    public int capacity = DefaultCapacity;

    [Header("Filters")]
    public bool showDebug = true;
    public bool showWarnings = true;
    public bool showErrors = true; // includes Error, Assert, Exception

    [Header("Behavior")]
    public bool paused = false;
    public bool autoScroll = true;
    public bool showStackTraces = false; // toggles display; capture is controlled by Unity's stack trace policy
    public bool collapseRepeats = true; // when true, consecutive identical messages are collapsed

    private Vector2 _scroll;
    private bool _visible = true;
    private Rect _windowRect;
    private int _dockedCorner = 2; // 0=TL,1=TR,2=BL,3=BR

    private GUIStyle _rowStyle;
    private GUIStyle _rowStyleWarn;
    private GUIStyle _rowStyleError;
    private GUIStyle _tinyLabel;

    private string _search = "";
    private bool _focusSearch;

    // ---------- Public API ----------
    public static void Show()
    {
        EnsureInstance();
        _instance._visible = true;
    }

    public static void Hide()
    {
        if (_instance != null) _instance._visible = false;
    }

    public static void ToggleVisible()
    {
        EnsureInstance();
        _instance._visible = !_instance._visible;
    }

    public static bool IsVisible => _instance != null && _instance._visible;

    public static void Clear()
    {
        if (_instance == null) return;
        _instance._entries.Clear();
    }

    public static IReadOnlyList<LogEntry> Snapshot()
    {
        EnsureInstance();
        return _instance._entries;
    }

    private static void EnsureInstance()
    {
        if (_instance != null) return;
        lock (InstanceLock)
        {
            if (_instance != null) return;
            var go = new GameObject("__DevLogOverlay");
            DontDestroyOnLoad(go);
            _instance = go.AddComponent<DevLogOverlay>();
        }
    }

    // ---------- Unity lifecycle ----------
    private void Awake()
    {
        // Reasonable defaults: errors/exceptions include stacks; others off for perf until toggled
        try
        {
            Application.SetStackTraceLogType(LogType.Log, StackTraceLogType.None);
            Application.SetStackTraceLogType(LogType.Warning, StackTraceLogType.None);
            Application.SetStackTraceLogType(LogType.Error, StackTraceLogType.ScriptOnly);
            Application.SetStackTraceLogType(LogType.Assert, StackTraceLogType.ScriptOnly);
            Application.SetStackTraceLogType(LogType.Exception, StackTraceLogType.ScriptOnly);
        }
        catch { /* Some platforms may not support changing this at runtime */ }

        // Sensible default window size
        var w = Mathf.RoundToInt(Screen.width * 0.6f);
        var h = Mathf.RoundToInt(Screen.height * 0.5f);
        _windowRect = new Rect(WindowPadding, Screen.height - h - WindowPadding, w, h);
    }

    private void OnEnable()
    {
        Application.logMessageReceivedThreaded += OnLogMessageReceivedThreaded;
    }

    private void OnDisable()
    {
        Application.logMessageReceivedThreaded -= OnLogMessageReceivedThreaded;
    }

    private void Update()
    {
        // Drain queue to main-thread list
        while (_incoming.TryDequeue(out var q))
        {
            var e = new LogEntry
            {
                time = q.time,
                frame = Time.frameCount,
                threadId = q.threadId,
                type = q.type,
                message = q.message ?? string.Empty,
                stackTrace = q.stackTrace ?? string.Empty,
                contextName = q.contextName ?? string.Empty
            };

            if (!paused)
            {
                if (collapseRepeats && _entries.Count > 0)
                {
                    var lastIndex = _entries.Count - 1;
                    var lastEntry = _entries[lastIndex];
                    if (AreSameForCollapse(lastEntry, e))
                    {
                        lastEntry.count = lastEntry.count + 1;
                        // keep the most recent time/frame/thread for the collapsed line
                        lastEntry.time = e.time;
                        lastEntry.frame = e.frame;
                        lastEntry.threadId = e.threadId;
                        _entries[lastIndex] = lastEntry;
                    }
                    else
                    {
                        _entries.Add(e);
                    }
                }
                else
                {
                    _entries.Add(e);
                }

                if (_entries.Count > Mathf.Max(512, capacity))
                {
                    var over = _entries.Count - capacity;
                    _entries.RemoveRange(0, over);
                }
            }
        }

        // Handle hotkeys without throwing when only the new Input System is active
        HandleHotkeys();
    }

    private void OnGUI()
    {
        if (!_visible) return;

        EnsureStyles();

        // Simple draggable/dockable window
        _windowRect = GUI.Window(GetInstanceID(), _windowRect, DrawWindow, "Developer Log");

        // Keep inside screen
        _windowRect.x = Mathf.Clamp(_windowRect.x, WindowPadding, Screen.width - _windowRect.width - WindowPadding);
        _windowRect.y = Mathf.Clamp(_windowRect.y, WindowPadding, Screen.height - _windowRect.height - WindowPadding);
    }

    private void DrawWindow(int id)
    {
        GUILayout.BeginHorizontal();
        if (GUILayout.Button(paused ? "Resume" : "Pause", GUILayout.Height(24))) paused = !paused;
        if (GUILayout.Button("Clear", GUILayout.Height(24))) _entries.Clear();
        if (GUILayout.Button("Copy Visible", GUILayout.Height(24))) CopyVisibleToClipboard();
        if (GUILayout.Button("Close", GUILayout.Height(24))) _visible = false;
        GUILayout.FlexibleSpace();
        autoScroll = GUILayout.Toggle(autoScroll, "Auto-Scroll", GUILayout.Height(24));
        showStackTraces = GUILayout.Toggle(showStackTraces, "Stack Traces", GUILayout.Height(24));
        collapseRepeats = GUILayout.Toggle(collapseRepeats, "Collapse Repeats", GUILayout.Height(24));
        GUILayout.EndHorizontal();

        GUILayout.Space(4);

        GUILayout.BeginHorizontal();
        showDebug = GUILayout.Toggle(showDebug, "Debug", GUILayout.Width(80));
        showWarnings = GUILayout.Toggle(showWarnings, "Warning", GUILayout.Width(90));
        showErrors = GUILayout.Toggle(showErrors, "Errors", GUILayout.Width(80));

        GUILayout.Space(10);
        GUILayout.Label("Search:", GUILayout.Width(50));
        GUI.SetNextControlName("DevLogSearch");
        _search = GUILayout.TextField(_search ?? string.Empty, GUILayout.MinWidth(120));
        if (_focusSearch)
        {
            _focusSearch = false;
            GUI.FocusControl("DevLogSearch");
        }
        if (GUILayout.Button("×", GUILayout.Width(26))) { _search = string.Empty; GUI.FocusControl(null); }

        GUILayout.FlexibleSpace();
        if (GUILayout.Button("Dock", GUILayout.Width(60))) CycleDock();
        GUILayout.EndHorizontal();

        GUILayout.Space(4);

        // Header line
        GUILayout.BeginHorizontal();
        GUILayout.Label("Time", _tinyLabel, GUILayout.Width(90));
        GUILayout.Label("F", _tinyLabel, GUILayout.Width(36));
        GUILayout.Label("T", _tinyLabel, GUILayout.Width(28));
        GUILayout.Label("Level", _tinyLabel, GUILayout.Width(60));
        GUILayout.Label("Message", _tinyLabel);
        GUILayout.EndHorizontal();

        // List
        _scroll = GUILayout.BeginScrollView(_scroll, GUI.skin.box);

        var countBefore = _entries.Count;
        for (int i = 0; i < _entries.Count; i++)
        {
            var e = _entries[i];
            if (!PassesFilter(e)) continue;
            if (!PassesSearch(e)) continue;

            var style = StyleFor(e.type);
            GUILayout.BeginHorizontal();
            GUILayout.Label(e.time.ToString("HH:mm:ss.fff"), _tinyLabel, GUILayout.Width(90));
            GUILayout.Label(e.frame.ToString(), _tinyLabel, GUILayout.Width(36));
            GUILayout.Label(e.threadId.ToString(), _tinyLabel, GUILayout.Width(28));
            GUILayout.Label(LevelLabel(e.type), _tinyLabel, GUILayout.Width(60));
            if (e.count > 0)
            {
                // Show message with (xN) suffix for collapsed duplicates
                GUILayout.Label(string.Concat(e.message, " (x", (e.count + 1).ToString(), ")"), style);
            }
            else
            {
                GUILayout.Label(e.message, style);
            }
            GUILayout.EndHorizontal();

            if (showStackTraces && HasStack(e))
            {
                GUILayout.BeginHorizontal();
                GUILayout.Space(90 + 36 + 28 + 60 + 8);
                GUILayout.Label(e.stackTrace, GUI.skin.label);
                GUILayout.EndHorizontal();
            }
        }

        if (autoScroll && Event.current.type == EventType.Repaint)
        {
            _scroll.y = float.MaxValue;
        }

        GUILayout.EndScrollView();

        GUI.DragWindow(new Rect(0, 0, 10000, 20));
    }

    private void EnsureStyles()
    {
        if (_rowStyle == null)
        {
            _rowStyle = new GUIStyle(GUI.skin.label) { wordWrap = true };
            _rowStyleWarn = new GUIStyle(_rowStyle);
            _rowStyleError = new GUIStyle(_rowStyle);

            // Colorize severities for quick scanning
            _rowStyleWarn.normal.textColor = Color.yellow; // Warnings
            _rowStyleError.normal.textColor = Color.red;   // Errors/Exceptions/Asserts

            _tinyLabel = new GUIStyle(GUI.skin.label)
            {
                fontSize = 10,
                alignment = TextAnchor.UpperLeft
            };
        }
    }

    private void HandleHotkeys()
    {
#if ENABLE_INPUT_SYSTEM && !ENABLE_LEGACY_INPUT_MANAGER
        var kb = Keyboard.current;
        if (kb != null)
        {
            if (kb.f9Key.wasPressedThisFrame) ToggleVisible();
            if (kb.f10Key.wasPressedThisFrame) paused = !paused;
        }
#else
        if (Input.GetKeyDown(KeyCode.F9)) ToggleVisible();
        if (Input.GetKeyDown(KeyCode.F10)) paused = !paused;
#endif
    }

    private void CycleDock()
    {
        _dockedCorner = (_dockedCorner + 1) % 4;

        var w = _windowRect.width;
        var h = _windowRect.height;

        switch (_dockedCorner)
        {
            case 0: _windowRect.position = new Vector2(WindowPadding, WindowPadding); break; // TL
            case 1: _windowRect.position = new Vector2(Screen.width - w - WindowPadding, WindowPadding); break; // TR
            case 2: _windowRect.position = new Vector2(WindowPadding, Screen.height - h - WindowPadding); break; // BL
            case 3: _windowRect.position = new Vector2(Screen.width - w - WindowPadding, Screen.height - h - WindowPadding); break; // BR
        }
    }

    private GUIStyle StyleFor(LogType t)
    {
        switch (t)
        {
            case LogType.Warning: return _rowStyleWarn;
            case LogType.Error:
            case LogType.Assert:
            case LogType.Exception: return _rowStyleError;
            default: return _rowStyle;
        }
    }

    private static string LevelLabel(LogType t)
    {
        switch (t)
        {
            case LogType.Warning: return "WARN";
            case LogType.Error: return "ERROR";
            case LogType.Assert: return "ASSERT";
            case LogType.Exception: return "EXC";
            default: return "DEBUG";
        }
    }

    private static bool HasStack(in LogEntry e)
    {
        if (string.IsNullOrEmpty(e.stackTrace)) return false;
        // Many non-error logs have empty stack due to policy; only render if provided
        return true;
    }

    private bool PassesFilter(in LogEntry e)
    {
        switch (e.type)
        {
            case LogType.Warning: return showWarnings;
            case LogType.Error:
            case LogType.Assert:
            case LogType.Exception: return showErrors;
            default: return showDebug;
        }
    }

    private bool PassesSearch(in LogEntry e)
    {
        if (string.IsNullOrEmpty(_search)) return true;
        var s = _search.Trim();
        if (s.Length == 0) return true;
        return (e.message?.IndexOf(s, StringComparison.OrdinalIgnoreCase) ?? -1) >= 0
            || (e.stackTrace?.IndexOf(s, StringComparison.OrdinalIgnoreCase) ?? -1) >= 0
            || (e.contextName?.IndexOf(s, StringComparison.OrdinalIgnoreCase) ?? -1) >= 0;
    }

    private void CopyVisibleToClipboard()
    {
        var sb = new StringBuilder(8192);
        foreach (var e in _entries)
        {
            if (!PassesFilter(e)) continue;
            if (!PassesSearch(e)) continue;

            sb.Append('[').Append(e.time.ToString("HH:mm:ss.fff")).Append("] ");
            sb.Append("F=").Append(e.frame).Append(' ');
            sb.Append("T=").Append(e.threadId).Append(' ');
            sb.Append('[').Append(LevelLabel(e.type)).Append("] ");
            if (!string.IsNullOrEmpty(e.contextName))
            {
                sb.Append('{').Append(e.contextName).Append("} ");
            }
            if (e.count > 0)
            {
                sb.Append(e.message ?? string.Empty).Append(" (x").Append((e.count + 1).ToString()).AppendLine(")");
            }
            else
            {
                sb.AppendLine(e.message ?? string.Empty);
            }

            if (showStackTraces && HasStack(e))
            {
                sb.AppendLine(e.stackTrace);
            }
        }

        GUIUtility.systemCopyBuffer = sb.ToString();
    }

    private static bool AreSameForCollapse(in LogEntry a, in LogEntry b)
    {
        if (a.type != b.type) return false;
        if (!string.Equals(a.message, b.message, StringComparison.Ordinal)) return false;
        if (!string.Equals(a.stackTrace, b.stackTrace, StringComparison.Ordinal)) return false;
        if (!string.Equals(a.contextName, b.contextName, StringComparison.Ordinal)) return false;
        return true;
    }

    private void OnLogMessageReceivedThreaded(string condition, string stacktrace, LogType type)
    {
        var q = new QueuedLog
        {
            time = DateTime.Now,
            threadId = Thread.CurrentThread.ManagedThreadId,
            type = type,
            message = condition,
            stackTrace = stacktrace,
            contextName = string.Empty
        };
        _incoming.Enqueue(q);
    }
}

// Optional convenience for code callers (e.g., MainMenuScreen) without adding compile-time dependency on UnityEngine.UI
public static class DevLog
{
    public static void Show() => DevLogOverlay.Show();
    public static void Hide() => DevLogOverlay.Hide();
    public static void Toggle() => DevLogOverlay.ToggleVisible();
    public static void Clear() => DevLogOverlay.Clear();
}




// ===== FILE: Assets/Scripts/Dev/OpenDevLogButton.cs =====
using UnityEngine;
using UnityEngine.UI;

/// <summary>
/// Attach this to the Main Menu "Log" button to open/close the Dev Log overlay.
/// Keeps scene/prefab changes minimal and avoids coupling to MainMenuScreen implementation.
/// </summary>
[RequireComponent(typeof(Button))]
public class OpenDevLogButton : MonoBehaviour
{
    [Tooltip("Button that will toggle the Dev Log overlay. If left empty, this component will use the Button on the same GameObject.")]
    public Button button;

    [Tooltip("If true, the overlay will open (Show) instead of toggling when clicked.")]
    public bool openOnly = false;

    private void Reset()
    {
        if (button == null) button = GetComponent<Button>();
    }

    private void Awake()
    {
        if (button == null) button = GetComponent<Button>();
        if (button != null)
        {
            button.onClick.AddListener(OnClick);
        }
    }

    private void OnDestroy()
    {
        if (button != null)
            button.onClick.RemoveListener(OnClick);
    }

    private void OnClick()
    {
        if (openOnly) DevLogOverlay.Show(); else DevLogOverlay.ToggleVisible();
    }
}

// ===== FILE: Assets/Scripts/UI/Creator/Editing/GridPrefs.cs =====
using UnityEngine;

namespace FantasyColony.UI.Creator.Editing
{
    /// <summary>
    /// Global grid/snapping preferences for the Creator. Runtime-only.
    /// </summary>
    public static class GridPrefs
    {
        public static bool SnapEnabled = true;
        public static bool GridVisible = true;
        public static int CellSize = 16; // pixels

        public static int CycleCellSize()
        {
            CellSize = CellSize == 8 ? 16 : CellSize == 16 ? 32 : 8;
            Debug.Log($"[UICreator] Grid size = {CellSize}");
            return CellSize;
        }
    }
}


// ===== FILE: Assets/Scripts/UI/Creator/Editing/InstructionDialog.cs =====
using UnityEngine;
using UnityEngine.UI;
using FantasyColony.UI.Widgets;

namespace FantasyColony.UI.Creator.Editing
{
    /// <summary>
    /// Runtime-built modal dialog to attach instructions to the selected item.
    /// </summary>
    public static class InstructionDialog
    {
        public static void Show(RectTransform parent, RectTransform target)
        {
            if (parent == null || target == null) { Debug.LogWarning("[UICreator] InstructionDialog missing parent/target"); return; }

            // Blocker overlay
            var overlayGO = new GameObject("InstructionDialog", typeof(RectTransform), typeof(Image));
            var overlay = overlayGO.GetComponent<RectTransform>();
            overlay.SetParent(parent, false);
            overlay.anchorMin = Vector2.zero; overlay.anchorMax = Vector2.one; overlay.pivot = new Vector2(0.5f, 0.5f);
            overlay.offsetMin = overlay.offsetMax = Vector2.zero;
            var blocker = overlayGO.GetComponent<Image>();
            blocker.color = new Color(0, 0, 0, 0.5f);
            blocker.raycastTarget = true;

            // Panel
            var panelGO = UIFactory.CreatePanelSurface(overlay, "Instructions", sizing: PanelSizing.AutoHeight);
            var panel = panelGO.GetComponent<RectTransform>();
            panel.anchorMin = panel.anchorMax = new Vector2(0.5f, 0.5f);
            panel.pivot = new Vector2(0.5f, 0.5f);
            panel.sizeDelta = new Vector2(520, 360);

            // Title
            var titleGO = new GameObject("Title", typeof(RectTransform), typeof(Text));
            var titleRT = titleGO.GetComponent<RectTransform>();
            titleRT.SetParent(panel, false);
            titleRT.anchorMin = new Vector2(0, 1); titleRT.anchorMax = new Vector2(1, 1); titleRT.pivot = new Vector2(0.5f, 1f);
            titleRT.offsetMin = new Vector2(16, -40); titleRT.offsetMax = new Vector2(-16, -8);
            var title = titleGO.GetComponent<Text>();
            title.alignment = TextAnchor.MiddleLeft;
            title.text = "Instructions";

            // Input background
            var inputBG = new GameObject("InputBG", typeof(RectTransform), typeof(Image));
            var inputBGRT = inputBG.GetComponent<RectTransform>();
            inputBGRT.SetParent(panel, false);
            inputBGRT.anchorMin = new Vector2(0, 0); inputBGRT.anchorMax = new Vector2(1, 1); inputBGRT.pivot = new Vector2(0.5f, 0.5f);
            inputBGRT.offsetMin = new Vector2(16, 64); inputBGRT.offsetMax = new Vector2(-16, 64);

            // Input field
            var inputGO = new GameObject("Input", typeof(RectTransform), typeof(Image), typeof(InputField));
            var inputRT = inputGO.GetComponent<RectTransform>();
            inputRT.SetParent(panel, false);
            inputRT.anchorMin = new Vector2(0, 0); inputRT.anchorMax = new Vector2(1, 1); inputRT.pivot = new Vector2(0.5f, 0.5f);
            inputRT.offsetMin = new Vector2(16, 64); inputRT.offsetMax = new Vector2(-16, 96);
            var inputImg = inputGO.GetComponent<Image>(); inputImg.raycastTarget = true;
            var field = inputGO.GetComponent<InputField>();
            field.lineType = InputField.LineType.MultiLineNewline;

            // Text components for InputField
            var textGO = new GameObject("Text", typeof(RectTransform), typeof(Text));
            var textRT = textGO.GetComponent<RectTransform>();
            textRT.SetParent(inputGO.transform, false);
            textRT.anchorMin = new Vector2(0, 0); textRT.anchorMax = new Vector2(1, 1); textRT.pivot = new Vector2(0.5f, 0.5f);
            textRT.offsetMin = new Vector2(8, 8); textRT.offsetMax = new Vector2(-8, -8);
            var text = textGO.GetComponent<Text>();
            text.alignment = TextAnchor.UpperLeft;
            field.textComponent = text;

            var phGO = new GameObject("Placeholder", typeof(RectTransform), typeof(Text));
            var phRT = phGO.GetComponent<RectTransform>();
            phRT.SetParent(inputGO.transform, false);
            phRT.anchorMin = new Vector2(0, 0); phRT.anchorMax = new Vector2(1, 1); phRT.pivot = new Vector2(0.5f, 0.5f);
            phRT.offsetMin = new Vector2(8, 8); phRT.offsetMax = new Vector2(-8, -8);
            var ph = phGO.GetComponent<Text>();
            ph.alignment = TextAnchor.UpperLeft; ph.text = "Type instructions here...";
            ph.color = new Color(1, 1, 1, 0.5f);
            field.placeholder = ph;

            // Load existing note
            var note = target.GetComponent<UIInstructionNote>();
            if (note != null) field.text = note.Note;

            // Buttons container
            var btnBar = new GameObject("Buttons", typeof(RectTransform));
            var btnBarRT = btnBar.GetComponent<RectTransform>();
            btnBarRT.SetParent(panel, false);
            btnBarRT.anchorMin = new Vector2(0, 0); btnBarRT.anchorMax = new Vector2(1, 0); btnBarRT.pivot = new Vector2(0.5f, 0f);
            btnBarRT.sizeDelta = new Vector2(0, 48); btnBarRT.anchoredPosition = new Vector2(0, 16);

            // Save button
            var save = CreateButton(btnBarRT, "Save", new Vector2(1f, 0.5f), new Vector2(-16, 0));
            save.onClick.AddListener(() =>
            {
                var n = target.GetComponent<UIInstructionNote>();
                if (n == null) n = target.gameObject.AddComponent<UIInstructionNote>();
                n.Note = field.text ?? string.Empty;
                Object.Destroy(overlayGO);
                Debug.Log($"[UICreator] Instructions saved for {target.name}");
            });

            // Cancel button
            var cancel = CreateButton(btnBarRT, "Cancel", new Vector2(0f, 0.5f), new Vector2(16, 0));
            cancel.onClick.AddListener(() =>
            {
                Object.Destroy(overlayGO);
                Debug.Log("[UICreator] Instructions canceled");
            });
        }

        private static Button CreateButton(RectTransform parent, string label, Vector2 anchor, Vector2 margin)
        {
            var go = new GameObject(label + "Button", typeof(RectTransform), typeof(Image), typeof(Button));
            var rt = go.GetComponent<RectTransform>();
            rt.SetParent(parent, false);
            rt.anchorMin = rt.anchorMax = anchor;
            rt.pivot = new Vector2(0.5f, 0.5f);
            rt.sizeDelta = new Vector2(120, 36);
            rt.anchoredPosition = new Vector2(Mathf.Lerp(-parent.rect.width * 0.5f + 80, parent.rect.width * 0.5f - 80, anchor.x), 0) + margin;
            var btn = go.GetComponent<Button>();

            var txtGO = new GameObject("Text", typeof(RectTransform), typeof(Text));
            var txtRT = txtGO.GetComponent<RectTransform>();
            txtRT.SetParent(rt, false);
            txtRT.anchorMin = new Vector2(0, 0); txtRT.anchorMax = new Vector2(1, 1); txtRT.pivot = new Vector2(0.5f, 0.5f);
            var txt = txtGO.GetComponent<Text>();
            txt.alignment = TextAnchor.MiddleCenter; txt.text = label;
            return btn;
        }
    }
}


// ===== FILE: Assets/Scripts/UI/Creator/Editing/UIDragMove.cs =====
using UnityEngine;
using UnityEngine.EventSystems;

namespace FantasyColony.UI.Creator.Editing
{
    /// <summary>
    /// Drag to move a RectTransform within a stage (top-left anchored space).
    /// Assumes target pivot=(0,1) and anchors fixed to stage (0,1).
    /// </summary>
    [RequireComponent(typeof(RectTransform))]
    public sealed class UIDragMove : MonoBehaviour, IBeginDragHandler, IDragHandler, IEndDragHandler
    {
        [SerializeField] private RectTransform _target; // optional; defaults to self
        [SerializeField] private RectTransform _stage;
        private Vector2 _startPos;
        private Vector2 _startMouseLocal;

        private void Awake()
        {
            if (_target == null) _target = GetComponent<RectTransform>();
            if (_stage == null && _target != null) _stage = _target.parent as RectTransform;
        }

        public void OnBeginDrag(PointerEventData eventData)
        {
            if (_target == null || _stage == null) return;
            _startPos = _target.anchoredPosition;
            ScreenToStageLocal(eventData, out _startMouseLocal);
            Debug.Log($"[UICreator] Drag begin: {_target.name} pos={_startPos}");
        }

        public void OnDrag(PointerEventData eventData)
        {
            if (_target == null || _stage == null) return;
            Vector2 mouseLocal;
            ScreenToStageLocal(eventData, out mouseLocal);
            var delta = mouseLocal - _startMouseLocal;
            var pos = _startPos + delta;

            if (GridPrefs.SnapEnabled && !IsAltHeld())
            {
                pos.x = Mathf.Round(pos.x / GridPrefs.CellSize) * GridPrefs.CellSize;
                pos.y = Mathf.Round(pos.y / GridPrefs.CellSize) * GridPrefs.CellSize;
            }

            var w = _target.rect.width;
            var h = _target.rect.height;
            var sw = _stage.rect.width;
            var sh = _stage.rect.height;

            pos.x = Mathf.Clamp(pos.x, 0f, Mathf.Max(0f, sw - w));
            pos.y = Mathf.Clamp(pos.y, -Mathf.Max(0f, sh - h), 0f);

            _target.anchoredPosition = pos;
        }

        public void OnEndDrag(PointerEventData eventData)
        {
            if (_target == null) return;
            Debug.Log($"[UICreator] Drag end: {_target.name} pos={_target.anchoredPosition}");
        }

        private void ScreenToStageLocal(PointerEventData ev, out Vector2 local)
        {
            RectTransformUtility.ScreenPointToLocalPointInRectangle(_stage, ev.position, null, out local);
        }

        private static bool IsAltHeld()
        {
#if ENABLE_INPUT_SYSTEM
            return UnityEngine.InputSystem.Keyboard.current != null &&
                   (UnityEngine.InputSystem.Keyboard.current.leftAltKey.isPressed || UnityEngine.InputSystem.Keyboard.current.rightAltKey.isPressed);
#else
            return Input.GetKey(KeyCode.LeftAlt) || Input.GetKey(KeyCode.RightAlt);
#endif
        }
    }
}


// ===== FILE: Assets/Scripts/UI/Creator/Editing/UIInstructionNote.cs =====
using UnityEngine;

namespace FantasyColony.UI.Creator.Editing
{
    /// <summary>
    /// Simple metadata component to store per-item instructions/notes.
    /// </summary>
    public sealed class UIInstructionNote : MonoBehaviour
    {
        [TextArea(3, 10)] public string Note = string.Empty;
    }
}


// ===== FILE: Assets/Scripts/UI/Creator/Editing/UIResizeHandle.cs =====
using UnityEngine;
using UnityEngine.EventSystems;

namespace FantasyColony.UI.Creator.Editing
{
    /// <summary>
    /// Drag to resize a RectTransform. Assumes target pivot=(0,1) (top-left) and fixed anchors.
    /// </summary>
    [RequireComponent(typeof(RectTransform))]
    public sealed class UIResizeHandle : MonoBehaviour, IBeginDragHandler, IDragHandler, IEndDragHandler
    {
        public enum Side { N, S, E, W, NE, NW, SE, SW }

        [SerializeField] private RectTransform _target;
        [SerializeField] private RectTransform _stage;
        [SerializeField] private Side _side;
        [SerializeField] private Vector2 _minSize = new Vector2(40, 24);

        private Vector2 _startMouseLocal;
        private Vector2 _startPos;
        private Vector2 _startSize;

        public void Init(RectTransform target, RectTransform stage, Side side)
        {
            _target = target; _stage = stage; _side = side;
        }

        public void OnBeginDrag(PointerEventData eventData)
        {
            if (_target == null || _stage == null) return;
            _startPos = _target.anchoredPosition;
            _startSize = _target.rect.size;
            RectTransformUtility.ScreenPointToLocalPointInRectangle(_stage, eventData.position, null, out _startMouseLocal);
            Debug.Log($"[UICreator] Resize begin: {_target.name} side={_side}");
        }

        public void OnDrag(PointerEventData eventData)
        {
            if (_target == null || _stage == null) return;
            Vector2 mouseLocal; RectTransformUtility.ScreenPointToLocalPointInRectangle(_stage, eventData.position, null, out mouseLocal);
            Vector2 d = mouseLocal - _startMouseLocal;

            float left = _startPos.x;
            float top = _startPos.y;
            float right = left + _startSize.x;
            float bottom = top - _startSize.y;

            if (_side == Side.E || _side == Side.NE || _side == Side.SE) right += d.x;
            if (_side == Side.W || _side == Side.NW || _side == Side.SW) left += d.x;
            if (_side == Side.N || _side == Side.NE || _side == Side.NW) top += d.y;
            if (_side == Side.S || _side == Side.SE || _side == Side.SW) bottom += d.y;

            if (GridPrefs.SnapEnabled && !IsAltHeld())
            {
                left = Mathf.Round(left / GridPrefs.CellSize) * GridPrefs.CellSize;
                right = Mathf.Round(right / GridPrefs.CellSize) * GridPrefs.CellSize;
                top = Mathf.Round(top / GridPrefs.CellSize) * GridPrefs.CellSize;
                bottom = Mathf.Round(bottom / GridPrefs.CellSize) * GridPrefs.CellSize;
            }

            float sw = _stage.rect.width;
            float sh = _stage.rect.height;
            left = Mathf.Clamp(left, 0f, sw);
            right = Mathf.Clamp(right, 0f, sw);
            top = Mathf.Clamp(top, -0f, 0f);
            bottom = Mathf.Clamp(bottom, -sh, 0f);

            float w = Mathf.Max(_minSize.x, right - left);
            float h = Mathf.Max(_minSize.y, top - bottom);
            right = left + w;
            bottom = top - h;

            _target.anchoredPosition = new Vector2(left, top);
            _target.SetSizeWithCurrentAnchors(RectTransform.Axis.Horizontal, w);
            _target.SetSizeWithCurrentAnchors(RectTransform.Axis.Vertical, h);
        }

        public void OnEndDrag(PointerEventData eventData)
        {
            if (_target == null) return;
            Debug.Log($"[UICreator] Resize end: {_target.name} size={_target.rect.size}");
        }

        private static bool IsAltHeld()
        {
#if ENABLE_INPUT_SYSTEM
            return UnityEngine.InputSystem.Keyboard.current != null &&
                   (UnityEngine.InputSystem.Keyboard.current.leftAltKey.isPressed || UnityEngine.InputSystem.Keyboard.current.rightAltKey.isPressed);
#else
            return Input.GetKey(KeyCode.LeftAlt) || Input.GetKey(KeyCode.RightAlt);
#endif
        }
    }
}


// ===== FILE: Assets/Scripts/UI/Creator/Editing/UISelectionBox.cs =====
using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.UI;
using FantasyColony.UI.Widgets;

namespace FantasyColony.UI.Creator.Editing
{
    /// <summary>
    /// Single-selection box with 8 resize handles for a placeable.
    /// </summary>
    [RequireComponent(typeof(RectTransform))]
    public sealed class UISelectionBox : MonoBehaviour, IPointerDownHandler
    {
        private static UISelectionBox _current;

        public static RectTransform CurrentTarget => _current != null ? _current._target : null;

        [SerializeField] private RectTransform _target; // self by default
        [SerializeField] private RectTransform _stage;
        [SerializeField] private RectTransform _overlay; // visual box parent

        private void Awake()
        {
            if (_target == null) _target = GetComponent<RectTransform>();
            if (_stage == null) _stage = _target.parent as RectTransform;
        }

        public void OnPointerDown(PointerEventData eventData)
        {
            Select();
        }

        public void Select()
        {
            if (_current == this) { Refresh(); return; }
            if (_current != null) _current.ClearOverlay();
            _current = this;
            BuildOverlay();
            Debug.Log($"[UICreator] Select: {_target.name}");
        }

        private void BuildOverlay()
        {
            ClearOverlay();
            _overlay = new GameObject("SelectionOverlay", typeof(RectTransform)).GetComponent<RectTransform>();
            _overlay.SetParent(_target, false);
            _overlay.anchorMin = new Vector2(0, 1);
            _overlay.anchorMax = new Vector2(0, 1);
            _overlay.pivot = new Vector2(0, 1);
            _overlay.anchoredPosition = Vector2.zero;
            _overlay.sizeDelta = _target.rect.size;

            var border = _overlay.gameObject.AddComponent<UIFrame>();
            border.SetEdges(true, true, true, true);

            CreateHandle(UIResizeHandle.Side.N, new Vector2(0.5f, 1f));
            CreateHandle(UIResizeHandle.Side.S, new Vector2(0.5f, 0f));
            CreateHandle(UIResizeHandle.Side.E, new Vector2(1f, 1f));
            CreateHandle(UIResizeHandle.Side.W, new Vector2(0f, 1f));
            CreateHandle(UIResizeHandle.Side.NE, new Vector2(1f, 1f));
            CreateHandle(UIResizeHandle.Side.NW, new Vector2(0f, 1f));
            CreateHandle(UIResizeHandle.Side.SE, new Vector2(1f, 0f));
            CreateHandle(UIResizeHandle.Side.SW, new Vector2(0f, 0f));
        }

        private void CreateHandle(UIResizeHandle.Side side, Vector2 anchor)
        {
            var go = new GameObject($"Handle_{side}", typeof(RectTransform), typeof(Image), typeof(UIResizeHandle));
            var rt = go.GetComponent<RectTransform>();
            rt.SetParent(_overlay, false);
            rt.anchorMin = rt.anchorMax = anchor;
            rt.pivot = new Vector2(0.5f, 0.5f);
            rt.sizeDelta = new Vector2(12, 12);
            var img = go.GetComponent<Image>(); var c = img.color; c.a = 0.6f; img.color = c;

            var h = go.GetComponent<UIResizeHandle>();
            h.Init(_target, _stage, side);
        }

        private void LateUpdate()
        {
            if (_overlay != null)
            {
                _overlay.sizeDelta = _target.rect.size;
            }
        }

        private void Refresh()
        {
            if (_overlay == null) BuildOverlay();
        }

        private void OnDisable() => ClearOverlay();

        private void OnDestroy() => ClearOverlay();

        private void ClearOverlay()
        {
            if (_overlay != null)
            {
                Destroy(_overlay.gameObject);
                _overlay = null;
            }
        }
    }
}


// ===== FILE: Assets/Scripts/UI/Creator/Editing/UIStageGrid.cs =====
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;

namespace FantasyColony.UI.Creator.Editing
{
    /// <summary>
    /// Lightweight grid overlay for the Creator stage. Drawn with pooled 1px Images.
    /// </summary>
    [RequireComponent(typeof(RectTransform))]
    public sealed class UIStageGrid : MonoBehaviour
    {
        [SerializeField] private RectTransform _rt;
        private readonly List<Image> _lines = new List<Image>();
        private bool _dirty = true;

        private void Awake()
        {
            if (_rt == null) _rt = GetComponent<RectTransform>();
        }

        private void OnEnable()
        {
            _dirty = true;
        }

        private void OnRectTransformDimensionsChange()
        {
            _dirty = true;
        }

        private void Update()
        {
            if (_dirty) Rebuild();
            foreach (var img in _lines)
            {
                if (img) img.enabled = GridPrefs.GridVisible;
            }
        }

        private void Rebuild()
        {
            _dirty = false;
            if (_rt.rect.width <= 0 || _rt.rect.height <= 0) return;

            int cell = Mathf.Max(2, GridPrefs.CellSize);
            int cols = Mathf.CeilToInt(_rt.rect.width / cell) + 1;
            int rows = Mathf.CeilToInt(_rt.rect.height / cell) + 1;
            int need = cols + rows;
            while (_lines.Count < need)
            {
                var go = new GameObject("grid-line", typeof(RectTransform), typeof(Image));
                go.transform.SetParent(transform, false);
                var img = go.GetComponent<Image>();
                var c = img.color; c.a = 0.08f; img.color = c; // subtle tint
                _lines.Add(img);
            }
            for (int i = need; i < _lines.Count; i++)
            {
                if (_lines[i]) _lines[i].enabled = false;
            }

            int idx = 0;
            // Vertical lines
            for (int x = 0; x <= cols; x++)
            {
                var img = _lines[idx++];
                var rt = img.rectTransform;
                rt.anchorMin = new Vector2(0, 1);
                rt.anchorMax = new Vector2(0, 1);
                rt.pivot = new Vector2(0.5f, 0.5f);
                rt.sizeDelta = new Vector2(1, _rt.rect.height);
                rt.anchoredPosition = new Vector2(x * cell, -_rt.rect.height * 0.5f);
                img.enabled = GridPrefs.GridVisible;
            }
            // Horizontal lines
            for (int y = 0; y <= rows; y++)
            {
                var img = _lines[idx++];
                var rt = img.rectTransform;
                rt.anchorMin = new Vector2(0, 1);
                rt.anchorMax = new Vector2(0, 1);
                rt.pivot = new Vector2(0.5f, 0.5f);
                rt.sizeDelta = new Vector2(_rt.rect.width, 1);
                rt.anchoredPosition = new Vector2(_rt.rect.width * 0.5f, -y * cell);
                img.enabled = GridPrefs.GridVisible;
            }
        }

        public Vector2 Snap(Vector2 localTopLeft)
        {
            int cell = Mathf.Max(2, GridPrefs.CellSize);
            float x = Mathf.Round(localTopLeft.x / cell) * cell;
            float y = Mathf.Round(localTopLeft.y / cell) * cell;
            return new Vector2(x, y);
        }

        public void MarkDirty() => _dirty = true;
    }
}


// ===== FILE: Assets/Scripts/UI/Root/UIRoot.cs =====
using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.UI;
#if ENABLE_INPUT_SYSTEM
// Only available when the new Input System package/define is enabled
using UnityEngine.InputSystem.UI;
#endif

namespace FantasyColony.UI.Root
{
    public sealed class UIRoot : MonoBehaviour
    {
        public RectTransform ScreenParent { get; private set; }

        public static event System.Action OnUpdate;

        public static UIRoot Create(Transform parent)
        {
            var go = new GameObject("UIRoot");
            go.transform.SetParent(parent, false);
            var root = go.AddComponent<UIRoot>();
            root.Build();
            return root;
        }

        private void Build()
        {
            // Canvas
            var canvasGO = new GameObject("Canvas");
            canvasGO.transform.SetParent(transform, false);
            var canvas = canvasGO.AddComponent<Canvas>();
            canvas.renderMode = RenderMode.ScreenSpaceOverlay;
            // Ensure pixel-accurate rounding to avoid uneven 1px borders on sliced images
            canvas.pixelPerfect = true; // ScreenSpaceOverlay only
            // Ensure a GraphicRaycaster exists
            if (canvasGO.GetComponent<GraphicRaycaster>() == null)
                canvasGO.AddComponent<GraphicRaycaster>();

            var scaler = canvasGO.AddComponent<CanvasScaler>();
            scaler.uiScaleMode = CanvasScaler.ScaleMode.ScaleWithScreenSize;
            scaler.referenceResolution = new Vector2(1920, 1080);
            scaler.matchWidthOrHeight = 0.5f;

            // EventSystem if missing
            bool hasEventSystem = EventSystem.current != null;
#if UNITY_2023_1_OR_NEWER
            if (!hasEventSystem)
                hasEventSystem = (Object.FindFirstObjectByType<EventSystem>() != null);
#else
            if (!hasEventSystem)
                hasEventSystem = (FindObjectOfType<EventSystem>() != null);
#endif
            // Create or sanitize EventSystem + input module (exactly one module)
            EventSystem esys = EventSystem.current;
            if (!hasEventSystem)
            {
                esys = new GameObject("EventSystem").AddComponent<EventSystem>();
                Debug.Log("[UIRoot] Created EventSystem");
            }

#if ENABLE_INPUT_SYSTEM
            // New Input System
            var oldMod = esys.GetComponent<StandaloneInputModule>();
            if (oldMod != null) Destroy(oldMod);
            if (esys.GetComponent<InputSystemUIInputModule>() == null)
                esys.gameObject.AddComponent<InputSystemUIInputModule>();
#else
            // Legacy Input (Standalone)
            // Remove any leftover InputSystemUIInputModule via reflection so this compiles
            // even if the new Input System package is not installed.
            var newInputModuleType = System.Type.GetType(
                "UnityEngine.InputSystem.UI.InputSystemUIInputModule, Unity.InputSystem");
            if (newInputModuleType != null)
            {
                var newMod = esys.GetComponent(newInputModuleType);
                if (newMod != null)
                    Destroy(newMod);
            }
            if (esys.GetComponent<StandaloneInputModule>() == null)
                esys.gameObject.AddComponent<StandaloneInputModule>();
#endif

            // Screen parent
            var screenParentGO = new GameObject("Screens");
            screenParentGO.transform.SetParent(canvasGO.transform, false);
            ScreenParent = screenParentGO.AddComponent<RectTransform>();
            ScreenParent.anchorMin = Vector2.zero;
            ScreenParent.anchorMax = Vector2.one;
            ScreenParent.offsetMin = Vector2.zero;
            ScreenParent.offsetMax = Vector2.zero;
        }

        private void Update()
        {
            OnUpdate?.Invoke();
        }
    }
}

// ===== FILE: Assets/Scripts/UI/Router/IScreen.cs =====
using UnityEngine;

namespace FantasyColony.UI.Router
{
    public interface IScreen
    {
        void Enter(Transform parent);
        void Exit();
    }

    public abstract class UIScreenBase : IScreen
    {
        protected RectTransform Root;
        public abstract void Enter(Transform parent);
        public abstract void Exit();
    }
}

// ===== FILE: Assets/Scripts/UI/Router/UIRouter.cs =====
using System;
using System.Collections.Generic;
using UnityEngine;
using FantasyColony.Core;

namespace FantasyColony.UI.Router
{
    public sealed class UIRouter
    {
        private readonly Transform _parent;
        private readonly ServiceRegistry _services;
        private readonly Stack<IScreen> _stack = new();

        // Global access to the active router (set in ctor)
        public static UIRouter Current { get; private set; }

        public UIRouter(Transform parent, ServiceRegistry services)
        {
            _parent = parent;
            _services = services;
            Current = this;
        }

        public void Push<T>() where T : IScreen, new()
        {
            var screen = new T();
            screen.Enter(_parent);
            _stack.Push(screen);
            Debug.Log($"[UIRouter] Push {typeof(T).Name}");
        }

        // Allow initializing a screen (e.g., dialogs) before entering
        public void Push<T>(Action<T> init) where T : IScreen, new()
        {
            var screen = new T();
            init?.Invoke(screen);
            Push(screen);
        }

        // Push an existing instance
        public void Push(IScreen screen)
        {
            screen.Enter(_parent);
            _stack.Push(screen);
            Debug.Log($"[UIRouter] Push {screen.GetType().Name}");
        }

        public void Pop()
        {
            if (_stack.Count == 0) return;
            var top = _stack.Pop();
            top.Exit();
            Debug.Log($"[UIRouter] Pop {top.GetType().Name}");
        }

        // --- Restart helpers ---
        public void PopAll()
        {
            while (_stack.Count > 0) Pop();
        }

        public void ResetTo<T>() where T : IScreen, new()
        {
            PopAll();
            Push<T>();
        }
    }
}

// ===== FILE: Assets/Scripts/UI/Screens/BootReportScreen.cs =====
using System.Text;
using UnityEngine;
using UnityEngine.UI;
using FantasyColony.UI.Router;

namespace FantasyColony.UI.Screens {
    /// <summary>
    /// Simple UI to present BootReport contents and first N validation messages.
    /// Dev-only utility; keep minimal.
    /// </summary>
    public sealed class BootReportScreen : IScreen {
        public GameObject Root { get; private set; }

        public void Enter(Transform parent) {
            CreateContent(parent);
        }
        public void Exit() { if (Root != null) GameObject.Destroy(Root); Root = null; }

        private Text _title;
        private Text _body;
        private Button _copy;
        private Button _close;

        private void CreateContent(Transform parent) {
            Root = new GameObject("BootReportScreen", typeof(RectTransform));
            Root.transform.SetParent(parent, false);
            var rootRT = (RectTransform)Root.transform;
            rootRT.anchorMin = new Vector2(0.5f, 0.5f);
            rootRT.anchorMax = new Vector2(0.5f, 0.5f);
            rootRT.pivot = new Vector2(0.5f, 0.5f);

            var panel = CreatePanel(Root.transform, new Vector2(800, 600));
            _title = CreateText(panel, "Boot Report", 24, TextAnchor.MiddleCenter);
            var titleRT = _title.rectTransform;
            titleRT.anchoredPosition = new Vector2(0, 250);

            _body = CreateText(panel, "", 14, TextAnchor.UpperLeft);
            var bodyRT = _body.rectTransform;
            bodyRT.sizeDelta = new Vector2(740, 430);
            bodyRT.anchoredPosition = new Vector2(0, 20);
            _body.horizontalOverflow = HorizontalWrapMode.Wrap;
            _body.verticalOverflow = VerticalWrapMode.Truncate;

            _copy = CreateButton(panel, "Copy", OnCopyClicked);
            _copy.GetComponent<RectTransform>().anchoredPosition = new Vector2(-120, -250);
            _close = CreateButton(panel, "Close", () => UIRouter.Current?.Pop());
            _close.GetComponent<RectTransform>().anchoredPosition = new Vector2(120, -250);

            Refresh();
        }

        private void Refresh() {
            var report = FantasyColony.Boot.BootReport.Last;
            if (report == null) {
                _body.text = "(no report)";
                return;
            }
            var sb = new StringBuilder();
            sb.AppendLine("Tasks:");
            for (int i = 0; i < report.steps.Count; i++) {
                var s = report.steps[i];
                sb.AppendLine($" - {s.title}  ({s.seconds:0.000}s){(string.IsNullOrEmpty(s.warn) ? "" : "  [" + s.warn + "]")}");
            }
            _body.text = sb.ToString();
        }

        private void OnCopyClicked() {
            var report = FantasyColony.Boot.BootReport.Last;
            if (report == null) return;
            var sb = new StringBuilder();
            for (int i = 0; i < report.steps.Count; i++) {
                var s = report.steps[i];
                sb.AppendLine($"{s.title}\t{s.seconds:0.000}\t{(s.warn ?? "").Replace('\n', ' ')}");
            }
#if UNITY_EDITOR
            UnityEditor.EditorGUIUtility.systemCopyBuffer = sb.ToString();
#else
            GUIUtility.systemCopyBuffer = sb.ToString();
#endif
        }

        // --- tiny UI helpers (local, to avoid style dependencies) ---
        private RectTransform CreatePanel(Transform parent, Vector2 size) {
            var go = new GameObject("Panel", typeof(RectTransform), typeof(Image));
            go.transform.SetParent(parent, false);
            var rt = (RectTransform)go.transform;
            rt.sizeDelta = size;
            rt.anchoredPosition = Vector2.zero;
            var img = go.GetComponent<Image>();
            img.color = new Color(0, 0, 0, 0.8f);
            var outline = go.AddComponent<Outline>();
            outline.effectColor = new Color(1, 1, 1, 0.05f);
            return rt;
        }
        private Text CreateText(RectTransform parent, string text, int size, TextAnchor anchor) {
            var go = new GameObject("Text", typeof(RectTransform), typeof(Text));
            go.transform.SetParent(parent, false);
            var t = go.GetComponent<Text>();
            t.text = text;
            t.fontSize = size;
            t.alignment = anchor;
            t.font = Resources.GetBuiltinResource<Font>("Arial.ttf");
            var rt = (RectTransform)go.transform;
            rt.sizeDelta = new Vector2(740, 60);
            rt.anchoredPosition = Vector2.zero;
            return t;
        }
        private Button CreateButton(RectTransform parent, string text, System.Action onClick) {
            var go = new GameObject("Button", typeof(RectTransform), typeof(Image), typeof(Button));
            go.transform.SetParent(parent, false);
            var rt = (RectTransform)go.transform;
            rt.sizeDelta = new Vector2(160, 40);
            var img = go.GetComponent<Image>();
            img.color = new Color(1, 1, 1, 0.1f);
            var btn = go.GetComponent<Button>();
            btn.onClick.AddListener(() => onClick());
            var label = CreateText(rt, text, 16, TextAnchor.MiddleCenter);
            label.rectTransform.sizeDelta = rt.sizeDelta;
            return btn;
        }
    }
}


// ===== FILE: Assets/Scripts/UI/Screens/BootScreen.cs =====
using System;
using System.Collections;
using UnityEngine;
using UnityEngine.UI;
using FantasyColony.UI.Router;
using FantasyColony.Boot;

namespace FantasyColony.UI.Screens
{
    // Boot screen: shows a cover and phase text while the app boot pipeline runs
    public class BootScreen : IScreen
    {
        public string Title = "Loading";
        public GameObject Root { get; private set; }
        private Text _phaseText;

        public void Enter(Transform parent)
        {
            Root = new GameObject("BootScreen");
            var rt = Root.AddComponent<RectTransform>();
            rt.SetParent(parent, false);
            rt.anchorMin = Vector2.zero; rt.anchorMax = Vector2.one;
            rt.offsetMin = Vector2.zero; rt.offsetMax = Vector2.zero;

            // Solid dark cover (prevents flash)
            var bg = new GameObject("Background");
            var bgrt = bg.AddComponent<RectTransform>();
            bgrt.SetParent(rt, false);
            bgrt.anchorMin = Vector2.zero; bgrt.anchorMax = Vector2.one;
            bgrt.offsetMin = Vector2.zero; bgrt.offsetMax = Vector2.zero;
            var bgImg = bg.AddComponent<Image>();
            bgImg.color = new Color(0.10f, 0.09f, 0.08f, 1f);
            bgImg.raycastTarget = true;

            // Centered title
            var titleGO = new GameObject("Title");
            var tr = titleGO.AddComponent<RectTransform>();
            tr.SetParent(rt, false);
            tr.anchorMin = tr.anchorMax = new Vector2(0.5f, 0.5f);
            tr.anchoredPosition = new Vector2(0f, 24f);
            tr.sizeDelta = new Vector2(640f, 80f);
            var text = titleGO.AddComponent<Text>();
            text.font = Resources.GetBuiltinResource<Font>("Arial.ttf");
            text.fontSize = 24; text.alignment = TextAnchor.MiddleCenter;
            text.color = Color.white;
            text.horizontalOverflow = HorizontalWrapMode.Overflow;
            text.verticalOverflow = VerticalWrapMode.Truncate;
            text.text = string.IsNullOrEmpty(Title) ? "Loading" : Title;

            // Phase text (small subtitle)
            var phaseGO = new GameObject("Phase");
            var pr = phaseGO.AddComponent<RectTransform>();
            pr.SetParent(rt, false);
            pr.anchorMin = pr.anchorMax = new Vector2(0.5f, 0.5f);
            pr.anchoredPosition = new Vector2(0f, -16f);
            pr.sizeDelta = new Vector2(720f, 40f);
            _phaseText = phaseGO.AddComponent<Text>();
            _phaseText.font = text.font;
            _phaseText.fontSize = 18; _phaseText.alignment = TextAnchor.MiddleCenter;
            _phaseText.color = new Color(0.92f, 0.92f, 0.92f, 0.95f);
            _phaseText.horizontalOverflow = HorizontalWrapMode.Overflow;
            _phaseText.verticalOverflow = VerticalWrapMode.Truncate;
            _phaseText.text = string.Empty;

            // Kick off the boot pipeline on the next frame
            var runner = Root.AddComponent<Runner>();
            runner.StartCoroutine(BootCo());
        }

        public void Exit()
        {
            if (Root != null)
            {
                UnityEngine.Object.Destroy(Root);
                Root = null;
            }
        }

        private IEnumerator BootCo()
        {
            yield return null; // render once so the cover is visible
            yield return BootPipeline.Run(SetPhase);
            Time.timeScale = 1f;
            UIRouter.Current?.ResetTo<MainMenuScreen>();
        }

        private void SetPhase(string s)
        {
            if (_phaseText != null) _phaseText.text = s ?? string.Empty;
        }

        private class Runner : MonoBehaviour { }
    }
}

// ===== FILE: Assets/Scripts/UI/Screens/ConfirmDialogScreen.cs =====
using System;
using UnityEngine;
using UnityEngine.UI;
using FantasyColony.UI.Router;
using FantasyColony.UI.Widgets;

namespace FantasyColony.UI.Screens
{
    // Simple reusable confirmation dialog with a dimming overlay
    public class ConfirmDialogScreen : IScreen
    {
        // Configure via UIRouter.Current.Push<ConfirmDialogScreen>(init => { ... })
        public string Title;
        public string Message;
        public string ConfirmLabel = "OK";
        public string CancelLabel = "Cancel";
        public Action OnConfirm;
        public Action OnCancel;

        public GameObject Root { get; private set; }

        public void Enter(Transform parent)
        {
            Root = new GameObject("ConfirmDialog");
            var rt = Root.AddComponent<RectTransform>();
            rt.SetParent(parent, false);
            rt.anchorMin = Vector2.zero; rt.anchorMax = Vector2.one;
            rt.offsetMin = Vector2.zero; rt.offsetMax = Vector2.zero;

            // Dimmer to block clicks and darken background
            var dim = new GameObject("Dimmer");
            var dimRt = dim.AddComponent<RectTransform>();
            dimRt.SetParent(rt, false);
            dimRt.anchorMin = Vector2.zero; dimRt.anchorMax = Vector2.one;
            dimRt.offsetMin = Vector2.zero; dimRt.offsetMax = Vector2.zero;
            var dimImg = dim.AddComponent<Image>();
            dimImg.color = new Color(0f, 0f, 0f, 0.55f);
            dimImg.raycastTarget = true;

            // Dialog panel (textured surface from UIFactory)
            var prt = UIFactory.CreatePanelSurface(rt, "Panel");
            prt.sizeDelta = new Vector2(520, 280);
            prt.anchorMin = prt.anchorMax = new Vector2(0.5f, 0.5f);
            prt.anchoredPosition = Vector2.zero;
            UIFactory.SetPanelDecorVisible(prt, true);

            var layout = prt.GetComponent<VerticalLayoutGroup>();
            layout.childAlignment = TextAnchor.UpperCenter;
            layout.childControlHeight = true; layout.childControlWidth = true;
            layout.childForceExpandHeight = false; layout.childForceExpandWidth = false;
            layout.padding = new RectOffset(24, 24, 24, 24);
            layout.spacing = 12;

            // Title
            var titleGO = new GameObject("Title");
            titleGO.transform.SetParent(prt, false);
            var titleText = titleGO.AddComponent<Text>();
            titleText.font = Resources.GetBuiltinResource<Font>("Arial.ttf");
            titleText.fontSize = 26; titleText.alignment = TextAnchor.MiddleCenter;
            titleText.color = Color.white;
            titleText.horizontalOverflow = HorizontalWrapMode.Wrap;
            titleText.verticalOverflow = VerticalWrapMode.Truncate;
            titleText.text = string.IsNullOrEmpty(Title) ? "Confirm" : Title;

            // Message
            var msgGO = new GameObject("Message");
            msgGO.transform.SetParent(prt, false);
            var msgText = msgGO.AddComponent<Text>();
            msgText.font = titleText.font;
            msgText.fontSize = 16; msgText.alignment = TextAnchor.MiddleCenter;
            msgText.color = new Color(0.9f, 0.9f, 0.9f, 0.95f);
            msgText.horizontalOverflow = HorizontalWrapMode.Wrap;
            msgText.verticalOverflow = VerticalWrapMode.Overflow;
            msgText.text = string.IsNullOrEmpty(Message) ? string.Empty : Message;

            // Buttons row
            var row = new GameObject("Buttons");
            row.transform.SetParent(prt, false);
            var rowLayout = row.AddComponent<HorizontalLayoutGroup>();
            rowLayout.childAlignment = TextAnchor.MiddleCenter;
            rowLayout.spacing = 16;
            rowLayout.childForceExpandWidth = false;
            rowLayout.childForceExpandHeight = false;
            rowLayout.padding = new RectOffset(0, 0, 8, 0);

            // Cancel / Confirm buttons using UIFactory
            UIFactory.CreateButtonSecondary(row.transform, string.IsNullOrEmpty(CancelLabel) ? "Cancel" : CancelLabel, () =>
            {
                UIRouter.Current?.Pop();
                OnCancel?.Invoke();
            });

            UIFactory.CreateButtonDanger(row.transform, string.IsNullOrEmpty(ConfirmLabel) ? "OK" : ConfirmLabel, () =>
            {
                var router = UIRouter.Current;
                router?.Pop(); // close dialog first so new screens appear above
                OnConfirm?.Invoke();
            });
        }

        public void Exit()
        {
            if (Root != null)
            {
                UnityEngine.Object.Destroy(Root);
                Root = null;
            }
        }
    }
}

// ===== FILE: Assets/Scripts/UI/Screens/MainMenuScreen.cs =====
using UnityEngine;
// using DevTools; // not required; DevLogOverlay is in the global namespace
using FantasyColony.UI.Router;
using FantasyColony.UI.Widgets;
using FantasyColony.UI.Style;
using FantasyColony.Core.Services;
using UnityObject = UnityEngine.Object;
using FantasyColony.Boot;

namespace FantasyColony.UI.Screens
{
    /// <summary>
    /// Main Menu (non-functional for now). Uses Base UI Style, bottom-right vertical stack.
    /// Order: Log, Start, Continue, Load, Options, Mods, Creator, Restart, Quit
    /// </summary>
    public sealed class MainMenuScreen : UIScreenBase
    {
        public override void Enter(Transform parent)
        {
            // Root
            var go = new GameObject("MainMenu", typeof(RectTransform));
            Root = go.GetComponent<RectTransform>();
            Root.SetParent(parent, false);
            Root.anchorMin = Vector2.zero;
            Root.anchorMax = Vector2.one;
            Root.offsetMin = Vector2.zero;
            Root.offsetMax = Vector2.zero;

            // Background (image if present, else solid)
            var bgSprite = Resources.Load<Sprite>("ui/menu/main_menu_bg");
            UIFactory.CreateFullscreenBackground(Root, bgSprite, new Color32(18, 15, 12, 255));

            // Panel stack (bottom-right)
            var panel = UIFactory.CreateBottomRightStack(Root, "MenuPanel");
            // Hide panel chrome so buttons sit directly on the background art (previous behavior)
            UIFactory.SetPanelDecorVisible(panel, false);

            // Buttons (log "Not implemented")
            void NotImpl(string name) => Debug.Log($"BUTTON: {name} (not implemented)");

            UIFactory.CreateButtonSecondary(panel, "Log",        DevLogOverlay.Show);
            var startBtn = UIFactory.CreateButtonPrimary(panel, "Start", () => NotImpl("Start"));
            var btnContinue = UIFactory.CreateButtonSecondary(panel, "Continue", () => NotImpl("Continue"));
            var btnLoad     = UIFactory.CreateButtonSecondary(panel, "Load",     () => NotImpl("Load"));
            UIFactory.CreateButtonSecondary(panel, "Options",    () => NotImpl("Options"));
            UIFactory.CreateButtonSecondary(panel, "Mods", () => UIRouter.Current?.Push<ModsScreen>());
            UIFactory.CreateButtonSecondary(panel, "Creator",    () => NotImpl("Creator"));
            UIFactory.CreateButtonSecondary(panel, "Restart",    ShowRestartConfirm);
            var quitBtn = UIFactory.CreateButtonDanger(panel, "Quit", ShowQuitConfirm);

#if UNITY_EDITOR || DEVELOPMENT_BUILD
            UIFactory.CreateButtonSecondary(panel, "Boot Report", () => UIRouter.Current?.Push<BootReportScreen>());
            UIFactory.CreateButtonSecondary(panel, "Validation: " + (JsonConfigService.Instance.GetValidationMode()==FantasyColony.Core.Defs.Validation.ValidationMode.Strict?"Strict":"Lenient"), ToggleValidationMode);
#endif

            // Disabled rules for now (no save system yet)
            btnContinue.interactable = false;
            btnLoad.interactable = false;
        }

        public override void Exit()
        {
            if (Root != null)
            {
                UnityObject.Destroy(Root.gameObject);
                Root = null;
            }
        }

        private void ShowRestartConfirm()
        {
            UIRouter.Current?.Push<ConfirmDialogScreen>(d =>
            {
                d.Title = "Restart Game?";
                d.Message = "This will restart the application flow.";
                d.ConfirmLabel = "Restart";
                d.CancelLabel = "Cancel";
                d.OnConfirm = () =>
                {
                    UIRouter.Current?.Push<BootScreen>(b => { b.Title = "Loading"; });
                };
            });
        }

        private void ShowQuitConfirm()
        {
            UIRouter.Current?.Push<ConfirmDialogScreen>(d =>
            {
                d.Title = "Quit Game?";
                d.Message = "Are you sure you want to exit?";
                d.ConfirmLabel = "Quit";
                d.CancelLabel = "Cancel";
                d.OnConfirm = QuitGame;
            });
        }

        private void QuitGame()
        {
#if UNITY_EDITOR
            UnityEditor.EditorApplication.ExitPlaymode();
#else
            Application.Quit();
#endif
        }

#if UNITY_EDITOR || DEVELOPMENT_BUILD
        private void ToggleValidationMode()
        {
            var cfg = JsonConfigService.Instance;
            var cur = cfg.GetValidationMode();
            var next = cur == FantasyColony.Core.Defs.Validation.ValidationMode.Strict ? "lenient" : "strict";
            cfg.Set("validation_mode", next);
            UIRouter.Current?.ResetTo<MainMenuScreen>();
        }
#endif
    }
}

// ===== FILE: Assets/Scripts/UI/Screens/ModsScreen.cs =====
using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;
using FantasyColony.UI.Router; // IScreen lives here
using FantasyColony.UI.Widgets; // UIFactory
using FantasyColony.UI.Style;   // BaseUIStyle paths & themes

namespace FantasyColony.UI.Screens
{
    /// <summary>
    /// Runtime-built Mods screen scaffold (no data wiring yet).
    /// Left column is labeled "Mods"; right column title reflects the selected mod's name.
    /// If no mod is selected, the snapshot shows aggregated view of all active mods (placeholder for now).
    /// </summary>
    public class ModsScreen : IScreen
    {
        private RectTransform _root;

        // Left column
        private RectTransform _leftColumn;
        private InputField _leftSearch;
        private RectTransform _inactiveListContent;
        private RectTransform _activeListContent;

        // Right column
        private RectTransform _centerColumn;
        private RectTransform _rightColumn;
        private Text _centerTitle;
        private InputField _snapshotSearch;
        private RectTransform _scriptContent;
        private RectTransform _defsContent;

        // Flexible height weights for header/content rows
        private const float H_HEADER = 1f;
        private const float H_CONTENT = 5f;
        // Column widths are ratio-only; the board HLG will distribute the remaining width
        private const float LEFT_RATIO = 1.0f;
        private const float CENTER_RATIO = 2.2f;
        private const float RIGHT_RATIO = 0.8f;

        private const float LeftWidth = 380f;
        private const float RightWidth = 320f;
        // Selection state
        private string _selectedModName = null; // null => aggregated view of all active mods

        public void Enter(Transform parent)
        {

            _root = CreateUIObject("ModsScreenRoot", parent);
            Stretch(_root);
            // Full-screen board
            var board = UIFactory.CreateBoardScreen(_root, padding:32, spacing:0); // spacing=0 so equalities hold exactly

            // Top-level three columns; use flexible weights to satisfy w1 + w4 + w6 = screenWidth
            var left = UIFactory.CreateColumn(board.Content, "Left",  preferredWidth: -1, flexibleWidth: LEFT_RATIO).GetComponent<RectTransform>();
            var center= UIFactory.CreateColumn(board.Content, "Center",preferredWidth: -1, flexibleWidth: CENTER_RATIO).GetComponent<RectTransform>();
            var right = UIFactory.CreateColumn(board.Content, "Right", preferredWidth: -1, flexibleWidth: RIGHT_RATIO).GetComponent<RectTransform>();
            UIFactory.JoinHorizontal(left, center);
            UIFactory.JoinHorizontal(center, right);

            // LEFT COLUMN
            _leftColumn = left;
            UIFactory.SetPanelDecorVisible(_leftColumn, true);
            var leftLE = _leftColumn.GetComponent<LayoutElement>() ?? _leftColumn.gameObject.AddComponent<LayoutElement>();
            leftLE.preferredWidth = -1f;   // use ratio
            leftLE.flexibleWidth = LEFT_RATIO;

            var leftVL = _leftColumn.GetComponent<VerticalLayoutGroup>();
            if (leftVL != null)
            {
                leftVL.spacing = 0; // to honor exact equalities; inner panels have their own padding
                leftVL.padding = new RectOffset(12, 12, 12, 12);
                leftVL.childControlHeight = true;
                leftVL.childForceExpandHeight = true;
            }

            // Panel #1 (header)
            var p1 = UIFactory.CreatePanelSurface(_leftColumn, "P1_Header").GetComponent<RectTransform>();
            var p1LE = p1.GetComponent<LayoutElement>() ?? p1.gameObject.AddComponent<LayoutElement>();
            p1LE.flexibleHeight = H_HEADER; // h1
            BuildLeftHeader(p1);

            // Row for #2 and #3 (equal widths)
            var row23 = CreateUIObject("Row23", _leftColumn);
            var row23HL = row23.gameObject.AddComponent<HorizontalLayoutGroup>();
            row23HL.spacing = 0; row23HL.childForceExpandWidth = true; row23HL.childForceExpandHeight = true;
            var row23LE = row23.gameObject.AddComponent<LayoutElement>();
            row23LE.flexibleHeight = H_CONTENT; // this enforces h2 = h3 = h5 later

            var leftControls = CreateUIObject("LeftControls", p1);
            var lcHL = leftControls.gameObject.AddComponent<HorizontalLayoutGroup>();
            lcHL.childAlignment = TextAnchor.MiddleLeft;
            lcHL.spacing = 8f;
            lcHL.childForceExpandWidth = false;

            _leftSearch = CreateSearchField(leftControls, "Search mods...");
            var searchLE = _leftSearch.GetComponent<LayoutElement>();
            if (searchLE == null) searchLE = _leftSearch.gameObject.AddComponent<LayoutElement>();
            searchLE.preferredWidth = 220f;

            UIFactory.CreateButtonSecondary(leftControls, "Sort", () => { /* TODO: sort menu */ });

            // Panel #2 (inactive) – half width of #1
            var p2 = UIFactory.CreatePanelSurface(row23, "P2_Inactive").GetComponent<RectTransform>();
            var p2LE = p2.GetComponent<LayoutElement>() ?? p2.gameObject.AddComponent<LayoutElement>();
            p2LE.flexibleWidth = 1; // w2
            _inactiveListContent = CreateTitledScrollPanel_Styled(p2, "inactive mod list");
            CreateEmptyState(_inactiveListContent, "No inactive mods");

            // Panel #3 (active) – equals #2
            var p3 = UIFactory.CreatePanelSurface(row23, "P3_Active").GetComponent<RectTransform>();
            var p3LE = p3.GetComponent<LayoutElement>() ?? p3.gameObject.AddComponent<LayoutElement>();
            p3LE.flexibleWidth = 1; // w3, ensures w2 = w3 and w2 + w3 = w1
            _activeListContent = CreateTitledScrollPanel_Styled(p3, "active mod list");
            CreateEmptyState(_activeListContent, "No active mods");

            // CENTER COLUMN (snapshot)
            _centerColumn = center;
            UIFactory.SetPanelDecorVisible(_centerColumn, true);
            var centerLE = _centerColumn.GetComponent<LayoutElement>() ?? _centerColumn.gameObject.AddComponent<LayoutElement>();
            centerLE.preferredWidth = -1f; // use ratio
            centerLE.flexibleWidth = CENTER_RATIO;  // flexible middle column
            var centerVL = _centerColumn.GetComponent<VerticalLayoutGroup>();
            if (centerVL != null)
            {
                centerVL.spacing = 0;
                centerVL.padding = new RectOffset(12, 12, 12, 12);
                centerVL.childControlHeight = true;
                centerVL.childForceExpandHeight = true;
            }

            // Panel #4 (snapshot header)
            var p4 = UIFactory.CreatePanelSurface(_centerColumn, "P4_SnapshotHeader").GetComponent<RectTransform>();
            var p4LE = p4.GetComponent<LayoutElement>() ?? p4.gameObject.AddComponent<LayoutElement>();
            p4LE.flexibleHeight = H_HEADER; // h4 = h1
            var centerHeader = CreateUIObject("CenterHeader", p4);
            var chHL = centerHeader.gameObject.AddComponent<HorizontalLayoutGroup>();
            chHL.childAlignment = TextAnchor.MiddleLeft;
            chHL.spacing = 8f;
            chHL.childForceExpandWidth = true;

            _centerTitle = CreateTitleLabel(centerHeader, "All Active Mods");
            var spacerC = CreateFlexibleSpace(centerHeader);
            _snapshotSearch = CreateSearchField(centerHeader, "search snapshot...");
            var snapLE = _snapshotSearch.gameObject.AddComponent<LayoutElement>();
            snapLE.preferredWidth = 260f;

            // Panel #5 (snapshot content)
            var snapshotPanel = UIFactory.CreatePanelSurface(_centerColumn, "P5_Snapshot").GetComponent<RectTransform>();
            var p5LE = snapshotPanel.GetComponent<LayoutElement>() ?? snapshotPanel.gameObject.AddComponent<LayoutElement>();
            p5LE.flexibleHeight = H_CONTENT; // h5 = h2 = h3
            var spVL = snapshotPanel.GetComponent<VerticalLayoutGroup>();
            if (spVL != null)
            {
                spVL.spacing = 8f;
                spVL.padding = new RectOffset(12, 12, 12, 12);
                spVL.childControlHeight = false;
                spVL.childForceExpandHeight = false;
            }

            CreateLabel(snapshotPanel, "Snapshot (shows the contents of the mod in a user-friendly list)", 14, FontStyle.Italic, TextAnchor.MiddleLeft);

            // Foldouts
            CreateFoldout(snapshotPanel, "script +", out _scriptContent);
            CreateDivider(_scriptContent);
            CreateDivider(_scriptContent);
            CreateDivider(_scriptContent);
            UIFactory.CreateRuleHorizontal(snapshotPanel, 2f, 0.7f); // visual break inside panel #5 (this is 5b)
            CreateFoldout(snapshotPanel, "defs +", out _defsContent);
            CreateDivider(_defsContent);
            CreateDivider(_defsContent);
            CreateDivider(_defsContent);

            // RIGHT COLUMN (actions)
            _rightColumn = right;
            UIFactory.SetPanelDecorVisible(_rightColumn, true);
            var rightLE = _rightColumn.GetComponent<LayoutElement>() ?? _rightColumn.gameObject.AddComponent<LayoutElement>();
            rightLE.preferredWidth = -1f;
            rightLE.flexibleWidth = RIGHT_RATIO; // ratio-based right rail
            var rightVL = _rightColumn.GetComponent<VerticalLayoutGroup>();
            if (rightVL != null)
            {
                rightVL.spacing = 12f;
                rightVL.padding = new RectOffset(12, 12, 12, 12);
                rightVL.childControlHeight = false;
                rightVL.childForceExpandHeight = false;
            }

            UIFactory.CreateButtonSecondary(_rightColumn, "save mod list", () => { /* TODO */ });
            UIFactory.CreateButtonSecondary(_rightColumn, "load mod list", () => { /* TODO */ });
            // push primary button to bottom
            CreateFlexibleSpace(_rightColumn);
            UIFactory.CreateButtonPrimary(_rightColumn, "apply/restart", () =>
            {
                try { AppFlowCommands.Restart(); } catch { Debug.Log("Restart requested (AppFlowCommands.Restart missing in editor)"); }
            });

            // Initial snapshot state (aggregated view)
            RefreshSnapshot();
        }

        public void Exit()
        {
            if (_root != null)
            {
                GameObject.Destroy(_root.gameObject);
                _root = null;
            }
        }

        // --- Selection and snapshot ---
        private void SetSelectedMod(string modName)
        {
            _selectedModName = modName;
            _centerTitle.text = string.IsNullOrEmpty(_selectedModName) ? "All Active Mods" : _selectedModName;
            RefreshSnapshot();
        }

        private void RefreshSnapshot()
        {
            ClearChildren(_scriptContent);
            ClearChildren(_defsContent);

            if (string.IsNullOrEmpty(_selectedModName))
            {
                // Aggregated from active list (placeholder – no real data yet)
                CreateLabel(_scriptContent, "(Aggregated) scripts from all active mods", 12, FontStyle.Normal, TextAnchor.MiddleLeft);
                for (int i = 0; i < 3; i++) CreateDivider(_scriptContent);

                CreateLabel(_defsContent, "(Aggregated) defs from all active mods", 12, FontStyle.Normal, TextAnchor.MiddleLeft);
                for (int i = 0; i < 3; i++) CreateDivider(_defsContent);
            }
            else
            {
                // Selected mod only (placeholder)
                CreateLabel(_scriptContent, $"scripts in '{_selectedModName}'", 12, FontStyle.Normal, TextAnchor.MiddleLeft);
                for (int i = 0; i < 3; i++) CreateDivider(_scriptContent);

                CreateLabel(_defsContent, $"defs in '{_selectedModName}'", 12, FontStyle.Normal, TextAnchor.MiddleLeft);
                for (int i = 0; i < 3; i++) CreateDivider(_defsContent);
            }
        }

        // --- UI building helpers (lean, rely on layout components) ---
        private static RectTransform CreateUIObject(string name, Transform parent)
        {
            var go = new GameObject(name, typeof(RectTransform));
            var rt = go.GetComponent<RectTransform>();
            rt.SetParent(parent, false);
            return rt;
        }

        private static RectTransform AsRT(Component c)
        {
            return c is RectTransform r ? r : c.GetComponent<RectTransform>();
        }

        private static void Stretch(RectTransform rt)
        {
            rt.anchorMin = Vector2.zero;
            rt.anchorMax = Vector2.one;
            rt.offsetMin = Vector2.zero;
            rt.offsetMax = Vector2.zero;
        }

        private static Text CreateLabel(Transform parent, string text, int size, FontStyle style, TextAnchor anchor)
        {
            var go = CreateUIObject("Label", parent);
            var t = go.gameObject.AddComponent<Text>();
            t.text = text;
            t.fontSize = size;
            t.alignment = anchor;
            t.font = Resources.GetBuiltinResource<Font>("Arial.ttf");
            t.color = new Color(0.92f, 0.88f, 0.78f, 1f); // light text (fits base style)
            var le = go.gameObject.AddComponent<LayoutElement>();
            le.minHeight = 24f;
            return t;
        }

        private static Text CreateHeaderLabel(Transform parent, string text)
        {
            return CreateLabel(parent, text, 22, FontStyle.Bold, TextAnchor.MiddleLeft);
        }

        private void BuildLeftHeader(Transform parent)
        {
            CreateHeaderLabel(parent, "Mods");
        }

        private static Text CreateTitleLabel(Transform parent, string text)
        {
            return CreateLabel(parent, text, 20, FontStyle.Bold, TextAnchor.MiddleLeft);
        }

        private static InputField CreateSearchField(Transform parent, string placeholder)
        {
            var container = CreateUIObject("SearchField", parent);
            var bg = container.gameObject.AddComponent<Image>();
            bg.color = new Color(0.16f, 0.14f, 0.10f, 0.85f);
            var le = container.gameObject.AddComponent<LayoutElement>();
            le.preferredHeight = 32f;
            le.flexibleWidth = 0f;

            var textGO = CreateUIObject("Text", container);
            var text = textGO.gameObject.AddComponent<Text>();
            text.font = Resources.GetBuiltinResource<Font>("Arial.ttf");
            text.color = new Color(0.92f, 0.88f, 0.78f, 1f);
            text.alignment = TextAnchor.MiddleLeft;
            var textRT = textGO;
            textRT.anchorMin = new Vector2(0, 0);
            textRT.anchorMax = new Vector2(1, 1);
            textRT.offsetMin = new Vector2(8, 6);
            textRT.offsetMax = new Vector2(-8, -6);

            var phGO = CreateUIObject("Placeholder", container);
            var placeholderText = phGO.gameObject.AddComponent<Text>();
            placeholderText.text = placeholder;
            placeholderText.font = text.font;
            placeholderText.color = new Color(1f, 1f, 1f, 0.35f);
            placeholderText.alignment = TextAnchor.MiddleLeft;
            var phRT = phGO;
            phRT.anchorMin = new Vector2(0, 0);
            phRT.anchorMax = new Vector2(1, 1);
            phRT.offsetMin = new Vector2(8, 6);
            phRT.offsetMax = new Vector2(-8, -6);

            var input = container.gameObject.AddComponent<InputField>();
            input.textComponent = text;
            input.placeholder = placeholderText;
            return input;
        }

        private static RectTransform CreateTitledScrollPanel_Styled(Transform parent, string title)
        {
            var container = UIFactory.CreatePanelSurface(parent, title + "_Panel");
            var vl = container.GetComponent<VerticalLayoutGroup>();
            if (vl != null)
            {
                vl.childControlHeight = false;
                vl.childForceExpandHeight = false;
                vl.spacing = 6f;
                vl.padding = new RectOffset(8, 8, 8, 8);
            }

            CreateLabel(container, title, 14, FontStyle.Bold, TextAnchor.MiddleLeft);

            var scrollRoot = CreateUIObject("Scroll", container);
            var le = scrollRoot.gameObject.AddComponent<LayoutElement>();
            le.preferredHeight = 220f;
            var scroll = scrollRoot.gameObject.AddComponent<ScrollRect>();
            var viewport = CreateUIObject("Viewport", scrollRoot);
            var vpImg = viewport.gameObject.AddComponent<Image>();
            vpImg.color = new Color(0, 0, 0, 0.1f);
            viewport.anchorMin = new Vector2(0, 0);
            viewport.anchorMax = new Vector2(1, 1);
            viewport.offsetMin = new Vector2(0, 0);
            viewport.offsetMax = new Vector2(0, 0);
            var mask = viewport.gameObject.AddComponent<Mask>();
            mask.showMaskGraphic = false;

            var content = CreateUIObject("Content", viewport);
            // The viewport content needs its own VerticalLayoutGroup; ensure only one per object.
            var layout = content.GetComponent<VerticalLayoutGroup>() ?? content.gameObject.AddComponent<VerticalLayoutGroup>();
            layout.childControlWidth = true;
            layout.childControlHeight = false;
            layout.childForceExpandWidth = true;
            layout.childForceExpandHeight = false;
            layout.spacing = 4f;
            content.gameObject.AddComponent<ContentSizeFitter>().verticalFit = ContentSizeFitter.FitMode.PreferredSize;

            scroll.viewport = viewport;
            scroll.content = content;
            scroll.horizontal = false;
            scroll.vertical = true;

            return content;
        }

        private static RectTransform CreateFlexibleSpace(Transform parent)
        {
            var rt = CreateUIObject("FlexibleSpace", parent);
            var le = rt.gameObject.AddComponent<LayoutElement>();
            le.flexibleWidth = 1f;
            return rt;
        }

        private static void CreateDivider(Transform parent)
        {
            var go = CreateUIObject("Divider", parent);
            var img = go.gameObject.AddComponent<Image>();
            img.color = new Color(1f, 1f, 1f, 0.25f);
            var le = go.gameObject.AddComponent<LayoutElement>();
            le.minHeight = 2f;
        }

        private static void CreateEmptyState(Transform parent, string message)
        {
            var label = CreateLabel(parent, message, 12, FontStyle.Italic, TextAnchor.MiddleCenter);
            label.color = new Color(1f, 1f, 1f, 0.5f);
        }

        private static void CreateFoldout(Transform parent, string title, out RectTransform content)
        {
            // Header
            var header = CreateUIObject(title + "_Header", parent);
            var hl = header.gameObject.AddComponent<HorizontalLayoutGroup>();
            hl.childAlignment = TextAnchor.MiddleLeft;
            hl.spacing = 6f;
            hl.childForceExpandWidth = true;
            var label = CreateLabel(header, title, 16, FontStyle.Bold, TextAnchor.MiddleLeft);
            var plusMinus = CreateLabel(header, "+", 18, FontStyle.Bold, TextAnchor.MiddleRight);
            var spacer = CreateFlexibleSpace(header);
            var btn = header.gameObject.AddComponent<Button>();

            // Content
            content = UIFactory.CreatePanelSurface(parent, title + "_Content");
            var localContent = content;
            // Avoid duplicate LayoutGroups: use existing or add if missing
            var vl = content.GetComponent<VerticalLayoutGroup>() ?? content.gameObject.AddComponent<VerticalLayoutGroup>();
            vl.childControlWidth = true;
            vl.childControlHeight = false;
            vl.childForceExpandWidth = true;
            vl.childForceExpandHeight = false;
            vl.spacing = 4f;
            vl.padding = new RectOffset(8, 8, 8, 8);

            // Default expanded
            bool expanded = true;
            plusMinus.text = expanded ? "–" : "+";

            btn.onClick.AddListener(() =>
            {
                expanded = !expanded;
                localContent.gameObject.SetActive(expanded);
                plusMinus.text = expanded ? "–" : "+";
            });
        }

        private static void ClearChildren(Transform t)
        {
            for (int i = t.childCount - 1; i >= 0; i--)
            {
                GameObject.Destroy(t.GetChild(i).gameObject);
            }
        }

    }
}

// ===== FILE: Assets/Scripts/UI/Screens/UICreatorScreen.cs =====
using System;
using UnityEngine;
using UnityEngine.UI;
#if ENABLE_INPUT_SYSTEM
using UnityEngine.InputSystem;
#endif
using FantasyColony.UI.Router;
using FantasyColony.UI.Widgets;
using FantasyColony.UI.Util;
using FantasyColony.UI.Creator.Editing;
using UnityObject = UnityEngine.Object;

namespace FantasyColony.UI.Screens
{
    /// <summary>
    /// UI Creator (Stub) — Step 1: dev entry & shell scaffold.
    /// Runtime-only, built via UIFactory. Structural containers use PanelSizing.Flexible.
    /// </summary>
    public sealed class UICreatorScreen : IScreen
    {
        public static bool IsOpen { get; private set; }
        private RectTransform _root;

        // Program-window layout: Top toolbar (percent height) + large blank stage
        private RectTransform _toolbar;
        private RectTransform _stage;
        private UIStageGrid _grid;
        private RectTransform _btnFile, _btnEdit, _btnView, _btnTools, _btnClose;
        private const float TOOLBAR_FRAC = 0.05f; // 5% of screen height

        // Attach controller when screen becomes active to manage stage fullscreen toggling
        private void OnEnable()
        {
            try
            {
                var rootRT = _root != null ? _root.GetComponent<RectTransform>() : null;
                if (rootRT != null && _toolbar != null && _stage != null && _root.GetComponent<UICreatorStageController>() == null)
                {
                    var ctl = _root.gameObject.AddComponent<UICreatorStageController>();
                    ctl.Initialize(_toolbar, _stage, TOOLBAR_FRAC);
                    Debug.Log("[UICreator] Controller attached");
                }
            }
            catch (Exception e)
            {
                Debug.LogWarning($"[UICreator] Controller attach failed: {e.Message}");
            }
        }

        // Ensure toolbar is visible if this screen is being closed
        private void OnDisable()
        {
            var ctl = _root != null ? _root.GetComponent<UICreatorStageController>() : null;
            if (ctl != null)
            {
                ctl.SetStageFullscreen(false);
            }
        }

        public void Enter(Transform parent)
        {
            // Root (full-screen)
            var go = new GameObject("UICreator", typeof(RectTransform));
            _root = go.GetComponent<RectTransform>();
            _root.SetParent(parent, false);
            _root.anchorMin = Vector2.zero;
            _root.anchorMax = Vector2.one;
            _root.offsetMin = Vector2.zero;
            _root.offsetMax = Vector2.zero;

            Debug.Log("[UICreator] Enter");

            // Board: neutral dev look; padded content for borders, but anchors must live under a layout-free layer.
            var board = UIFactory.CreateBoardScreen(_root, padding: 8, spacing: 0);

            // Create a layout-free absolute layer under BoardRoot to host anchor-based regions
            var absGO = new GameObject("AbsoluteLayer", typeof(RectTransform));
            var absRT = absGO.GetComponent<RectTransform>();
            absRT.SetParent(board.Root, false);
            absRT.anchorMin = Vector2.zero;
            absRT.anchorMax = Vector2.one;
            absRT.offsetMin = Vector2.zero;
            absRT.offsetMax = Vector2.zero;

            // Percent-height anchors for Toolbar/Stage (under the absolute, layout-free layer)
            // Toolbar: make it OWN the HorizontalLayoutGroup; avoid nested layout parents that collapse width
            var toolbarGO = new GameObject("Toolbar", typeof(RectTransform), typeof(Image), typeof(HorizontalLayoutGroup));
            _toolbar = toolbarGO.GetComponent<RectTransform>();
            var toolbarImg = toolbarGO.GetComponent<Image>();
            toolbarImg.color = new Color(0f, 0f, 0f, 1f); // solid bar; adjust in future if needed
            toolbarImg.raycastTarget = true;
            var toolbarHL = toolbarGO.GetComponent<HorizontalLayoutGroup>();
            toolbarHL.padding = new RectOffset(0,0,0,0);
            toolbarHL.spacing = 0f;
            toolbarHL.childControlWidth = true;
            toolbarHL.childForceExpandWidth = true; // split width evenly via button flexibleWidth=1
            toolbarHL.childControlHeight = true;
            toolbarHL.childForceExpandHeight = true;
            toolbarHL.childAlignment = TextAnchor.MiddleCenter;
            _toolbar.SetParent(absRT, false);

            // Stage should be a BLANK surface (no frame/border) to avoid artifacts in the center
            var stageGO = new GameObject("CanvasStage", typeof(RectTransform), typeof(Image));
            _stage = stageGO.GetComponent<RectTransform>();
            var stageImg = stageGO.GetComponent<Image>();
            stageImg.color = new Color(0f, 0f, 0f, 0f); // transparent
            stageImg.raycastTarget = false;
              _stage.SetParent(absRT, false);

            // Anchors: toolbar = top 5% height, stage = remaining 95%
            UIFactory.SetAnchorsPercent(_toolbar, xMin:0f, xMax:1f, yMin:1f - TOOLBAR_FRAC, yMax:1f);
              UIFactory.SetAnchorsPercent(_stage, xMin:0f, xMax:1f, yMin:0f, yMax:1f - TOOLBAR_FRAC);

              // Use top-left origin for deterministic editing math
              _stage.pivot = new Vector2(0f, 1f);
              _stage.anchoredPosition = Vector2.zero;
              _grid = _stage.gameObject.GetComponent<UIStageGrid>();
              if (_grid == null) _grid = _stage.gameObject.AddComponent<UIStageGrid>();
              Debug.Log($"[UICreator] Grid:on size={GridPrefs.CellSize}");

            // --- Toolbar content: equal-width buttons across full width ---
            // Create equal-width buttons directly under the toolbar (no nested Row)
            _btnFile  = CreateFlexMenuButton(_toolbar, "File",  OnFileMenu);
            _btnEdit  = CreateFlexMenuButton(_toolbar, "Edit",  OnEditMenu);
            _btnView  = CreateFlexMenuButton(_toolbar, "View",  OnViewMenu);
            _btnTools = CreateFlexMenuButton(_toolbar, "Tools", OnToolsMenu);
            // Remove Help per request
            _btnClose = CreateFlexMenuButton(_toolbar, "Close", () => UIRouter.Current?.Pop());

            // Reset toolbar ON whenever entering the Creator
            OnEnable();
            var ctl = _root != null ? _root.GetComponent<UICreatorStageController>() : null;
            if (ctl != null) ctl.SetStageFullscreen(false);

            IsOpen = true;
        }

        public void Exit()
        {
            if (_root != null)
            {
                Debug.Log("[UICreator] Exit");
                OnDisable();
                // Cleanup any open menus/overlays
                CloseMenus();
                UnityObject.Destroy(_root.gameObject);
                _root = null;
            }
            IsOpen = false;
        }

        // --- helpers ---
        private static RectTransform CreateFlexMenuButton(Transform parent, string label, System.Action onClick)
        {
            var btn = UIFactory.CreateButtonPrimary(parent, label, onClick);
            // Equal slice of width, regardless of label length
            var le = btn.GetComponent<LayoutElement>();
            if (le == null) le = btn.gameObject.AddComponent<LayoutElement>();
            le.minWidth = 0f;
            le.preferredWidth = 0f;
            le.flexibleWidth = 1f; // ratio slice

            var txt = btn.GetComponentInChildren<Text>();
            if (txt != null)
            {
                txt.resizeTextForBestFit = true;
                txt.resizeTextMinSize = 12;
                txt.resizeTextMaxSize = 28;
            }
            return btn.GetComponent<RectTransform>();
        }

        // --- Simple dropdown framework (stub for Step 1) ---
        private RectTransform _menuOverlay;
        private RectTransform _openMenu;

        private void EnsureMenuOverlay(Transform parent)
        {
            if (_menuOverlay != null) return;
            var go = new GameObject("MenuOverlay", typeof(RectTransform), typeof(Image));
            _menuOverlay = go.GetComponent<RectTransform>();
            var img = go.GetComponent<Image>();
            img.color = new Color(0f,0f,0f,0f);
            img.raycastTarget = true; // capture outside clicks
            _menuOverlay.SetParent(parent, false);
            _menuOverlay.anchorMin = Vector2.zero; _menuOverlay.anchorMax = Vector2.one;
            _menuOverlay.offsetMin = Vector2.zero; _menuOverlay.offsetMax = Vector2.zero;
            go.AddComponent<Button>().onClick.AddListener(CloseMenus);
            go.SetActive(false);
        }

        private void CloseMenus()
        {
            if (_openMenu != null)
            {
                UnityObject.Destroy(_openMenu.gameObject);
                _openMenu = null;
            }
            if (_menuOverlay != null) _menuOverlay.gameObject.SetActive(false);
        }

        private void ShowMenu(RectTransform anchor, params (string label, System.Action onClick)[] items)
        {
            CloseMenus();
            EnsureMenuOverlay(_toolbar.parent); // overlay lives under AbsoluteLayer
            _menuOverlay.gameObject.SetActive(true);

            var list = new System.Collections.Generic.List<UIFactory.MenuItem>(items.Length);
            foreach (var it in items)
                list.Add(new UIFactory.MenuItem(it.label, () => { it.onClick?.Invoke(); CloseMenus(); }));

            _openMenu = UIFactory.CreateDropdownMenu(_menuOverlay, anchor, list, rowHeight: 32f, minWidth: 160f, matchAnchorWidth: true);
        }

        // --- Menu actions (stubs) ---
        private void OnFileMenu()
        {
            ShowMenu(_btnFile, ("New", ()=>Debug.Log("[UICreator] File/New")),
                              ("Save", ()=>Debug.Log("[UICreator] File/Save (stub)")),
                              ("Load", ()=>Debug.Log("[UICreator] File/Load (stub)")));
        }

        private void OnEditMenu() { Debug.Log("[UICreator] Edit (stub)"); }

        private void OnViewMenu()
        {
            ShowMenu(_btnView, ("Fullscreen Work Area", ()=> ToggleFullscreenWorkArea()));
        }

        private void OnToolsMenu()
        {
            ShowMenu(_btnTools,
                ("Add Primary Button", ()=> SpawnButton("UI_PrimaryButton", UIFactory.CreateButtonPrimary)),
                ("Add Secondary Button", ()=> SpawnButton("UI_SecondaryButton", UIFactory.CreateButtonSecondary)),
                ("Add Danger Button", ()=> SpawnButton("UI_DangerButton", UIFactory.CreateButtonDanger)),
                ("Add Panel", ()=> SpawnPanel(false)),
                ("Add Background Panel", ()=> SpawnPanel(true))
            );
        }

        private void ToggleFullscreenWorkArea()
        {
            var ctl = _root != null ? _root.GetComponent<UICreatorStageController>() : null;
            if (ctl != null)
            {
                bool target = !ctl.IsStageFullscreen;
                ctl.SetStageFullscreen(target);
                Debug.Log($"[UICreator] View/Fullscreen Work Area: {target}");
            }
        }

        // --- Spawn helpers (center of stage; placement tools come later) ---
        private void SpawnButton(string name, System.Func<Transform, string, System.Action, UnityEngine.UI.Button> ctor)
        {
            var btn = ctor(_stage, name.Replace("UI_", string.Empty), ()=>{});
            btn.gameObject.name = name;
            var rt = btn.GetComponent<RectTransform>();
            // Apply factory defaults so buttons spawned outside a LayoutGroup are visible and usable
            UIFactory.ApplyDefaultButtonSizing(rt);
            rt.anchoredPosition = Vector2.zero;
            NormalizePlaceable(rt);
            AttachEditing(rt);
            Debug.Log($"[UICreator] Spawn {name}");
        }

        private void SpawnPanel(bool background)
        {
            if (background)
            {
                var panelGO = UIFactory.CreatePanelSurface(_stage, "UI_BackgroundPanel", sizing: PanelSizing.AutoBoth);
                var rt = panelGO != null ? panelGO.GetComponent<RectTransform>() : null;
                if (rt != null)
                {
                    UIFactory.EnsureRaycastTarget(rt);
                    NormalizePlaceable(rt);
                    AttachEditing(rt);
                    Debug.Log("[UICreator] Spawn UI_BackgroundPanel");
                }
                return;
            }

            var panelGO2 = UIFactory.CreatePanelSurface(_stage, "UI_Panel", sizing: PanelSizing.AutoBoth);
            var prt = panelGO2 != null ? panelGO2.GetComponent<RectTransform>() : null;
            if (prt != null)
            {
                UIFactory.ApplyDefaultPanelSizing(prt);
                UIFactory.EnsureRaycastTarget(prt);
                NormalizePlaceable(prt);
                AttachEditing(prt);
                Debug.Log("[UICreator] Spawn UI_Panel");
            }
        }

        private void NormalizePlaceable(RectTransform t)
        {
            if (t == null) return;
            var size = t.rect.size;
            t.anchorMin = t.anchorMax = new Vector2(0, 1);
            t.pivot = new Vector2(0, 1);
            if (t.parent != _stage) t.SetParent(_stage, false);
            t.sizeDelta = size;
            if (t.sizeDelta == Vector2.zero) t.sizeDelta = new Vector2(200, 60);
            t.anchoredPosition = new Vector2(
                Mathf.Round(t.anchoredPosition.x / GridPrefs.CellSize) * GridPrefs.CellSize,
                Mathf.Round(t.anchoredPosition.y / GridPrefs.CellSize) * GridPrefs.CellSize);
        }

        private void AttachEditing(RectTransform rt)
        {
            if (rt == null) return;
            if (rt.GetComponent<UIPixelSnap>() == null) rt.gameObject.AddComponent<UIPixelSnap>();
            if (rt.GetComponent<UIDragMove>() == null) rt.gameObject.AddComponent<UIDragMove>();
            if (rt.GetComponent<UISelectionBox>() == null) rt.gameObject.AddComponent<UISelectionBox>();
        }

        private void Update()
        {
#if ENABLE_INPUT_SYSTEM
            bool g = Keyboard.current != null && Keyboard.current.gKey.wasPressedThisFrame;
            bool ctrl = Keyboard.current != null && (Keyboard.current.leftCtrlKey.isPressed || Keyboard.current.rightCtrlKey.isPressed);
            bool f4 = Keyboard.current != null && Keyboard.current.f4Key.wasPressedThisFrame;
            bool iKey = Keyboard.current != null && Keyboard.current.iKey.wasPressedThisFrame;
#else
            bool g = Input.GetKeyDown(KeyCode.G);
            bool ctrl = Input.GetKey(KeyCode.LeftControl) || Input.GetKey(KeyCode.RightControl);
            bool f4 = Input.GetKeyDown(KeyCode.F4);
            bool iKey = Input.GetKeyDown(KeyCode.I);
#endif
            if (g)
            {
                if (ctrl)
                {
                    GridPrefs.CycleCellSize();
                    _grid?.MarkDirty();
                }
                else
                {
                    GridPrefs.GridVisible = !GridPrefs.GridVisible;
                    Debug.Log($"[UICreator] Grid {(GridPrefs.GridVisible ? "on" : "off")}");
                }
            }
            if (f4)
            {
                GridPrefs.SnapEnabled = !GridPrefs.SnapEnabled;
                Debug.Log($"[UICreator] Snap {(GridPrefs.SnapEnabled ? "on" : "off")}");
            }

            if (iKey)
            {
                var sel = UISelectionBox.CurrentTarget;
                if (sel != null)
                {
                    InstructionDialog.Show(_stage, sel);
                }
                else
                {
                    Debug.Log("[UICreator] No selection for Instructions dialog");
                }
            }
        }
    }

    // Local controller that handles F11/Escape and stage fullscreen toggling.
    internal sealed class UICreatorStageController : MonoBehaviour
    {
        private RectTransform _toolbar;
        private RectTransform _stage;
        private float _toolbarFrac = 0.05f;
        private bool _isFullscreen;

        public bool IsStageFullscreen => _isFullscreen;

        public void Initialize(RectTransform toolbar, RectTransform stage, float toolbarFrac)
        {
            _toolbar = toolbar;
            _stage = stage;
            _toolbarFrac = Mathf.Clamp01(toolbarFrac);
        }

        private void Update()
        {
            if (_toolbar == null || _stage == null) return;
#if ENABLE_INPUT_SYSTEM
            bool f11 = Keyboard.current != null && Keyboard.current.f11Key.wasPressedThisFrame;
            bool esc = Keyboard.current != null && Keyboard.current.escapeKey.wasPressedThisFrame;
#else
            bool f11 = Input.GetKeyDown(KeyCode.F11);
            bool esc = Input.GetKeyDown(KeyCode.Escape);
#endif
            if (f11)
            {
                SetStageFullscreen(!_isFullscreen);
            }
            else if (esc && _isFullscreen)
            {
                SetStageFullscreen(false);
            }
        }

        public void SetStageFullscreen(bool on)
        {
            if (_toolbar == null || _stage == null) return;
            _isFullscreen = on;

            if (on)
            {
                if (_toolbar.gameObject.activeSelf) _toolbar.gameObject.SetActive(false);
                // Stage fills entire area
                SetAnchors(_stage, new Vector2(0f, 0f), new Vector2(1f, 1f));
                Debug.Log("[UICreator] View: Stage Fullscreen ON");
            }
            else
            {
                if (!_toolbar.gameObject.activeSelf) _toolbar.gameObject.SetActive(true);
                // Toolbar on top strip; stage below it.
                SetAnchors(_toolbar, new Vector2(0f, 1f - _toolbarFrac), new Vector2(1f, 1f));
                SetAnchors(_stage, new Vector2(0f, 0f), new Vector2(1f, 1f - _toolbarFrac));
                Debug.Log("[UICreator] View: Stage Fullscreen OFF");
            }
        }

        private static void SetAnchors(RectTransform rt, Vector2 min, Vector2 max)
        {
            var t = rt;
            t.anchorMin = min;
            t.anchorMax = max;
            t.offsetMin = Vector2.zero;
            t.offsetMax = Vector2.zero;
            t.anchoredPosition = Vector2.zero;
            t.localScale = Vector3.one;
        }

        private void OnDestroy()
        {
            // If screen closes while fullscreen, ensure toolbar is not left hidden in scene play mode.
            if (_toolbar != null) _toolbar.gameObject.SetActive(true);
        }
    }
}

// ===== FILE: Assets/Scripts/UI/Style/BaseUIStyle.cs =====
using UnityEngine;

namespace FantasyColony.UI.Style
{
    public static class BaseUIStyle
    {
        // Colors
        public static Color32 Gold            = Hex("#D6B25E");
        public static Color32 GoldHover       = Hex("#E4C77D");
        public static Color32 GoldPressed     = Hex("#B99443");
        public static Color32 PanelSurface    = new Color32(0x1F,0x1A,0x14, (byte)(0.95f * 255));
        // Secondary (dark) fill used for standard buttons - BRIGHTENED for better visibility on dark backgrounds
        // Old values kept in comments for reference
        // Previous: #3B3329 (0.231, 0.200, 0.161)
        public static Color32 SecondaryFill   = Hex("#5E5345"); // #5E5345
        // Secondary (dark) explicit states for visible hover/press
        // Hover: noticeably lighter than base; Pressed: slightly darker than new base
        public static Color32 SecondaryHover  = Hex("#726555"); // #726555
        public static Color32 SecondaryPressed= Hex("#4A4033"); // Slightly darker than new base
        public static Color32 Keyline         = new Color32(0x5A,0x4C,0x38, (byte)(0.60f * 255));
        public static Color32 TextPrimary     = Hex("#F1E9D2");
        public static Color32 TextSecondary   = Hex("#C9BDA2");
        public static Color32 Danger          = Hex("#B34844");
        public static Color32 DangerHover     = Hex("#C8625E");
        public static Color32 DangerPressed   = Hex("#953A37");

        // --- Textured UI assets ---
        // Resource paths (under Assets/Resources)
        public const string WoodTilePath = "ui/sprites/tile/wood_soft_tile";
        public const string DarkBorder9SPath = "ui/sprites/9slice/border_dark_9s";

        // Toggle: grayscale the wood tile before tinting (for faithful palette hues)
        public static bool UseGrayscaleTint = true; // static (not const) to avoid unreachable-code folding

        // Desired on-screen border thickness in device pixels for sliced borders
        // This single value controls both panels and buttons.
        public const float TargetBorderPx = 10f; // default visual = 10px borders

        // --- Tint themes for wood_soft_tile surfaces ---
        public struct TintTheme { public Color32 Base, Hover, Pressed; }

        // Secondary (dark) theme
        public static readonly TintTheme SecondaryTheme = new TintTheme
        {
            Base    = SecondaryFill,
            Hover   = SecondaryHover,
            Pressed = SecondaryPressed
        };

        // Gold (primary/action) theme
        public static readonly TintTheme GoldTheme = new TintTheme
        {
            Base    = Gold,
            Hover   = GoldHover,
            Pressed = GoldPressed
        };

        // Danger theme
        public static readonly TintTheme DangerTheme = new TintTheme
        {
            Base    = Danger,
            Hover   = DangerHover,
            Pressed = DangerPressed
        };

        // Overlay tints for Button.state (applied to a transparent overlay Image)
        // Keep subtle so textures are not washed out
        public static readonly Color HoverOverlay   = new Color(1f, 1f, 1f, 0.06f);
        public static readonly Color PressedOverlay = new Color(0f, 0f, 0f, 0.10f);
        public static readonly Color DisabledOverlay= new Color(0f, 0f, 0f, 0.40f);

        // Sizes
        public const int ButtonHeight = 56;
        public const int ButtonFontSize = 24;
        public const int BodyFontSize = 20;
        public const int CaptionFontSize = 18;
        public const int PanelPadding = 24;
        public const int StackSpacing = 12;
        public const int EdgeOffset = 56;

        public static Color32 Hex(string hex)
        {
            if (ColorUtility.TryParseHtmlString(hex, out var c))
                return c;
            return Color.white;
        }
    }
}

// ===== FILE: Assets/Scripts/UI/Util/GrayscaleSpriteCache.cs =====
using System.Collections.Generic;
using UnityEngine;

namespace FantasyColony.UI.Util
{
    public static class GrayscaleSpriteCache
    {
        // Cache by source texture instanceID + rect
        private class Entry
        {
            public Sprite Sprite;
            public int RefCount;
        }
        private static readonly Dictionary<string, Entry> _cache = new();

        public static Sprite Get(Sprite source)
        {
            if (source == null) return null;
            var key = MakeKey(source);
            if (_cache.TryGetValue(key, out var e))
            {
                e.RefCount++;
                return e.Sprite;
            }

            var rect = source.rect;
            var tex = source.texture;
            if (tex == null)
                return null;
            // CPU fallback requires readable textures; atlased sprites in builds are often not readable.
            if (!tex.isReadable)
            {
                Debug.LogWarning($"[GrayscaleSpriteCache] Source texture not readable for '{source.name}', skipping CPU grayscale.");
                return null;
            }
            var x = Mathf.RoundToInt(rect.x);
            var y = Mathf.RoundToInt(rect.y);
            var w = Mathf.RoundToInt(rect.width);
            var h = Mathf.RoundToInt(rect.height);

            // Read pixels from source region
            var tmp = new Texture2D(w, h, TextureFormat.RGBA32, false, false)
            {
                hideFlags = HideFlags.DontSaveInBuild | HideFlags.DontSaveInEditor
            };
            var pixels = tex.GetPixels(x, y, w, h);
            for (int i = 0; i < pixels.Length; i++)
            {
                var c = pixels[i];
                float g = (0.299f * c.r) + (0.587f * c.g) + (0.114f * c.b);
                pixels[i] = new Color(g, g, g, c.a);
            }
            tmp.SetPixels(pixels);
            tmp.Apply(false, true);

            // Create a sprite with same PPU and pivot
            var sp = Sprite.Create(tmp, new Rect(0, 0, w, h), new Vector2(0.5f, 0.5f), source.pixelsPerUnit, 0, SpriteMeshType.FullRect);
            _cache[key] = new Entry { Sprite = sp, RefCount = 1 };
            return sp;
        }

        public static void Release(Sprite source)
        {
            if (source == null) return;
            var key = MakeKey(source);
            if (!_cache.TryGetValue(key, out var e)) return;
            e.RefCount--;
            if (e.RefCount > 0) return;

            if (e.Sprite != null)
            {
                var tex = e.Sprite.texture;
                if (tex != null)
                    Object.Destroy(tex);
                Object.Destroy(e.Sprite);
            }
            _cache.Remove(key);
        }

        public static void Clear()
        {
            foreach (var e in _cache.Values)
            {
                var sp = e.Sprite;
                if (sp == null) continue;
                var tex = sp.texture;
                if (tex != null)
                    Object.Destroy(tex);
                Object.Destroy(sp);
            }
            _cache.Clear();
        }

        private static string MakeKey(Sprite s)
        {
            var r = s.rect;
            return s.texture.GetInstanceID().ToString() + ":" + r.x + "," + r.y + "," + r.width + "," + r.height + ":" + s.pixelsPerUnit;
        }
    }
}


// ===== FILE: Assets/Scripts/UI/Util/UIPixelSnap.cs =====
using UnityEngine;
using UnityEngine.UI;

namespace FantasyColony.UI.Util
{
    // Keep RectTransforms aligned to the pixel grid to avoid uneven 1px borders on 9-slice images.
    [ExecuteAlways]
    [DisallowMultipleComponent]
    public class UIPixelSnap : MonoBehaviour
    {
        RectTransform _rt;
        Canvas _canvas;

        void OnEnable()
        {
            _rt = GetComponent<RectTransform>();
            _canvas = GetComponentInParent<Canvas>();
            Snap();
        }

        void LateUpdate() => Snap();
        void OnRectTransformDimensionsChange() => Snap();

        void Snap()
        {
            if (_rt == null) return;
            if (_canvas == null) _canvas = GetComponentInParent<Canvas>();
            if (_canvas == null) return;

            float refPPU = _canvas.referencePixelsPerUnit <= 0 ? 100f : _canvas.referencePixelsPerUnit;
            float sf = _canvas.scaleFactor <= 0 ? 1f : _canvas.scaleFactor;
            float unitsPerPixel = 1f / (refPPU * sf);

            // Round anchored position
            var ap = _rt.anchoredPosition;
            ap.x = Mathf.Round(ap.x / unitsPerPixel) * unitsPerPixel;
            ap.y = Mathf.Round(ap.y / unitsPerPixel) * unitsPerPixel;
            _rt.anchoredPosition = ap;

            // Round sizeDelta
            var sd = _rt.sizeDelta;
            sd.x = Mathf.Round(sd.x / unitsPerPixel) * unitsPerPixel;
            sd.y = Mathf.Round(sd.y / unitsPerPixel) * unitsPerPixel;
            _rt.sizeDelta = sd;
        }
    }
}


// ===== FILE: Assets/Scripts/UI/Widgets/UIFactory.cs =====
using UnityEngine;
using UnityEngine.UI;
using System;
using System.Collections.Generic;
using UnityObject = UnityEngine.Object;
using System.Linq;
using FantasyColony; // for GetHierarchyPath()
using FantasyColony.UI.Style;
using FantasyColony.UI.Util;
using TintTheme = FantasyColony.UI.Style.BaseUIStyle.TintTheme;

namespace FantasyColony.UI.Widgets
{
    public enum PanelSizing { Flexible, AutoHeight, AutoWidth, AutoBoth }

 public static class UIFactory
 {
        // ===== Cached assets =====
        private static Sprite _woodTile;

        private static Sprite GetWoodTile()
        {
            if (_woodTile == null)
                _woodTile = Resources.Load<Sprite>(BaseUIStyle.WoodTilePath);
            return _woodTile;
        }

        // ===== Layout utilities =====
        public static void SetAnchorsPercent(RectTransform rt, float xMin, float xMax, float yMin, float yMax)
        {
            if (rt == null) return;
            rt.anchorMin = new Vector2(xMin, yMin);
            rt.anchorMax = new Vector2(xMax, yMax);
            rt.offsetMin = Vector2.zero;
            rt.offsetMax = Vector2.zero;
        }

    public static LayoutElement EnsureLayoutElement(GameObject go)
    {
        var le = go.GetComponent<LayoutElement>();
        if (le == null) le = go.AddComponent<LayoutElement>();
        return le;
        }

        // Cache a symmetrized version of the dark 9-slice border so L/R and T/B are equal.
        private static Sprite _darkBorderSymmetric;
        private static Material _grayscaleTintMat;

        // Tracks CPU-generated grayscale sprites so they can be released.
        private class GrayscaleTracker : MonoBehaviour
        {
            public Sprite Source;
            public Sprite Gray;

            private void OnDestroy()
            {
                if (Source != null)
                {
                    GrayscaleSpriteCache.Release(Source);
                    Source = null;
                    Gray = null;
                }
            }
        }

        // ---- Button sizing helpers (safe defaults when outside a LayoutGroup) ----
        /// <summary>
        /// Returns true if any parent has a LayoutGroup (Horizontal/Vertical/Grid).
        /// </summary>
        public static bool ParentHasLayoutGroup(Transform t)
        {
            if (t == null) return false;
            Transform p = t.parent;
            while (p != null)
            {
                if (p.GetComponent<HorizontalLayoutGroup>() != null ||
                    p.GetComponent<VerticalLayoutGroup>()   != null ||
                    p.GetComponent<GridLayoutGroup>()       != null)
                    return true;
                p = p.parent;
            }
            return false;
        }

        public static RectTransform[] SplitPercentH(Transform parent, params float[] percents)
        {
            if (parent == null || percents == null || percents.Length == 0) return Array.Empty<RectTransform>();
            float total = 0f; foreach (var f in percents) total += Mathf.Max(0f, f);
            if (total <= 0f) return Array.Empty<RectTransform>();
            float x = 0f;
            var list = new List<RectTransform>(percents.Length);
            for (int i = 0; i < percents.Length; i++)
            {
                float w = Mathf.Max(0f, percents[i]) / total;
                var go = new GameObject($"H{i}", typeof(RectTransform));
                var rt = go.GetComponent<RectTransform>();
                rt.SetParent(parent, false);
                SetAnchorsPercent(rt, x, x + w, 0f, 1f);
                list.Add(rt);
                x += w;
            }
            return list.ToArray();
        }

        public static RectTransform[] SplitPercentV(Transform parent, params float[] percents)
        {
            if (parent == null || percents == null || percents.Length == 0) return Array.Empty<RectTransform>();
            float total = 0f; foreach (var f in percents) total += Mathf.Max(0f, f);
            if (total <= 0f) return Array.Empty<RectTransform>();
            float y = 0f;
            var list = new List<RectTransform>(percents.Length);
            for (int i = 0; i < percents.Length; i++)
            {
                float h = Mathf.Max(0f, percents[i]) / total;
                var go = new GameObject($"V{i}", typeof(RectTransform));
                var rt = go.GetComponent<RectTransform>();
                rt.SetParent(parent, false);
                SetAnchorsPercent(rt, 0f, 1f, y, y + h);
                list.Add(rt);
                y += h;
            }
            return list.ToArray();
        }

        /// <summary>
        /// Apply sane default sizing to a Button's RectTransform when not controlled by a LayoutGroup.
        /// In a free (no-layout) container, set explicit size; in a layout, only ensure a stable height.
        /// Idempotent.
        /// </summary>
        public static void ApplyDefaultButtonSizing(RectTransform rt, Vector2? freeSize = null)
        {
            if (rt == null) return;
            var size = freeSize ?? new Vector2(240f, 64f);
            var le = rt.GetComponent<LayoutElement>();
            if (le == null) le = rt.gameObject.AddComponent<LayoutElement>();

            if (!ParentHasLayoutGroup(rt))
            {
                // Free stage: give it an explicit, visible size centered on the stage.
                rt.anchorMin = rt.anchorMax = new Vector2(0.5f, 0.5f);
                rt.pivot = new Vector2(0.5f, 0.5f);
                rt.sizeDelta = size;
                rt.anchoredPosition = Vector2.zero;
                // Allow later manual resizing by authoring tools
                le.minWidth = 0f; le.preferredWidth = 0f; le.flexibleWidth = 0f;
                le.minHeight = 0f; le.preferredHeight = size.y; le.flexibleHeight = 0f;
            }
            else
            {
                // In a LayoutGroup: don't force width; provide a sensible preferred height for the row.
                le.minWidth = 0f; le.preferredWidth = 0f; le.flexibleWidth = 0f;
                le.minHeight = 0f; le.preferredHeight = 48f; le.flexibleHeight = 0f;
            }
        }

        public static void ApplyDefaultPanelSizing(RectTransform rt, Vector2? freeSize = null)
        {
            if (rt == null) return;
            var size = freeSize ?? new Vector2(480f, 320f);
            var le = rt.GetComponent<LayoutElement>(); if (le == null) le = rt.gameObject.AddComponent<LayoutElement>();
            if (!ParentHasLayoutGroup(rt))
            {
                rt.anchorMin = rt.anchorMax = new Vector2(0.5f, 0.5f);
                rt.pivot = new Vector2(0.5f, 0.5f);
                rt.sizeDelta = size;
                rt.anchoredPosition = Vector2.zero;
            }
            le.minWidth = 0f; le.preferredWidth = 0f; le.flexibleWidth = 0f;
            le.minHeight = 0f; le.preferredHeight = size.y; le.flexibleHeight = 0f;
        }

        // ---- Dropdown Menu ----
        public struct MenuItem
        {
            public string Label;
            public Action OnClick;
            public bool Separator;

            public MenuItem(string label, Action onClick)
            {
                Label = label;
                OnClick = onClick;
                Separator = false;
            }

            public static MenuItem Sep() => new MenuItem { Label = string.Empty, OnClick = null, Separator = true };
        }

        /// <summary>
        /// Build a dropdown menu under an anchor. The overlay must be a full-screen RectTransform with no LayoutGroup.
        /// Returns the dropdown root (caller manages its lifetime).
        /// </summary>
        public static RectTransform CreateDropdownMenu(
            RectTransform overlay,
            RectTransform anchor,
            IList<MenuItem> items,
            float rowHeight = 32f,
            float minWidth = 160f,
            bool matchAnchorWidth = true)
        {
            if (overlay == null || anchor == null) return null;

            var root = new GameObject("Dropdown", typeof(RectTransform)).GetComponent<RectTransform>();
            root.SetParent(overlay, false);

            var canvas = overlay.GetComponentInParent<Canvas>();

            Action<RectTransform> populateItems = contentRT =>
            {
                foreach (var it in items)
                {
                    if (it.Separator)
                    {
                        var sep = new GameObject("Sep", typeof(RectTransform), typeof(Image));
                        var srt = sep.GetComponent<RectTransform>();
                        srt.SetParent(contentRT, false);
                        var le = sep.AddComponent<LayoutElement>();
                        var scale = canvas != null ? Mathf.Max(1f, canvas.scaleFactor) : 1f;
                        le.preferredHeight = 1f / scale; // crisp 1 physical pixel
                        continue;
                    }

                    var row = CreateButtonSecondary(contentRT, it.Label, () => it.OnClick?.Invoke());
                    var le2 = row.GetComponent<LayoutElement>();
                    if (le2 == null) le2 = row.gameObject.AddComponent<LayoutElement>();
                    le2.preferredHeight = rowHeight;
                    le2.flexibleWidth = 1f;
                }
            };

        // Build first, then measure, then attach-and-clamp using real size
        var anchorRT = anchor.GetComponent<RectTransform>();
        root.anchorMin = root.anchorMax = new Vector2(0f, 1f);
        root.pivot = new Vector2(0f, 1f);

        // --- BUILD PANEL & ITEMS FIRST ---
        var panel = CreatePanelSurface(root, "DropdownPanel", sizing: PanelSizing.AutoHeight);
        var content = new GameObject("Content", typeof(RectTransform), typeof(VerticalLayoutGroup));
        content.transform.SetParent(panel.transform, false);
        var contentRT = content.GetComponent<RectTransform>();
        contentRT.anchorMin = new Vector2(0f, 1f);
        contentRT.anchorMax = new Vector2(1f, 1f);
        contentRT.pivot = new Vector2(0f, 1f);
        contentRT.offsetMin = new Vector2(0f, 0f);
        contentRT.offsetMax = new Vector2(0f, 0f);
        var vlg = content.GetComponent<VerticalLayoutGroup>();
        vlg.childControlWidth = true;
        vlg.childControlHeight = true;
        vlg.childForceExpandWidth = true;
        vlg.childForceExpandHeight = false;
        vlg.spacing = 2f;
        vlg.padding = new RectOffset(2, 2, 2, 2);

        // Populate items now so layout has real height
        populateItems?.Invoke(contentRT);

        // --- MEASURE & POSITION ---
        Camera cam = null;
        var parentCanvas = overlay.GetComponentInParent<Canvas>();
        if (parentCanvas != null && parentCanvas.renderMode != RenderMode.ScreenSpaceOverlay)
            cam = parentCanvas.worldCamera != null ? parentCanvas.worldCamera : Camera.main;

        // Rebuild to get real size
        LayoutRebuilder.ForceRebuildLayoutImmediate(panel.GetComponent<RectTransform>());
        var panelRt = panel.GetComponent<RectTransform>();
        var size = panelRt.rect.size;

        // Ensure root matches panel size so we clamp correctly
        root.sizeDelta = size;

        // Convert button bottom-left to overlay local (top-left space)
        Vector3[] corners = new Vector3[4];
        anchorRT.GetWorldCorners(corners);
        Vector2 screenBL = RectTransformUtility.WorldToScreenPoint(cam, corners[0]);
        Vector2 localBL;
        RectTransformUtility.ScreenPointToLocalPointInRectangle(overlay, screenBL, cam, out localBL);
        Vector2 overlayTopLeft = new Vector2(-overlay.rect.width * overlay.pivot.x, overlay.rect.height * (1f - overlay.pivot.y));
        Vector2 anchored = localBL - overlayTopLeft; // attach top of dropdown to bottom of button

        // Clamp X within overlay
        float maxX = overlay.rect.width - size.x;
        anchored.x = Mathf.Clamp(anchored.x, 0f, maxX);

        // Clamp/flip Y in top-left space
        float maxY = overlay.rect.height - size.y;
        if (anchored.y + size.y > overlay.rect.height)
        {
            // place above using top-left corner of button
            Vector2 screenTL = RectTransformUtility.WorldToScreenPoint(cam, corners[1]);
            Vector2 localTL;
            RectTransformUtility.ScreenPointToLocalPointInRectangle(overlay, screenTL, cam, out localTL);
            anchored.y = Mathf.Clamp((localTL - overlayTopLeft).y - size.y, 0f, maxY);
            Debug.Log("[UIFactory] Dropdown flipped above (bottom clamp)");
        }
        else
        {
            anchored.y = Mathf.Clamp(anchored.y, 0f, maxY);
        }

        root.anchoredPosition = anchored;
        root.SetAsLastSibling();
        return root;
        }

        // Ensure the 9-slice border has equal left/right and top/bottom edge sizes.
        // This avoids visual asymmetry when Unity stretches the sliced edges.
        private static Sprite GetSymmetricDarkBorder()
        {
            if (_darkBorderSymmetric != null)
                return _darkBorderSymmetric;

            var src = Resources.Load<Sprite>(BaseUIStyle.DarkBorder9SPath);
            if (src == null)
                return null;

            _darkBorderSymmetric = MakeUniformBorderFromTopBottom(src);
            return _darkBorderSymmetric;
        }

        private static Material GetGrayscaleTintMaterial()
        {
            if (_grayscaleTintMat != null) return _grayscaleTintMat;
            // Load from Resources to ensure inclusion in builds
            var sh = Resources.Load<Shader>("Shaders/UIGrayscaleTint");
            if (sh == null)
            {
                Debug.LogWarning("UIFactory: Shader 'UI/GrayscaleTint' not found in Resources. Will fall back to CPU grayscale.");
                return null;
            }
            _grayscaleTintMat = new Material(sh)
            {
                hideFlags = HideFlags.DontSaveInBuild | HideFlags.DontSaveInEditor
            };
            return _grayscaleTintMat;
        }

        private static void ApplyTintMaterial(Image img)
        {
            if (img == null) return;
            if (!BaseUIStyle.UseGrayscaleTint)
                return; // use default
            var tracker = img.GetComponent<GrayscaleTracker>();
            var src = img.sprite;

            if (tracker != null)
            {
                // If this image currently uses a tracked grayscale sprite, recover the original source.
                if (tracker.Gray != null && img.sprite == tracker.Gray)
                    src = tracker.Source;
                // If sprite changed away from tracked grayscale, release previous.
                else if (tracker.Source != null && tracker.Gray != null && img.sprite != tracker.Gray)
                {
                    GrayscaleSpriteCache.Release(tracker.Source);
                    tracker.Source = null;
                    tracker.Gray = null;
                }
            }

            var mat = GetGrayscaleTintMaterial();
            if (mat == null)
            {
                // Fallback: CPU grayscale sprite, then let UI/Default tint it
                var gray = (tracker != null && tracker.Source == src && tracker.Gray != null)
                    ? tracker.Gray
                    : GrayscaleSpriteCache.Get(src);
                if (gray != null)
                {
                    if (tracker == null) tracker = img.gameObject.AddComponent<GrayscaleTracker>();

                    img.sprite = gray;
                    img.material = null;
                    tracker.Source = src;
                    tracker.Gray = gray;
                }
                else if (tracker != null && tracker.Source == null)
                {
                    UnityObject.Destroy(tracker);
                }
                Debug.LogWarning($"UIFactory: Using CPU grayscale fallback on {img.transform.GetHierarchyPath()}.");
                return;
            }

            // Using shader-based tinting; ensure any tracked sprite is released
            if (tracker != null && tracker.Source != null)
            {
                GrayscaleSpriteCache.Release(tracker.Source);
                tracker.Source = null;
                tracker.Gray = null;
                UnityObject.Destroy(tracker);
                tracker = null;
            }

            img.material = new Material(mat); // per-image instance
            img.SetMaterialDirty();
            // Runtime verification (no editor guard):
            var actual = img.materialForRendering != null ? img.materialForRendering.shader.name : "<null>";
            if (actual != "UI/GrayscaleTint")
                Debug.LogWarning($"UIFactory: Expected 'UI/GrayscaleTint' but got '{actual}' on {img.transform.GetHierarchyPath()}.");
            else
                Debug.Log($"UIFactory: GrayscaleTint OK on {img.transform.GetHierarchyPath()}.");
        }

        private static Sprite MakeUniformBorderFromTopBottom(Sprite src)
        {
            // Unity's Sprite.border order: (left, bottom, right, top)
            // Ensure we compare Top (w) and Bottom (y).
            var b = src.border;
            // Force all four edges to match the thinner of Top/Bottom to keep corners safe
            float tb = Mathf.Min(b.w, b.y);
            
            // Sprite.Create expects pivot relative to rect (0..1). Convert existing pixel pivot.
            var rect = src.rect;
            var pivotNormalized = new Vector2(
                rect.width  > 0 ? src.pivot.x / rect.width  : 0.5f,
                rect.height > 0 ? src.pivot.y / rect.height : 0.5f
            );

            var sym = Sprite.Create(
                src.texture,
                rect,
                pivotNormalized,
                src.pixelsPerUnit,
                0,
                SpriteMeshType.FullRect,
                new Vector4(tb, tb, tb, tb)
            );
            return sym;
        }

        // Compute a pixelsPerUnitMultiplier that yields a precise on-screen thickness in pixels for the 9-slice edges.
        // Assumes the Sprite has equal borders on all sides (enforced by GetSymmetricDarkBorder).
        // Formula: displayed_px ≈ slice_px / (spritePPU * multiplier) * canvasRefPPU * canvasScaleFactor
        // We solve for multiplier so displayed_px == targetPixels.
        private static float ComputeBorderScale(Sprite s, float targetPixels, float canvasRefPPU, float canvasScaleFactor)
        {
            if (s == null) return 1f;
            float borderPx = s.border.w; // any side; they're equal
            float tpx = Mathf.Max(0.0001f, targetPixels);
            float spritePPU = Mathf.Max(0.0001f, s.pixelsPerUnit);
            float refPPU = Mathf.Max(0.0001f, canvasRefPPU);
            float scale = Mathf.Max(0.0001f, canvasScaleFactor);
            // Solve: targetPixels = borderPx / (spritePPU * m) * refPPU * scale
            float m = (borderPx * refPPU * scale) / (spritePPU * tpx);
            return Mathf.Max(0.0001f, m);
        }

        // Find nearest parent Canvas to get the current Canvas.scaleFactor (for pixel-accurate computation)
        private static float GetCanvasScaleFactor(Transform t)
        {
            var canvas = t.GetComponentInParent<Canvas>();
            if (canvas != null) return canvas.scaleFactor <= 0f ? 1f : canvas.scaleFactor;
            return 1f;
        }

        private static float GetCanvasRefPPU(Transform t)
        {
            var canvas = t.GetComponentInParent<Canvas>();
            if (canvas != null)
            {
                return canvas.referencePixelsPerUnit <= 0f ? 100f : canvas.referencePixelsPerUnit;
            }
            return 100f;
        }

        private static void AttachPixelSnap(Component c)
        {
            if (c == null) return;
            if (c.gameObject.GetComponent<UIPixelSnap>() == null)
                c.gameObject.AddComponent<UIPixelSnap>();
        }

        private static RectTransform CreateUIObject(string name, Transform parent)
        {
            var go = new GameObject(name, typeof(RectTransform));
            var rt = go.GetComponent<RectTransform>();
            go.transform.SetParent(parent, false);
            return rt;
        }

        private static void Stretch(RectTransform rt)
        {
            rt.anchorMin = Vector2.zero;
            rt.anchorMax = Vector2.one;
            rt.offsetMin = Vector2.zero;
            rt.offsetMax = Vector2.zero;
        }

        public static LayoutElement SetFlex(RectTransform rt, float flexW = 0f, float flexH = 0f, float prefW = -1f, float prefH = -1f)
        {
            var le = rt.GetComponent<LayoutElement>() ?? rt.gameObject.AddComponent<LayoutElement>();
            le.flexibleWidth = flexW;
            le.flexibleHeight = flexH;
            le.preferredWidth = prefW;
            le.preferredHeight = prefH;
            return le;
        }

        public static (RectTransform root, RectTransform content) CreateScreenOverlay(Transform parent, string name = "ScreenOverlay", bool dim = false)
        {
            var root = CreateUIObject(name, parent);
            Stretch(root);
            var img = root.gameObject.AddComponent<Image>();
            var woodBg = GetWoodTile();
            if (woodBg == null)
                Debug.LogWarning($"UIFactory: Wood tile sprite missing at {BaseUIStyle.WoodTilePath} for {root.GetHierarchyPath()}");
            img.sprite = woodBg;
            img.type = Image.Type.Tiled;
            img.raycastTarget = true;
            img.color = dim ? new Color(0f, 0f, 0f, 0.5f) : Color.white;
            var content = CreateUIObject("Content", root);
            Stretch(content);
            return (root, content);
        }

        public static (RectTransform a, RectTransform b) SplitHorizontal(RectTransform parent, float leftPct, int gapPx = 0)
        {
            leftPct = Mathf.Clamp01(leftPct);
            var a = CreateUIObject("Left", parent);
            var b = CreateUIObject("Right", parent);
            a.anchorMin = new Vector2(0,0); a.anchorMax = new Vector2(leftPct,1);
            a.offsetMin = new Vector2(0,0); a.offsetMax = new Vector2(-gapPx/2f,0);
            b.anchorMin = new Vector2(leftPct,0); b.anchorMax = new Vector2(1,1);
            b.offsetMin = new Vector2(gapPx/2f,0); b.offsetMax = new Vector2(0,0);
            return (a,b);
        }

        public static (RectTransform a, RectTransform b) SplitVertical(RectTransform parent, float topPct, int gapPx = 0)
        {
            topPct = Mathf.Clamp01(topPct);
            var a = CreateUIObject("Top", parent);
            var b = CreateUIObject("Bottom", parent);
            a.anchorMin = new Vector2(0,1-topPct); a.anchorMax = new Vector2(1,1);
            a.offsetMin = new Vector2(0,gapPx/2f); a.offsetMax = new Vector2(0,0);
            b.anchorMin = new Vector2(0,0); b.anchorMax = new Vector2(1,1-topPct);
            b.offsetMin = new Vector2(0,0); b.offsetMax = new Vector2(0,-gapPx/2f);
            return (a,b);
        }

        public static RectTransform Inset(RectTransform parent, int l = 0, int r = 0, int t = 0, int b = 0)
        {
            var c = CreateUIObject("Inset", parent);
            c.anchorMin = Vector2.zero; c.anchorMax = Vector2.one;
            c.offsetMin = new Vector2(l, b); c.offsetMax = new Vector2(-r, -t);
            return c;
        }

        // ===== Board helpers (snap panels together) =====
        public readonly struct Board
        {
            public readonly RectTransform Root;    // fullscreen container (HorizontalLayoutGroup lives elsewhere)
            public readonly RectTransform Content; // padded inner area
            public Board(RectTransform root, RectTransform content) { Root = root; Content = content; }
        }

        /// <summary>
        /// Creates a full-screen tiled wood background and returns a padded content area for placing columns.
        /// </summary>
        public static Board CreateBoardScreen(Transform parent, float padding = 32f, float spacing = 16f)
        {
            var root = CreateUIObject("BoardRoot", parent);
            Stretch(root);

            // Background (tiled wood) that ignores layout
            var woodBg = GetWoodTile();
            if (woodBg == null)
                Debug.LogWarning($"UIFactory: Wood tile sprite missing at {BaseUIStyle.WoodTilePath} for {root.GetHierarchyPath()}");
            var bg = CreateFullscreenBackground(root, woodBg, new Color(0.05f, 0.04f, 0.03f, 1f));
            bg.type = Image.Type.Tiled;
            var bgLE = bg.gameObject.AddComponent<LayoutElement>();
            bgLE.ignoreLayout = true;
            bg.rectTransform.SetAsFirstSibling();

            // Padded content
            var content = CreateUIObject("BoardContent", root);
            var hl = content.gameObject.AddComponent<HorizontalLayoutGroup>();
            hl.childForceExpandWidth = true;
            hl.childForceExpandHeight = true;
            hl.spacing = spacing;
            hl.padding = new RectOffset((int)padding, (int)padding, (int)padding, (int)padding);
            return new Board(root, content);
        }

        /// <summary>
        /// Creates three columns that snap decor together: left/right fixed widths, center flexible.
        /// </summary>
        public static (RectTransform left, RectTransform center, RectTransform right) CreateThreeColumnBoard(RectTransform parent, float leftWidth, float rightWidth, bool joinDecor = true)
        {
            var left = CreateColumn(parent, "LeftColumn", preferredWidth: leftWidth, flexibleWidth: 0);
            var center = CreateColumn(parent, "CenterColumn", preferredWidth: -1, flexibleWidth: 1);
            var right = CreateColumn(parent, "RightColumn", preferredWidth: rightWidth, flexibleWidth: 0);

            if (joinDecor)
            {
                JoinHorizontal(left, center);
                JoinHorizontal(center, right);
            }
            return (left, center, right);
        }

        /// <summary>
        /// Creates a panel-surface column with width behavior already configured.
        /// </summary>
        public static RectTransform CreateColumn(Transform parent, string name, float preferredWidth, float flexibleWidth, bool showFrame = true)
        {
            // Columns are structural: they must fill their slot. Use Flexible sizing explicitly.
            var panel = CreatePanelSurface(parent, name, sizing: PanelSizing.Flexible);
            SetPanelDecorVisible(panel, true);
            if (!showFrame) SetPanelBorders(panel, false, false, false, false);

            var le = panel.GetComponent<LayoutElement>() ?? panel.gameObject.AddComponent<LayoutElement>();
            le.preferredWidth  = preferredWidth;
            le.flexibleWidth   = flexibleWidth;
            le.minWidth        = preferredWidth > 0 ? preferredWidth - 60f : 0f;
            return panel;
        }

        /// <summary>
        /// Hides/shows specific frame edges so adjacent panels "join" without double seams.
        /// Assumes CreatePanelSurface creates children named: BG_Fill (Image), Frame (Image or container).
        /// If Frame is a single 9-slice Image, we mask edges by overlaying thin images.
        /// </summary>
        public static void SetPanelBorders(RectTransform panel, bool left = true, bool right = true, bool top = true, bool bottom = true)
        {
            var frame = panel.Find("Frame");
            if (frame == null) return;
            var frameImg = frame.GetComponent<Image>();
            if (frameImg != null)
            {
                // Simple approach: keep the 9-slice, but add masking quads on hidden edges
                EnsureEdgeMask(panel, "Mask_L", new Vector2(0f, 0.5f), new Vector2(0f, 0.5f), new Vector2(4f, 0f)).gameObject.SetActive(!left);
                EnsureEdgeMask(panel, "Mask_R", new Vector2(1f, 0.5f), new Vector2(1f, 0.5f), new Vector2(4f, 0f)).gameObject.SetActive(!right);
                EnsureEdgeMask(panel, "Mask_T", new Vector2(0.5f, 1f), new Vector2(0.5f, 1f), new Vector2(0f, 4f)).gameObject.SetActive(!top);
                EnsureEdgeMask(panel, "Mask_B", new Vector2(0.5f, 0f), new Vector2(0.5f, 0f), new Vector2(0f, 4f)).gameObject.SetActive(!bottom);
                return;
            }
        }

        private static RectTransform EnsureEdgeMask(Transform parent, string name, Vector2 anchorMin, Vector2 anchorMax, Vector2 size)
        {
            var t = parent.Find(name) as RectTransform;
            if (t == null)
            {
                t = CreateUIObject(name, parent);
                var img = t.gameObject.AddComponent<Image>();
                img.color = new Color(0f, 0f, 0f, 1f); // matches border color
            }
            t.anchorMin = anchorMin;
            t.anchorMax = anchorMax;
            t.sizeDelta = size;
            t.anchoredPosition = Vector2.zero;
            t.SetAsLastSibling();
            return t;
        }

        public static void JoinHorizontal(RectTransform left, RectTransform right)
        {
            var lf = left.GetComponent<UIFrame>();
            var rf = right.GetComponent<UIFrame>();
            if (lf != null || rf != null)
            {
                if (lf != null) lf.SetEdges(true, false, true, true);
                if (rf != null) rf.SetEdges(false, true, true, true);
            }
            else
            {
                SetPanelBorders(left,  left: true,  right: false, top: true, bottom: true);
                SetPanelBorders(right, left: false, right: true,  top: true, bottom: true);
            }
        }

        public static void JoinVertical(RectTransform top, RectTransform bottom)
        {
            var tf = top.GetComponent<UIFrame>();
            var bf = bottom.GetComponent<UIFrame>();
            if (tf != null || bf != null)
            {
                if (tf != null) tf.SetEdges(true, true, true, false);
                if (bf != null) bf.SetEdges(true, true, false, true);
            }
            else
            {
                SetPanelBorders(top, left: true, right: true, top: true, bottom: false);
                SetPanelBorders(bottom, left: true, right: true, top: false, bottom: true);
            }
        }

        public static RectTransform CreateRow(Transform parent, float spacing = 8f)
        {
            var row = new GameObject("Row", typeof(RectTransform));
            var rt = row.GetComponent<RectTransform>();
            rt.SetParent(parent, false);
            var h = row.AddComponent<HorizontalLayoutGroup>();
            h.spacing = spacing;
            h.padding = new RectOffset(0, 0, 0, 0);
            h.childAlignment = TextAnchor.MiddleLeft;
            h.childControlHeight = true;
            h.childForceExpandHeight = true;
            h.childControlWidth = true;
            h.childForceExpandWidth = true;
            return rt;
        }

        public static RectTransform CreateCol(Transform parent, float spacing = 8f)
        {
            var col = new GameObject("Col", typeof(RectTransform));
            var rt = col.GetComponent<RectTransform>();
            rt.SetParent(parent, false);
            var v = col.AddComponent<VerticalLayoutGroup>();
            v.spacing = spacing;
            v.padding = new RectOffset(0, 0, 0, 0);
            v.childAlignment = TextAnchor.UpperLeft;
            v.childControlHeight = true;
            v.childForceExpandHeight = true;
            v.childControlWidth = true;
            v.childForceExpandWidth = true;
            return rt;
        }

        public static RectTransform CreateSpacer(Transform parent, float flexW = 1f)
        {
            var go = new GameObject("Spacer", typeof(RectTransform));
            var rt = go.GetComponent<RectTransform>();
            rt.SetParent(parent, false);
            var le = go.AddComponent<LayoutElement>();
            le.flexibleWidth = flexW;
            le.minWidth = 0f;
            return rt;
        }

        /// <summary>
        /// Themed horizontal rule for visual separation. Uses theme border tone.
        /// </summary>
        public static Image CreateRuleHorizontal(Transform parent, float thickness = 2f, float alpha = 0.65f)
        {
            var rt = CreateUIObject("Rule_H", parent);
            var img = rt.gameObject.AddComponent<Image>();
            img.color = new Color(0f, 0f, 0f, alpha);
            var le = rt.gameObject.AddComponent<LayoutElement>();
            le.minHeight = thickness;
            le.preferredHeight = thickness;
            le.flexibleHeight = 0f;
            // Stretch full width within its layout group
            rt.anchorMin = new Vector2(0, 0.5f);
            rt.anchorMax = new Vector2(1, 0.5f);
            rt.offsetMin = Vector2.zero;
            rt.offsetMax = Vector2.zero;
            return img;
        }

        // PANEL (Textured wood fill + dark 9-slice border)
        public static RectTransform CreatePanelSurface(Transform parent, string name = "Panel", TintTheme? theme = null, PanelSizing sizing = PanelSizing.AutoBoth)
        {
            var go = new GameObject(name, typeof(RectTransform), typeof(CanvasRenderer), typeof(Image), typeof(VerticalLayoutGroup));
            go.transform.SetParent(parent, false);

            var rt = go.GetComponent<RectTransform>();
            var rootImg = go.GetComponent<Image>();

            // Layout configuration (unchanged)
            var layout = go.GetComponent<VerticalLayoutGroup>();
            layout.spacing = BaseUIStyle.StackSpacing;
            layout.padding = new RectOffset(BaseUIStyle.PanelPadding, BaseUIStyle.PanelPadding, BaseUIStyle.PanelPadding, BaseUIStyle.PanelPadding);
            layout.childControlWidth = true;
            layout.childControlHeight = true;
            layout.childForceExpandWidth = false;
            layout.childForceExpandHeight = false;
            var fitter = go.GetComponent<ContentSizeFitter>();
            if (sizing == PanelSizing.Flexible)
            {
                if (fitter) UnityEngine.Object.DestroyImmediate(fitter);
                SetFlex(rt, flexW: 1f, flexH: 1f);
            }
            else
            {
                if (fitter == null) fitter = go.AddComponent<ContentSizeFitter>();
                fitter.horizontalFit = (sizing == PanelSizing.AutoBoth || sizing == PanelSizing.AutoWidth) ? ContentSizeFitter.FitMode.PreferredSize : ContentSizeFitter.FitMode.Unconstrained;
                fitter.verticalFit   = (sizing == PanelSizing.AutoBoth || sizing == PanelSizing.AutoHeight) ? ContentSizeFitter.FitMode.PreferredSize : ContentSizeFitter.FitMode.Unconstrained;
            }

            // --- Fill (tiled wood) ---
            var fillGO = new GameObject("BG_Fill", typeof(RectTransform), typeof(CanvasRenderer), typeof(Image), typeof(LayoutElement));
            fillGO.transform.SetParent(go.transform, false);
            var fillRt = fillGO.GetComponent<RectTransform>();
            fillRt.anchorMin = Vector2.zero; fillRt.anchorMax = Vector2.one;
            fillRt.offsetMin = Vector2.zero; fillRt.offsetMax = Vector2.zero;
            var fillImg = fillGO.GetComponent<Image>();
            fillImg.raycastTarget = false;
            var le = fillGO.GetComponent<LayoutElement>();
            le.ignoreLayout = true;
            var wood = GetWoodTile();
            if (wood == null)
                Debug.LogWarning($"UIFactory: Wood tile sprite missing at {BaseUIStyle.WoodTilePath} for {fillGO.transform.GetHierarchyPath()}");
            fillImg.sprite = wood;
            fillImg.type = Image.Type.Tiled;
            fillImg.preserveAspect = false;
            ApplyTintMaterial(fillImg);
            var panelTheme = theme ?? BaseUIStyle.SecondaryTheme;
            fillImg.color = panelTheme.Base;
            // --- Pixel-precise frame instead of 9-slice Image ---
            var borderGO = new GameObject("Frame", typeof(RectTransform), typeof(CanvasRenderer), typeof(LayoutElement), typeof(UIFrame));
            borderGO.transform.SetParent(go.transform, false);
            var borderRt = borderGO.GetComponent<RectTransform>();
            borderRt.anchorMin = Vector2.zero; borderRt.anchorMax = Vector2.one;
            borderRt.offsetMin = Vector2.zero; borderRt.offsetMax = Vector2.zero;
            borderGO.GetComponent<LayoutElement>().ignoreLayout = true;
            var frame = borderGO.GetComponent<UIFrame>();
            var border = GetSymmetricDarkBorder();
            frame.Init(border, BaseUIStyle.TargetBorderPx, Color.white);

            // Root image no longer draws visuals; keep it disabled but present for easy toggling
            rootImg.enabled = false;
            rootImg.raycastTarget = false;

            // Pixel snap to avoid uneven vertical vs horizontal edges
            AttachPixelSnap(go.transform);
            AttachPixelSnap(borderGO.transform);

            // Ensure BG_Fill under Frame
            var fill = go.transform.Find("BG_Fill");
            var borderT = go.transform.Find("Frame");
            if (fill) fill.SetSiblingIndex(0);
            if (borderT) borderT.SetSiblingIndex(1);

            return rt;
        }

        // BUTTONS
        public static Button CreateButtonPrimary(Transform parent, string label, Action onClick) => CreateButton(parent, label, BaseUIStyle.TextSecondary, onClick, BaseUIStyle.GoldTheme);
        public static Button CreateButtonSecondary(Transform parent, string label, Action onClick) => CreateButton(parent, label, BaseUIStyle.TextPrimary, onClick, BaseUIStyle.SecondaryTheme);
        public static Button CreateButtonDanger(Transform parent, string label, Action onClick) => CreateButton(parent, label, BaseUIStyle.TextSecondary, onClick, BaseUIStyle.DangerTheme);

        // Textured button: tiled wood fill + 9-slice dark border; wood itself tints for state changes
        private static Button CreateButton(Transform parent, string label, Color textColor, Action onClick, TintTheme theme)
        {
            var go = new GameObject($"Button_{label}", typeof(RectTransform), typeof(CanvasRenderer), typeof(Image), typeof(Button), typeof(LayoutElement));
            go.transform.SetParent(parent, false);

            var rt = go.GetComponent<RectTransform>();
            rt.sizeDelta = new Vector2(380, BaseUIStyle.ButtonHeight);

            // Root image handles raycasts, but does not draw visuals
            var rootImg = go.GetComponent<Image>();
            rootImg.sprite = null; rootImg.color = new Color(0,0,0,0); rootImg.raycastTarget = true;
            var btn = go.GetComponent<Button>();

            // --- Background fill (wood, tiled) ---
            var fillGO = new GameObject("BG_Fill", typeof(RectTransform), typeof(CanvasRenderer), typeof(Image), typeof(LayoutElement));
            fillGO.transform.SetParent(go.transform, false);
            var fillRt = fillGO.GetComponent<RectTransform>();
            fillRt.anchorMin = Vector2.zero; fillRt.anchorMax = Vector2.one;
            fillRt.offsetMin = Vector2.zero; fillRt.offsetMax = Vector2.zero; // full-bleed wood
            var fillImg = fillGO.GetComponent<Image>();
            fillImg.raycastTarget = false;
            fillImg.preserveAspect = false;
            fillGO.GetComponent<LayoutElement>().ignoreLayout = true;
            var wood = GetWoodTile();
            if (wood == null)
                Debug.LogWarning($"UIFactory: Wood tile sprite missing at {BaseUIStyle.WoodTilePath} for {fillGO.transform.GetHierarchyPath()}");
            fillImg.sprite = wood;
            fillImg.type = Image.Type.Tiled;
            ApplyTintMaterial(fillImg);
            fillImg.color = theme.Base; // tint the wood itself
            // --- Pixel-precise frame instead of 9-slice Image ---
            var borderGO = new GameObject("Frame", typeof(RectTransform), typeof(CanvasRenderer), typeof(LayoutElement), typeof(UIFrame));
            borderGO.transform.SetParent(go.transform, false);
            var borderRt = borderGO.GetComponent<RectTransform>();
            borderRt.anchorMin = Vector2.zero; borderRt.anchorMax = Vector2.one;
            borderRt.offsetMin = Vector2.zero; borderRt.offsetMax = Vector2.zero;
            borderGO.GetComponent<LayoutElement>().ignoreLayout = true;
            var frame = borderGO.GetComponent<UIFrame>();
            var border = GetSymmetricDarkBorder();
            frame.Init(border, BaseUIStyle.TargetBorderPx, Color.white);

            // Button setup
            btn.transition = Selectable.Transition.ColorTint;
            // Make the wood fill the targetGraphic so the texture itself tints for state changes
            btn.targetGraphic = fillImg;
            var cb = btn.colors;
            cb.colorMultiplier = 1f;
            cb.fadeDuration = 0.08f;
            cb.normalColor      = theme.Base;
            cb.highlightedColor = theme.Hover;
            cb.pressedColor     = theme.Pressed;
            cb.selectedColor    = theme.Base;
            var baseCol = (Color)theme.Base;
            baseCol.a *= 0.6f;
            cb.disabledColor    = baseCol;
            btn.colors = cb;
            btn.onClick.AddListener(() => onClick?.Invoke());

            // Pixel snapping on root & border to keep 1px borders even
            AttachPixelSnap(go.transform);
            AttachPixelSnap(borderGO.transform);

            // Layout sizing so buttons are visible in the stack
            var le = go.GetComponent<LayoutElement>();
            le.preferredWidth = 420;
            le.minHeight = BaseUIStyle.ButtonHeight;
            le.flexibleWidth = 0;
            le.flexibleHeight = 0;

            // Label
            var textGO = new GameObject("Label", typeof(RectTransform), typeof(CanvasRenderer), typeof(Text));
            textGO.transform.SetParent(go.transform, false);
            var trt = textGO.GetComponent<RectTransform>();
            trt.anchorMin = new Vector2(0, 0);
            trt.anchorMax = new Vector2(1, 1);
            trt.offsetMin = Vector2.zero; // true center
            trt.offsetMax = Vector2.zero;
            var txt = textGO.GetComponent<Text>();
            txt.text = label;
            txt.alignment = TextAnchor.MiddleCenter; // center-aligned labels
            txt.fontSize = BaseUIStyle.ButtonFontSize;
            txt.color = textColor;
            // Explicit font (avoid missing-font in builds)
            try { txt.font = Resources.GetBuiltinResource<Font>("Arial.ttf"); } catch {}
            txt.raycastTarget = false;
            txt.horizontalOverflow = HorizontalWrapMode.Overflow;
            txt.verticalOverflow = VerticalWrapMode.Truncate;
            // Subtle outline for readability over busy backgrounds
            var ol = textGO.AddComponent<Outline>();
            ol.effectColor = new Color(0,0,0,0.5f);
            ol.effectDistance = new Vector2(1f, -1f);

            // Explicit layer order (back -> front)
            fillGO.transform.SetSiblingIndex(0);
            borderGO.transform.SetSiblingIndex(1);
            textGO.transform.SetSiblingIndex(2);

            return btn;
        }

        // Toggle panel chrome (fill + border) without affecting layout or children
        public static void SetPanelDecorVisible(RectTransform panel, bool visible)
        {
            if (!panel) return;
            // Root image (should be disabled by CreatePanelSurface, but handle both cases)
            var rootImg = panel.GetComponent<Image>();
            if (rootImg) { rootImg.enabled = false; rootImg.raycastTarget = false; }

            // Child fill
            var fill = panel.Find("BG_Fill");
            if (fill) fill.gameObject.SetActive(visible);

            // Child border
            var border = panel.Find("Frame");
            if (border) border.gameObject.SetActive(visible);
        }

        /// <summary>
        /// Helper that creates a small bottom-right stacked panel (e.g., debug/info stack).
        /// Shrinks vertically to content.
        /// </summary>
        public static RectTransform CreateBottomRightStack(Transform parent, string name = "BottomRightStack")
        {
            // Explicit AutoHeight so behavior does not depend on CreatePanelSurface defaults
            var rt = CreatePanelSurface(parent, name, sizing: PanelSizing.AutoHeight);
            var le = rt.GetComponent<LayoutElement>() ?? rt.gameObject.AddComponent<LayoutElement>();
            le.flexibleWidth = 0f; le.flexibleHeight = 0f;
            // Anchor to bottom-right
            rt.anchorMin = new Vector2(1, 0);
            rt.anchorMax = new Vector2(1, 0);
            rt.pivot     = new Vector2(1, 0);
            rt.anchoredPosition = new Vector2(-12, 12);
            return rt;
        }

        // BACKGROUND IMAGE (full screen)
        public static Image CreateFullscreenBackground(Transform parent, Sprite sprite, Color fallbackColor)
        {
            var go = new GameObject("Background", typeof(RectTransform), typeof(CanvasRenderer), typeof(Image));
            go.transform.SetParent(parent, false);
            var rt = go.GetComponent<RectTransform>();
            rt.anchorMin = Vector2.zero;
            rt.anchorMax = Vector2.one;
            rt.offsetMin = Vector2.zero;
            rt.offsetMax = Vector2.zero;
            var img = go.GetComponent<Image>();
            if (sprite != null)
            {
                img.sprite = sprite;
                img.preserveAspect = true; // Background should not intercept clicks
                img.color = Color.white;
            }
            else
            {
                img.color = fallbackColor;
            }
            img.raycastTarget = false; // never block UI
            return img;
        }

        /// <summary>
        /// Attach a native uGUI Dropdown to an existing top-bar Button so it behaves like a menu.
        /// Uses Unity's built-in placement/flip/clamp via the Template hierarchy.
        /// </summary>
        public static Dropdown AttachDropdownToButton(Button button,
            IList<(string text, Action onClick)> items,
            float maxHeight = 320f,
            float minWidth = 220f)
        {
            if (button == null) throw new ArgumentNullException(nameof(button));
            if (items == null) throw new ArgumentNullException(nameof(items));

            var go = button.gameObject;
            var rt = go.GetComponent<RectTransform>();
            var img = go.GetComponent<Image>();
            if (img == null) img = go.AddComponent<Image>();

            // Ensure our default wood frame skin
            var frame = go.GetComponent<UIFrame>();
            if (frame == null) frame = go.AddComponent<UIFrame>();
            frame.SetEdges(true, true, true, true);

            // Find/create caption label
            Text caption = go.GetComponentInChildren<Text>();
            if (caption == null)
            {
                var captionGO = new GameObject("Label", typeof(RectTransform), typeof(Text));
                captionGO.transform.SetParent(go.transform, false);
                var crt = captionGO.GetComponent<RectTransform>();
                crt.anchorMin = new Vector2(0, 0);
                crt.anchorMax = new Vector2(1, 1);
                crt.offsetMin = new Vector2(8, 6);
                crt.offsetMax = new Vector2(-8, -6);
                caption = captionGO.GetComponent<Text>();
                caption.alignment = TextAnchor.MiddleCenter;
                caption.text = go.name;
            }
            string originalCaption = caption.text;

            // Dropdown component
            var dd = go.GetComponent<Dropdown>();
            if (dd == null) dd = go.AddComponent<Dropdown>();
            dd.targetGraphic = img;
            dd.captionText = caption;
            dd.interactable = true;

            // Template tree (as per Unity's expected structure)
            var templateGO = new GameObject("Template", typeof(RectTransform), typeof(Image), typeof(ScrollRect));
            templateGO.transform.SetParent(go.transform, false);
            var templateRT = templateGO.GetComponent<RectTransform>();
            // Anchor the template to the BOTTOM of the button so its TOP attaches to the button's bottom
            templateRT.anchorMin = new Vector2(0, 0);
            templateRT.anchorMax = new Vector2(1, 0);
            templateRT.pivot = new Vector2(0.5f, 1f);
            templateRT.sizeDelta = new Vector2(0, Mathf.Min(240f, maxHeight));
            templateGO.SetActive(false);

            var templateImg = templateGO.GetComponent<Image>();
            templateImg.raycastTarget = true;

            var viewportGO = new GameObject("Viewport", typeof(RectTransform), typeof(Image), typeof(Mask));
            viewportGO.transform.SetParent(templateGO.transform, false);
            var viewportRT = viewportGO.GetComponent<RectTransform>();
            viewportRT.anchorMin = new Vector2(0, 1);
            viewportRT.anchorMax = new Vector2(1, 1);
            viewportRT.pivot = new Vector2(0, 1);
            viewportRT.sizeDelta = new Vector2(0, 0);
            viewportGO.GetComponent<Image>().raycastTarget = true;
            viewportGO.GetComponent<Mask>().showMaskGraphic = false;

            var contentGO = new GameObject("Content", typeof(RectTransform), typeof(VerticalLayoutGroup));
            contentGO.transform.SetParent(viewportGO.transform, false);
            var contentRT = contentGO.GetComponent<RectTransform>();
            contentRT.anchorMin = new Vector2(0, 1);
            contentRT.anchorMax = new Vector2(1, 1);
            contentRT.pivot = new Vector2(0, 1);
            contentRT.anchoredPosition = Vector2.zero;
            var vlg = contentGO.GetComponent<VerticalLayoutGroup>();
            vlg.childForceExpandWidth = true;
            vlg.childForceExpandHeight = false;
            vlg.childControlWidth = true;
            vlg.childControlHeight = true;
            vlg.spacing = 2f;
            vlg.padding = new RectOffset(2, 2, 2, 2);

            var itemGO = new GameObject("Item", typeof(RectTransform), typeof(Toggle));
            itemGO.transform.SetParent(contentGO.transform, false);
            var itemRT = itemGO.GetComponent<RectTransform>();
            itemRT.anchorMin = new Vector2(0, 1);
            itemRT.anchorMax = new Vector2(1, 1);
            itemRT.pivot = new Vector2(0, 1);
            itemRT.sizeDelta = new Vector2(0, 28f);
            var itemToggle = itemGO.GetComponent<Toggle>();

            var itemLabelGO = new GameObject("Item Label", typeof(RectTransform), typeof(Text));
            itemLabelGO.transform.SetParent(itemGO.transform, false);
            var itemLabelRT = itemLabelGO.GetComponent<RectTransform>();
            itemLabelRT.anchorMin = new Vector2(0, 0);
            itemLabelRT.anchorMax = new Vector2(1, 1);
            itemLabelRT.offsetMin = new Vector2(10, 4);
            itemLabelRT.offsetMax = new Vector2(-10, -4);
            var itemLabel = itemLabelGO.GetComponent<Text>();
            itemLabel.alignment = TextAnchor.MiddleLeft;
            itemLabel.text = "Item";

            // ScrollRect wiring
            var sr = templateGO.GetComponent<ScrollRect>();
            sr.viewport = viewportRT;
            sr.content = contentRT;
            sr.horizontal = false;
            sr.vertical = true;

            // Dropdown wiring
            dd.template = templateRT;
            dd.itemText = itemLabel;
            dd.captionText = caption;

            // Width handling
            var le = go.GetComponent<LayoutElement>();
            if (le == null) le = go.AddComponent<LayoutElement>();
            le.minWidth = Mathf.Max(minWidth, le.minWidth);

            // Build options and action binder
            var opts = new List<Dropdown.OptionData>(items.Count);
            var binder = go.GetComponent<DropdownMenuBinder>();
            if (binder == null) binder = go.AddComponent<DropdownMenuBinder>();
            binder.Actions.Clear();
            foreach (var it in items)
            {
                opts.Add(new Dropdown.OptionData(it.text));
                binder.Actions.Add(it.onClick);
            }
            dd.options = opts;

            // Button opens dropdown list; keep visual skin
            button.onClick.RemoveAllListeners();
            button.onClick.AddListener(() => { dd.Show(); Debug.Log("[UICreator] Menu opened: " + originalCaption); });

            dd.onValueChanged.RemoveAllListeners();
            dd.onValueChanged.AddListener((idx) =>
            {
                if (idx >= 0 && idx < binder.Actions.Count)
                {
                    try { binder.Actions[idx]?.Invoke(); } catch (Exception e) { Debug.LogWarning("[UICreator] Menu item error: " + e.Message); }
                }
                // Reset caption so menu acts like a toolbar menu
                caption.text = originalCaption;
            });

            // Ensure pixel snap
            if (go.GetComponent<UIPixelSnap>() == null) go.AddComponent<UIPixelSnap>();

            return dd;
        }

        /// <summary>
        /// Ensure the RectTransform has a raycast-target Graphic so pointer events hit it.
        /// Adds an Image if no MaskableGraphic exists.
        /// </summary>
        public static void EnsureRaycastTarget(RectTransform rt)
        {
            if (rt == null) return;
            var g = rt.GetComponent<MaskableGraphic>();
            if (g == null) g = rt.gameObject.AddComponent<Image>();
            g.raycastTarget = true;
        }

    }

    // Stores actions for menu options created via AttachDropdownToButton
    internal sealed class DropdownMenuBinder : MonoBehaviour
    {
        public readonly List<Action> Actions = new List<Action>();
    }
}

// ===== FILE: Assets/Scripts/UI/Widgets/UIFrame.cs =====
using UnityEngine;
using UnityEngine.UI;
using FantasyColony.UI.Style;

namespace FantasyColony.UI.Widgets
{
    // Pixel-precise frame that guarantees identical edge thickness on all sides.
    // Renders four edge Images cut from the source 9-slice sprite; optional corner Images can be added later if needed.
    [ExecuteAlways]
    [DisallowMultipleComponent]
    public class UIFrame : MonoBehaviour
    {
        [SerializeField] private Sprite _sourceNineSlice; // your dark border 9-slice
        [SerializeField] private float _targetBorderPx = 1f; // in screen pixels
        [SerializeField] private Color _tint = Color.white;
        public bool ShowLeft = true, ShowRight = true, ShowTop = true, ShowBottom = true;

        // child images
        Image _top, _bottom, _left, _right;
        RectTransform _rt;
        Canvas _canvas;

        public void Init(Sprite nineSlice, float targetPx, Color tint)
        {
            _sourceNineSlice = nineSlice;
            _targetBorderPx = targetPx;
            _tint = tint;
            EnsureChildren();
            SetEdges(ShowLeft, ShowRight, ShowTop, ShowBottom);
            ApplyLook();
            LayoutNow();
        }

        void OnEnable()
        {
            _rt = GetComponent<RectTransform>();
            _canvas = GetComponentInParent<Canvas>();
            EnsureChildren();
            SetEdges(ShowLeft, ShowRight, ShowTop, ShowBottom);
            ApplyLook();
            LayoutNow();
        }

        void OnRectTransformDimensionsChange() => LayoutNow();
        void Update()
        {
#if UNITY_EDITOR
            // keep live in editor
            LayoutNow();
#endif
        }

        void EnsureChildren()
        {
            if (_rt == null) _rt = GetComponent<RectTransform>();
            if (_top == null) _top = CreateEdge("Top");
            if (_bottom == null) _bottom = CreateEdge("Bottom");
            if (_left == null) _left = CreateEdge("Left");
            if (_right == null) _right = CreateEdge("Right");
        }

        Image CreateEdge(string name)
        {
            var go = new GameObject(name, typeof(RectTransform), typeof(CanvasRenderer), typeof(Image));
            go.transform.SetParent(transform, false);
            var img = go.GetComponent<Image>();
            img.raycastTarget = false;
            return img;
        }

        void ApplyLook()
        {
            if (_sourceNineSlice == null) return;
            // Build sub-sprites for edges from the 9-slice source using its border rect.
            // Unity's Sprite.border order: (left, bottom, right, top)
            var b = _sourceNineSlice.border;
            var rect = _sourceNineSlice.rect;
            var tex = _sourceNineSlice.texture;
            var ppu = _sourceNineSlice.pixelsPerUnit;

            // Top strip (height = b.w, y starts at rect.yMax - b.w)
            _top.sprite = Sprite.Create(tex, new Rect(rect.x, rect.yMax - b.w, rect.width, b.w), new Vector2(0.5f, 1f), ppu, 0, SpriteMeshType.FullRect);
            // Bottom strip (height = b.y)
            _bottom.sprite = Sprite.Create(tex, new Rect(rect.x, rect.y, rect.width, b.y), new Vector2(0.5f, 0f), ppu, 0, SpriteMeshType.FullRect);
            // Left strip (width = b.x)
            _left.sprite = Sprite.Create(tex, new Rect(rect.x, rect.y, b.x, rect.height), new Vector2(0f, 0.5f), ppu, 0, SpriteMeshType.FullRect);
            // Right strip (width = b.z, x starts at rect.xMax - b.z)
            _right.sprite = Sprite.Create(tex, new Rect(rect.xMax - b.z, rect.y, b.z, rect.height), new Vector2(1f, 0.5f), ppu, 0, SpriteMeshType.FullRect);

            _top.color = _bottom.color = _left.color = _right.color = _tint;

            _top.type = _bottom.type = _left.type = _right.type = Image.Type.Tiled;
            _top.preserveAspect = _bottom.preserveAspect = _left.preserveAspect = _right.preserveAspect = false;
        }

        void LayoutNow()
        {
            if (_rt == null) _rt = GetComponent<RectTransform>();
            if (_rt == null || _top == null) return;

            float px = Mathf.Max(0.0f, _targetBorderPx);
            if (_canvas == null) _canvas = GetComponentInParent<Canvas>();
            float sf = (_canvas != null && _canvas.scaleFactor > 0f) ? _canvas.scaleFactor : 1f;
            // RectTransform sizes are specified in reference pixels. Under CanvasScaler.ScaleWithScreenSize,
            // device pixels = reference pixels * scaleFactor. Therefore to get N device pixels of thickness,
            // we set sizeDelta = N / scaleFactor. Do NOT include referencePixelsPerUnit here.
            float u = Mathf.Round(px) / sf;

            // Top
            var trt = _top.rectTransform;
            trt.anchorMin = new Vector2(0f, 1f);
            trt.anchorMax = new Vector2(1f, 1f);
            trt.pivot = new Vector2(0.5f, 1f);
            trt.anchoredPosition = Vector2.zero;
            trt.sizeDelta = new Vector2(0f, u);

            // Bottom
            var brt = _bottom.rectTransform;
            brt.anchorMin = new Vector2(0f, 0f);
            brt.anchorMax = new Vector2(1f, 0f);
            brt.pivot = new Vector2(0.5f, 0f);
            brt.anchoredPosition = Vector2.zero;
            brt.sizeDelta = new Vector2(0f, u);

            // Left
            var lrt = _left.rectTransform;
            lrt.anchorMin = new Vector2(0f, 0f);
            lrt.anchorMax = new Vector2(0f, 1f);
            lrt.pivot = new Vector2(0f, 0.5f);
            lrt.anchoredPosition = Vector2.zero;
            lrt.sizeDelta = new Vector2(u, 0f);

            // Right
            var rrt = _right.rectTransform;
            rrt.anchorMin = new Vector2(1f, 0f);
            rrt.anchorMax = new Vector2(1f, 1f);
            rrt.pivot = new Vector2(1f, 0.5f);
            rrt.anchoredPosition = Vector2.zero;
            rrt.sizeDelta = new Vector2(u, 0f);
        }

        public void SetEdges(bool left, bool right, bool top, bool bottom)
        {
            ShowLeft = left; ShowRight = right; ShowTop = top; ShowBottom = bottom;
            if (_left) _left.gameObject.SetActive(ShowLeft);
            if (_right) _right.gameObject.SetActive(ShowRight);
            if (_top) _top.gameObject.SetActive(ShowTop);
            if (_bottom) _bottom.gameObject.SetActive(ShowBottom);
        }
    }
}

// ===== FILE: Assets/Scripts/Util/TransformPathExtensions.cs =====
using UnityEngine;

namespace FantasyColony
{
    public static class TransformPathExtensions
    {
        // Helper for readable logs (Editor only usage).
        public static string GetHierarchyPath(this Transform t)
        {
            if (t == null) return "<null>";
            System.Text.StringBuilder sb = new System.Text.StringBuilder(t.name);
            var p = t.parent;
            while (p != null)
            {
                sb.Insert(0, "/");
                sb.Insert(0, p.name);
                p = p.parent;
            }
            return sb.ToString();
        }
    }
}

// ===== FILE: Assets/TutorialInfo/Scripts/Editor/ReadmeEditor.cs =====
﻿using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEditor;
using System;
using System.IO;
using System.Reflection;

[CustomEditor(typeof(Readme))]
[InitializeOnLoad]
public class ReadmeEditor : Editor
{
    static string s_ShowedReadmeSessionStateName = "ReadmeEditor.showedReadme";
    
    static string s_ReadmeSourceDirectory = "Assets/TutorialInfo";

    const float k_Space = 16f;

    static ReadmeEditor()
    {
        EditorApplication.delayCall += SelectReadmeAutomatically;
    }

    static void RemoveTutorial()
    {
        if (EditorUtility.DisplayDialog("Remove Readme Assets",
            
            $"All contents under {s_ReadmeSourceDirectory} will be removed, are you sure you want to proceed?",
            "Proceed",
            "Cancel"))
        {
            if (Directory.Exists(s_ReadmeSourceDirectory))
            {
                FileUtil.DeleteFileOrDirectory(s_ReadmeSourceDirectory);
                FileUtil.DeleteFileOrDirectory(s_ReadmeSourceDirectory + ".meta");
            }
            else
            {
                Debug.Log($"Could not find the Readme folder at {s_ReadmeSourceDirectory}");
            }

            var readmeAsset = SelectReadme();
            if (readmeAsset != null)
            {
                var path = AssetDatabase.GetAssetPath(readmeAsset);
                FileUtil.DeleteFileOrDirectory(path + ".meta");
                FileUtil.DeleteFileOrDirectory(path);
            }

            AssetDatabase.Refresh();
        }
    }

    static void SelectReadmeAutomatically()
    {
        if (!SessionState.GetBool(s_ShowedReadmeSessionStateName, false))
        {
            var readme = SelectReadme();
            SessionState.SetBool(s_ShowedReadmeSessionStateName, true);

            if (readme && !readme.loadedLayout)
            {
                LoadLayout();
                readme.loadedLayout = true;
            }
        }
    }

    static void LoadLayout()
    {
        var assembly = typeof(EditorApplication).Assembly;
        var windowLayoutType = assembly.GetType("UnityEditor.WindowLayout", true);
        var method = windowLayoutType.GetMethod("LoadWindowLayout", BindingFlags.Public | BindingFlags.Static);
        method.Invoke(null, new object[] { Path.Combine(Application.dataPath, "TutorialInfo/Layout.wlt"), false });
    }

    static Readme SelectReadme()
    {
        var ids = AssetDatabase.FindAssets("Readme t:Readme");
        if (ids.Length == 1)
        {
            var readmeObject = AssetDatabase.LoadMainAssetAtPath(AssetDatabase.GUIDToAssetPath(ids[0]));

            Selection.objects = new UnityEngine.Object[] { readmeObject };

            return (Readme)readmeObject;
        }
        else
        {
            Debug.Log("Couldn't find a readme");
            return null;
        }
    }

    protected override void OnHeaderGUI()
    {
        var readme = (Readme)target;
        Init();

        var iconWidth = Mathf.Min(EditorGUIUtility.currentViewWidth / 3f - 20f, 128f);

        GUILayout.BeginHorizontal("In BigTitle");
        {
            if (readme.icon != null)
            {
                GUILayout.Space(k_Space);
                GUILayout.Label(readme.icon, GUILayout.Width(iconWidth), GUILayout.Height(iconWidth));
            }
            GUILayout.Space(k_Space);
            GUILayout.BeginVertical();
            {

                GUILayout.FlexibleSpace();
                GUILayout.Label(readme.title, TitleStyle);
                GUILayout.FlexibleSpace();
            }
            GUILayout.EndVertical();
            GUILayout.FlexibleSpace();
        }
        GUILayout.EndHorizontal();
    }

    public override void OnInspectorGUI()
    {
        var readme = (Readme)target;
        Init();

        foreach (var section in readme.sections)
        {
            if (!string.IsNullOrEmpty(section.heading))
            {
                GUILayout.Label(section.heading, HeadingStyle);
            }

            if (!string.IsNullOrEmpty(section.text))
            {
                GUILayout.Label(section.text, BodyStyle);
            }

            if (!string.IsNullOrEmpty(section.linkText))
            {
                if (LinkLabel(new GUIContent(section.linkText)))
                {
                    Application.OpenURL(section.url);
                }
            }

            GUILayout.Space(k_Space);
        }

        if (GUILayout.Button("Remove Readme Assets", ButtonStyle))
        {
            RemoveTutorial();
        }
    }

    bool m_Initialized;

    GUIStyle LinkStyle
    {
        get { return m_LinkStyle; }
    }

    [SerializeField]
    GUIStyle m_LinkStyle;

    GUIStyle TitleStyle
    {
        get { return m_TitleStyle; }
    }

    [SerializeField]
    GUIStyle m_TitleStyle;

    GUIStyle HeadingStyle
    {
        get { return m_HeadingStyle; }
    }

    [SerializeField]
    GUIStyle m_HeadingStyle;

    GUIStyle BodyStyle
    {
        get { return m_BodyStyle; }
    }

    [SerializeField]
    GUIStyle m_BodyStyle;

    GUIStyle ButtonStyle
    {
        get { return m_ButtonStyle; }
    }

    [SerializeField]
    GUIStyle m_ButtonStyle;

    void Init()
    {
        if (m_Initialized)
            return;
        m_BodyStyle = new GUIStyle(EditorStyles.label);
        m_BodyStyle.wordWrap = true;
        m_BodyStyle.fontSize = 14;
        m_BodyStyle.richText = true;

        m_TitleStyle = new GUIStyle(m_BodyStyle);
        m_TitleStyle.fontSize = 26;

        m_HeadingStyle = new GUIStyle(m_BodyStyle);
        m_HeadingStyle.fontStyle = FontStyle.Bold;
        m_HeadingStyle.fontSize = 18;

        m_LinkStyle = new GUIStyle(m_BodyStyle);
        m_LinkStyle.wordWrap = false;

        // Match selection color which works nicely for both light and dark skins
        m_LinkStyle.normal.textColor = new Color(0x00 / 255f, 0x78 / 255f, 0xDA / 255f, 1f);
        m_LinkStyle.stretchWidth = false;

        m_ButtonStyle = new GUIStyle(EditorStyles.miniButton);
        m_ButtonStyle.fontStyle = FontStyle.Bold;

        m_Initialized = true;
    }

    bool LinkLabel(GUIContent label, params GUILayoutOption[] options)
    {
        var position = GUILayoutUtility.GetRect(label, LinkStyle, options);

        Handles.BeginGUI();
        Handles.color = LinkStyle.normal.textColor;
        Handles.DrawLine(new Vector3(position.xMin, position.yMax), new Vector3(position.xMax, position.yMax));
        Handles.color = Color.white;
        Handles.EndGUI();

        EditorGUIUtility.AddCursorRect(position, MouseCursor.Link);

        return GUI.Button(position, label, LinkStyle);
    }
}

// ===== FILE: Assets/TutorialInfo/Scripts/Readme.cs =====
﻿using System;
using UnityEngine;

public class Readme : ScriptableObject
{
    public Texture2D icon;
    public string title;
    public Section[] sections;
    public bool loadedLayout;

    [Serializable]
    public class Section
    {
        public string heading, text, linkText, url;
    }
}

// ===== FILE: Tools/XmlDefsTools/Emit/SchemaCatalogWriter.cs =====
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Xml.Linq;
using XmlDefsTools.Scan;
using XmlDefsTools.Util;

namespace XmlDefsTools.Emit
{
    /// <summary>
    /// Writes a consolidated catalog file listing all schemas,
    /// their union of attributes and elements, and a canonical template
    /// sample for each schema.
    /// </summary>
    public static class SchemaCatalogWriter
    {
        public static void Write(string outputDir, ScanResult scan,
            IReadOnlyDictionary<string, IList<string>> orderHints)
        {
            Directory.CreateDirectory(outputDir);
            var outPath = Path.Combine(outputDir, "_AllSchemas.xml");

            var configuredSchemas = orderHints.Keys
                .Where(k => !string.Equals(k, "_common", StringComparison.OrdinalIgnoreCase)
                    && !k.StartsWith("//"))
                .ToHashSet(StringComparer.OrdinalIgnoreCase);
            var allSchemas = new HashSet<string>(scan.Schemas, StringComparer.OrdinalIgnoreCase);
            foreach (var s in configuredSchemas) allSchemas.Add(s);

            var doc = new XDocument(
                new XElement("DefSchemas",
                    new XAttribute("generated",
                        DateTime.UtcNow.ToString("yyyy-MM-ddTHH:mm:ssZ")))
            );

            var common = orderHints.TryGetValue("_common", out var commonOrder)
                ? commonOrder
                : Array.Empty<string>();

            foreach (var schema in allSchemas.OrderBy(s => s, StringComparer.OrdinalIgnoreCase))
            {
                var perSchema = orderHints.TryGetValue(schema, out var per)
                    ? per : Array.Empty<string>();
                var precedence = common.Concat(perSchema).ToList();

                // Collect union of fields from discovered defs
                var attrFields = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
                var elemFields = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
                if (scan.DefsBySchema.TryGetValue(schema, out var defs))
                {
                    foreach (var d in defs)
                    {
                        foreach (var a in d.AttributeFields) attrFields.Add(a);
                        foreach (var e in d.ElementFields) elemFields.Add(e);
                    }
                }

                // Seed with configured fields
                foreach (var hinted in perSchema) elemFields.Add(hinted);

                // Attributes for root + ordered element list
                var rootAttrs = NormalizeOrder(attrFields, precedence,
                    keepOnly: new[] { "id", "schema", "name_key", "tags", "version", "requires" });
                var elementNames = NormalizeOrder(
                    elemFields.Except(rootAttrs, StringComparer.OrdinalIgnoreCase), precedence);

                // Build a canonical template element (same rules as TemplateSynthesizer)
                var root = new XElement(schema);
                foreach (var a in rootAttrs)
                {
                    var placeholder = a.Equals("id", StringComparison.OrdinalIgnoreCase) ? "your_id_here"
                        : a.Equals("name_key", StringComparison.OrdinalIgnoreCase) ? "ui.your.key.here"
                        : a.Equals("tags", StringComparison.OrdinalIgnoreCase) ? string.Empty
                        : a.Equals("version", StringComparison.OrdinalIgnoreCase) ? "1"
                        : string.Empty;
                    root.SetAttributeValue(a, placeholder);
                }

                bool HasElem(string name) =>
                    elementNames.Any(n => n.Equals(name, StringComparison.OrdinalIgnoreCase));
                if (HasElem("version") && root.Attribute("version") == null)
                    root.Add(new XElement("version", "1"));
                if (HasElem("requires") && root.Attribute("requires") == null)
                    root.Add(new XElement("requires"));
                if (HasElem("components") ||
                    perSchema.Contains("components", StringComparer.OrdinalIgnoreCase))
                {
                    root.Add(new XElement("components",
                        new XComment(" Add component entries like <Component type=\"...\"/> ")));
                }
                foreach (var el in elementNames)
                {
                    if (string.Equals(el, "components", StringComparison.OrdinalIgnoreCase))
                        continue;
                    if (string.Equals(el, "version", StringComparison.OrdinalIgnoreCase)
                        && root.Elements("version").Any())
                        continue;
                    if (string.Equals(el, "requires", StringComparison.OrdinalIgnoreCase)
                        && root.Elements("requires").Any())
                        continue;
                    root.Add(new XElement(el));
                }
                var canonicalElement = CanonicalXml.CanonicalizeElement(root);

                // Compose catalog node
                var schemaNode = new XElement("Schema",
                    new XAttribute("name", schema),
                    new XElement("Attributes",
                        rootAttrs.Select(a => new XElement("Attr", new XAttribute("name", a)))),
                    new XElement("Elements",
                        elementNames.Select(e => new XElement("El", new XAttribute("name", e)))),
                    new XElement("Template", canonicalElement));

                doc.Root!.Add(schemaNode);
            }

            doc.Save(outPath);
        }

        private static List<string> NormalizeOrder(IEnumerable<string> names,
            IList<string> precedence, IEnumerable<string>? keepOnly = null)
        {
            var all = new HashSet<string>(names, StringComparer.OrdinalIgnoreCase);
            if (keepOnly != null)
            {
                var keep = new HashSet<string>(keepOnly, StringComparer.OrdinalIgnoreCase);
                all.RemoveWhere(n => !keep.Contains(n));
            }

            var ordered = new List<string>();
            foreach (var p in precedence)
            {
                if (all.Remove(p)) ordered.Add(p);
            }
            ordered.AddRange(all.OrderBy(n => n, StringComparer.OrdinalIgnoreCase));
            return ordered;
        }
    }
}


// ===== FILE: Tools/XmlDefsTools/Emit/TemplateSynthesizer.cs =====
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Xml.Linq;
using XmlDefsTools.Scan;
using XmlDefsTools.Util;

namespace XmlDefsTools.Emit
{
    public static class TemplateSynthesizer
    {
        public static void WriteTemplates(string outputDir, ScanResult scan, IReadOnlyDictionary<string, IList<string>> orderHints)
        {
            Directory.CreateDirectory(outputDir);
            // union of discovered schemas and configured schemas (ensures baseline output)
            var configuredSchemas = orderHints.Keys
                .Where(k => !string.Equals(k, "_common", StringComparison.OrdinalIgnoreCase) && !k.StartsWith("//"))
                .ToHashSet(StringComparer.OrdinalIgnoreCase);
            var allSchemas = new HashSet<string>(scan.Schemas, StringComparer.OrdinalIgnoreCase);
            foreach (var s in configuredSchemas) allSchemas.Add(s);

            foreach (var schema in allSchemas.OrderBy(s => s))
            {
                // if no defs discovered, synthesize from hints only
                var defs = scan.DefsBySchema.ContainsKey(schema)
                    ? scan.DefsBySchema[schema]
                    : new List<DefInfo>();

                // union of observed fields (attributes + elements)
                var attrFields = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
                var elemFields = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
                // include configured per-schema fields as elements to seed structure
                if (orderHints.TryGetValue(schema, out var hinted))
                {
                    foreach (var h in hinted) elemFields.Add(h);
                }
                foreach (var d in defs)
                {
                    foreach (var f in d.AttributeFields) attrFields.Add(f);
                    foreach (var f in d.ElementFields) elemFields.Add(f);
                }

                // known/common order
                var common = orderHints.TryGetValue("_common", out var c) ? c : Array.Empty<string>();
                var perSchema = orderHints.TryGetValue(schema, out var s) ? s : Array.Empty<string>();
                var precedence = common.Concat(perSchema).ToList();

                // Attributes to place on root element
                var rootAttrs = NormalizeOrder(attrFields, precedence, keepOnly: new[] { "id","schema","name_key","tags","version","requires" });
                // Remaining element fields (drop those already in attributes)
                var elementNames = NormalizeOrder(elemFields.Except(rootAttrs, StringComparer.OrdinalIgnoreCase),
                                                  precedence);

                bool HasElem(string name) => elementNames.Any(n => n.Equals(name, StringComparison.OrdinalIgnoreCase));

                var sb = new StringBuilder();
                sb.AppendLine($"<!-- Auto-generated default template for {schema}. Edit your copies; this file is regenerated. -->");

                var root = new XElement(schema);
                // Put attributes with placeholders
                foreach (var a in rootAttrs)
                {
                    var placeholder = a.Equals("id", StringComparison.OrdinalIgnoreCase) ? "your_id_here"
                                   : a.Equals("name_key", StringComparison.OrdinalIgnoreCase) ? "ui.your.key.here"
                                   : a.Equals("tags", StringComparison.OrdinalIgnoreCase) ? ""
                                   : a.Equals("version", StringComparison.OrdinalIgnoreCase) ? "1"
                                   : "";
                    root.SetAttributeValue(a, placeholder);
                }

                // Insert version/requires as elements too if heavily used as elements
                if (HasElem("version") && root.Attribute("version") == null)
                    root.Add(new XElement("version", "1"));
                if (HasElem("requires") && root.Attribute("requires") == null)
                    root.Add(new XElement("requires"));

                // Components block if observed
                if (HasElem("components") || perSchema.Contains("components", StringComparer.OrdinalIgnoreCase))
                {
                    root.Add(new XElement("components",
                        new XComment(" Add component entries like <Component type=\"...\"/> ")));
                }

                // Other fields as empty elements
                foreach (var el in elementNames)
                {
                    if (string.Equals(el, "components", StringComparison.OrdinalIgnoreCase)) continue;
                    if (string.Equals(el, "version", StringComparison.OrdinalIgnoreCase) && root.Elements("version").Any()) continue;
                    if (string.Equals(el, "requires", StringComparison.OrdinalIgnoreCase) && root.Elements("requires").Any()) continue;
                    root.Add(new XElement(el));
                }

                // Canonicalize attribute order
                var canonical = CanonicalXml.CanonicalizeElement(root);
                sb.AppendLine(canonical.ToString(SaveOptions.None));

                var outPath = Path.Combine(outputDir, $"{schema}.xml");
                File.WriteAllText(outPath, sb.ToString());
            }
        }

        private static List<string> NormalizeOrder(IEnumerable<string> names, IList<string> precedence, IEnumerable<string>? keepOnly = null)
        {
            var all = new HashSet<string>(names, StringComparer.OrdinalIgnoreCase);
            if (keepOnly != null)
            {
                var keep = new HashSet<string>(keepOnly, StringComparer.OrdinalIgnoreCase);
                all.RemoveWhere(n => !keep.Contains(n));
            }
            var ordered = new List<string>();
            foreach (var p in precedence)
            {
                if (all.Remove(p)) ordered.Add(p);
            }
            ordered.AddRange(all.OrderBy(n => n, StringComparer.OrdinalIgnoreCase));
            return ordered;
        }
    }
}

// ===== FILE: Tools/XmlDefsTools/Emit/XmlIndexWriter.cs =====
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using XmlDefsTools.Scan;

namespace XmlDefsTools.Emit
{
    public static class XmlIndexWriter
    {
        public static void Write(string repoRoot, string outFile, ScanResult scan)
        {
            var sb = new StringBuilder();
            sb.AppendLine("# XML Index (.xml)");
            sb.AppendLine();
            sb.AppendLine($"_Generated: {DateTime.UtcNow:yyyy-MM-dd HH:mm} UTC_");
            sb.AppendLine();
            sb.AppendLine($"**Total files scanned:** {scan.TotalFiles}  ");
            sb.AppendLine($"**Valid XML files:** {scan.ValidFiles}  ");
            sb.AppendLine($"**Defs discovered:** {scan.TotalDefs}  ");
            sb.AppendLine();

            if (scan.Errors.Any())
            {
                sb.AppendLine("## Parse Errors");
                foreach (var err in scan.Errors)
                {
                    sb.AppendLine($"- `{Rel(repoRoot, err.File)}` — {err.Message}");
                }
                sb.AppendLine();
            }

            if (scan.DuplicateIds.Any())
            {
                sb.AppendLine("## Duplicate IDs");
                foreach (var kvp in scan.DuplicateIds.OrderBy(k => k.Key, StringComparer.OrdinalIgnoreCase))
                {
                    sb.AppendLine($"- **{kvp.Key}**");
                    foreach (var item in kvp.Value)
                    {
                        sb.AppendLine($"  - `{item.Schema}` in `{Rel(repoRoot, item.SourceFile)}`");
                    }
                }
                sb.AppendLine();
            }

            // Match Code Index style: bulleted list of files with View · Raw links
            var (repo, branch) = RepoMeta();
            var allXmlFiles = scan.FileDocs.Keys.OrderBy(p => p, StringComparer.OrdinalIgnoreCase).ToList();
            if (allXmlFiles.Count > 0)
            {
                foreach (var file in allXmlFiles)
                {
                    var rel = Rel(repoRoot, file);
                    var webPath = rel.Replace('\\','/'); // ensure URL form
                    var enc = EncodePathSegments(webPath);
                    var viewUrl = $"https://github.com/{repo}/blob/{branch}/{enc}";
                    var rawUrl  = $"https://raw.githubusercontent.com/{repo}/{branch}/{enc}";
                    sb.AppendLine($"- `{webPath}` — [View]({viewUrl}) · [Raw]({rawUrl})");
                }
                sb.AppendLine();
            }

            // Keep the schema summary (below the list) for quick counts
            sb.AppendLine("## Summary by Schema");
            sb.AppendLine();
            sb.AppendLine("| Schema | Def Count | Files |");
            sb.AppendLine("|---|---:|---|");
            foreach (var schema in scan.Schemas.OrderBy(s => s))
            {
                var defs = scan.DefsBySchema[schema];
                var files = defs.Select(d => Rel(repoRoot, d.SourceFile)).Distinct().OrderBy(s => s);
                sb.AppendLine($"| {schema} | {defs.Count} | {string.Join("<br/>", files)} |");
            }
            sb.AppendLine();

            // Per-schema sections unchanged below (list ids + rare fields)

            foreach (var schema in scan.Schemas.OrderBy(s => s))
            {
                var defs = scan.DefsBySchema[schema];
                sb.AppendLine($"### {schema}");
                sb.AppendLine();
                foreach (var d in defs.OrderBy(d => d.Id, StringComparer.OrdinalIgnoreCase))
                {
                    sb.AppendLine($"- `{d.Id}` — `{Rel(repoRoot, d.SourceFile)}`");
                }
                // Any newly observed/rare fields
                var fieldCounts = new Dictionary<string,int>(StringComparer.OrdinalIgnoreCase);
                foreach (var d in defs)
                {
                    foreach (var f in d.AttributeFields.Concat(d.ElementFields))
                        fieldCounts[f] = fieldCounts.TryGetValue(f, out var c) ? c + 1 : 1;
                }
                var rare = fieldCounts.Where(kvp => kvp.Value <= Math.Max(1, defs.Count/5)).Select(kvp => kvp.Key).OrderBy(s=>s, StringComparer.OrdinalIgnoreCase).ToList();
                if (rare.Count > 0)
                {
                    sb.AppendLine();
                    sb.AppendLine("<details><summary>Less common fields</summary>");
                    sb.AppendLine();
                    foreach (var f in rare) sb.AppendLine($"- `{f}`");
                    sb.AppendLine();
                    sb.AppendLine("</details>");
                }
                sb.AppendLine();
            }

            Directory.CreateDirectory(Path.GetDirectoryName(outFile)!);
            File.WriteAllText(outFile, sb.ToString());
        }

        // Encode each path segment to avoid corrupting '/' and handle special characters safely.
        private static string EncodePathSegments(string path)
        {
            var parts = path.Replace('\\','/').Split(new[]{'/'}, StringSplitOptions.RemoveEmptyEntries);
            var encoded = parts.Select(Uri.EscapeDataString);
            return string.Join("/", encoded);
        }

        private static (string repo, string branch) RepoMeta()
        {
            var repo = Environment.GetEnvironmentVariable("GITHUB_REPOSITORY");
            if (string.IsNullOrWhiteSpace(repo)) repo = "Natangry/FantasyColony";
            var branch = Environment.GetEnvironmentVariable("GITHUB_REF_NAME");
            if (string.IsNullOrWhiteSpace(branch)) branch = "main";
            // strip refs/heads/ if present
            branch = branch.Replace("refs/heads/", "");
            return (repo, branch);
        }

        private static string Rel(string root, string path)
        {
            try
            {
                var rp = Path.GetRelativePath(root, path).Replace('\\','/');
                return rp;
            }
            catch
            {
                return path.Replace('\\','/');
            }
        }
    }
}

// ===== FILE: Tools/XmlDefsTools/Emit/XmlSnapshotWriter.cs =====
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Xml.Linq;
using XmlDefsTools.Util;

namespace XmlDefsTools.Emit
{
    public static class XmlSnapshotWriter
    {
        public static void Write(string repoRoot, string outFile, IEnumerable<(string path, XDocument? doc)> docs)
        {
            var sb = new StringBuilder();
            foreach (var (path, doc) in docs.OrderBy(t => t.path, StringComparer.OrdinalIgnoreCase))
            {
                sb.AppendLine($"// ===== FILE: {Rel(repoRoot, path)} =====");
                if (doc == null)
                {
                    sb.AppendLine("// (invalid XML)");
                    sb.AppendLine();
                    continue;
                }
                var normalized = CanonicalXml.Canonicalize(doc);
                sb.AppendLine(normalized);
                sb.AppendLine();
            }
            File.WriteAllText(outFile, sb.ToString());
        }

        private static string Rel(string root, string path)
        {
            try
            {
                var rp = Path.GetRelativePath(root, path).Replace('\\','/');
                return rp;
            }
            catch
            {
                return path.Replace('\\','/');
            }
        }
    }
}

// ===== FILE: Tools/XmlDefsTools/Program.cs =====
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text.Json;
using XmlDefsTools.Emit;
using XmlDefsTools.Scan;

namespace XmlDefsTools
{
    internal static class Program
    {
        private static int Main(string[] args)
        {
            try
            {
                var repoRoot = GetRepoRoot();
                var defsDir = GetDefsDir(repoRoot);
                Console.WriteLine($"[XmlDefsTools] Repo root: {repoRoot}");
                Console.WriteLine($"[XmlDefsTools] Defs dir : {defsDir}");

                var scanner = new XmlDefScanner();
                var scan = scanner.Scan(defsDir);

                // Load order hints
                var hintsPath = Path.Combine(repoRoot, "Tools", "XmlDefsTools", "Config", "SchemaOrder.json");
                var orderHints = File.Exists(hintsPath)
                    ? JsonSerializer.Deserialize<Dictionary<string, IList<string>>>(File.ReadAllText(hintsPath))
                    : new Dictionary<string, IList<string>>(StringComparer.OrdinalIgnoreCase);
                orderHints ??= new Dictionary<string, IList<string>>(StringComparer.OrdinalIgnoreCase);

                // Write index
                var indexPath = Path.Combine(repoRoot, "XML_INDEX.md");
                XmlIndexWriter.Write(repoRoot, indexPath, scan);
                Console.WriteLine($"[XmlDefsTools] Wrote index: {indexPath}");

                // Write snapshot
                var snapshotPath = Path.Combine(repoRoot, "XML_SNAPSHOT.txt");
                var docs = scan.FileDocs.Select(kvp => (kvp.Key, kvp.Value));
                XmlSnapshotWriter.Write(repoRoot, snapshotPath, docs);
                Console.WriteLine($"[XmlDefsTools] Wrote snapshot: {snapshotPath}");

                // Write templates
                var templatesDir = Path.Combine(repoRoot, "Docs", "Templates", "Defs");
                TemplateSynthesizer.WriteTemplates(templatesDir, scan, orderHints);
                Console.WriteLine($"[XmlDefsTools] Wrote templates to: {templatesDir}");

                // Write consolidated schema catalog
                SchemaCatalogWriter.Write(templatesDir, scan, orderHints);
                Console.WriteLine($"[XmlDefsTools] Wrote consolidated catalog: {Path.Combine(templatesDir, "_AllSchemas.xml")}");

                return 0;
            }
            catch (Exception ex)
            {
                Console.Error.WriteLine(ex.ToString());
                return 1;
            }
        }

        private static string GetRepoRoot()
        {
            var env = Environment.GetEnvironmentVariable("FC_REPO_ROOT");
            if (!string.IsNullOrWhiteSpace(env))
                return Path.GetFullPath(env);
            // assume current working directory is repo root (CI) or a subfolder (local)
            var cwd = Directory.GetCurrentDirectory();
            // try to find .git upwards
            var dir = new DirectoryInfo(cwd);
            while (dir != null)
            {
                if (Directory.Exists(Path.Combine(dir.FullName, ".git")))
                    return dir.FullName;
                dir = dir.Parent;
            }
            return cwd;
        }

        private static string GetDefsDir(string repoRoot)
        {
            var env = Environment.GetEnvironmentVariable("FC_DEFS_DIR");
            if (!string.IsNullOrWhiteSpace(env))
            {
                var p = Path.IsPathRooted(env) ? env : Path.Combine(repoRoot, env);
                return Directory.Exists(p) ? p : repoRoot;
            }
            var candidates = new[]
            {
                Path.Combine(repoRoot, "StreamingAssets", "Defs"),
                Path.Combine(repoRoot, "Assets", "StreamingAssets", "Defs"),
                Path.Combine(repoRoot, "GameData", "Defs")
            };
            foreach (var c in candidates)
                if (Directory.Exists(c)) return c;
            // fallback: repo root (will scan, find no files, still emit artifacts)
            return repoRoot;
        }
    }
}

// ===== FILE: Tools/XmlDefsTools/Scan/XmlDefScanner.cs =====
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Xml;
using System.Xml.Linq;

namespace XmlDefsTools.Scan
{
    public sealed class XmlDefScanner
    {
        public ScanResult Scan(string rootDir)
        {
            var res = new ScanResult();
            if (!Directory.Exists(rootDir))
                return res;

            var files = Directory.EnumerateFiles(rootDir, "*.xml", SearchOption.AllDirectories).ToList();
            res.TotalFiles = files.Count;
            foreach (var file in files)
            {
                XDocument? doc = null;
                try
                {
                    var text = File.ReadAllText(file);
                    doc = XDocument.Parse(text, LoadOptions.PreserveWhitespace | LoadOptions.SetLineInfo);
                    res.ValidFiles++;
                    res.FileDocs[file] = doc;
                }
                catch (Exception ex)
                {
                    res.Errors.Add(new ScanError { File = file, Message = ex.GetBaseException().Message });
                    res.FileDocs[file] = null;
                    continue;
                }

                // Collect defs: any element with an 'id' attribute
                var defs = doc.Descendants()
                    .Where(e => e.NodeType == System.Xml.XmlNodeType.Element)
                    .OfType<XElement>()
                    .Where(e => e.Attribute("id") != null)
                    .ToList();

                foreach (var el in defs)
                {
                    var schema = el.Name.LocalName;
                    var id = (string?)el.Attribute("id") ?? "(missing)";
                    var info = new DefInfo
                    {
                        Schema = schema,
                        Id = id,
                        SourceFile = file
                    };

                    // Attribute fields (names only)
                    foreach (var a in el.Attributes())
                    {
                        if (a.IsNamespaceDeclaration) continue;
                        info.AttributeFields.Add(a.Name.LocalName);
                    }

                    // Element fields (direct child element names only)
                    foreach (var child in el.Elements())
                    {
                        info.ElementFields.Add(child.Name.LocalName);
                    }

                    res.TotalDefs++;
                    if (!res.DefsBySchema.TryGetValue(schema, out var list))
                    {
                        list = new List<DefInfo>();
                        res.DefsBySchema[schema] = list;
                        res.Schemas.Add(schema);
                    }
                    list.Add(info);

                    // Track duplicates
                    var dupKey = $"{schema}:{id}";
                    if (!res.DuplicateIds.TryGetValue(dupKey, out var dupList))
                    {
                        dupList = new List<DefInfo>();
                        res.DuplicateIds[dupKey] = dupList;
                    }
                    dupList.Add(info);
                }
            }

            // Remove entries that are not actually duplicates (only one occurrence)
            var toPrune = res.DuplicateIds.Where(kvp => kvp.Value.Count <= 1)
                                          .Select(kvp => kvp.Key).ToList();
            foreach (var k in toPrune) res.DuplicateIds.Remove(k);

            return res;
        }
    }

    public sealed class ScanResult
    {
        public int TotalFiles { get; set; }
        public int ValidFiles { get; set; }
        public int TotalDefs { get; set; }
        public HashSet<string> Schemas { get; } = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
        public Dictionary<string, List<DefInfo>> DefsBySchema { get; } = new Dictionary<string, List<DefInfo>>(StringComparer.OrdinalIgnoreCase);
        public List<ScanError> Errors { get; } = new List<ScanError>();
        public Dictionary<string, XDocument?> FileDocs { get; } = new Dictionary<string, XDocument?>(StringComparer.OrdinalIgnoreCase);
        public Dictionary<string, List<DefInfo>> DuplicateIds { get; } = new Dictionary<string, List<DefInfo>>(StringComparer.OrdinalIgnoreCase);
    }

    public sealed class DefInfo
    {
        public string Schema { get; set; } = "";
        public string Id { get; set; } = "";
        public string SourceFile { get; set; } = "";
        public HashSet<string> AttributeFields { get; } = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
        public HashSet<string> ElementFields { get; } = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
    }

    public sealed class ScanError
    {
        public string File { get; set; } = "";
        public string Message { get; set; } = "";
    }
}

// ===== FILE: Tools/XmlDefsTools/Util/CanonicalXml.cs =====
using System;
using System.IO;
using System.Linq;
using System.Text;
using System.Xml;
using System.Xml.Linq;

namespace XmlDefsTools.Util
{
    public static class CanonicalXml
    {
        private static readonly string[] AttributePrecedence =
        {
            "id","schema","name_key","tags","version","requires"
        };

        public static string Canonicalize(XDocument doc)
        {
            // Remove comments
            foreach (var c in doc.DescendantNodes().OfType<XComment>().ToList())
                c.Remove();

            // Canonicalize elements & attributes
            var root = CanonicalizeElement(doc.Root!);
            var newDoc = new XDocument(root);

            // Save with stable formatting
            var settings = new XmlWriterSettings
            {
                OmitXmlDeclaration = true,
                Indent = true,
                NewLineOnAttributes = false
            };
            var sb = new StringBuilder();
            using (var writer = XmlWriter.Create(sb, settings))
            {
                newDoc.Save(writer);
            }
            return sb.ToString().Trim() + Environment.NewLine;
        }

        public static XElement CanonicalizeElement(XElement el)
        {
            var orderedAttrs = el.Attributes()
                .Where(a => !a.IsNamespaceDeclaration)
                .OrderBy(a => OrderKey(a.Name.LocalName))
                .ThenBy(a => a.Name.LocalName, StringComparer.OrdinalIgnoreCase)
                .ToList();

            var newEl = new XElement(el.Name);
            foreach (var a in orderedAttrs)
                newEl.SetAttributeValue(a.Name.LocalName, a.Value);

            foreach (var node in el.Nodes())
            {
                if (node is XElement child)
                {
                    newEl.Add(CanonicalizeElement(child));
                }
                else if (node is XText t)
                {
                    var v = t.Value;
                    if (!string.IsNullOrWhiteSpace(v))
                        newEl.Add(new XText(NormalizeWhitespace(v)));
                }
                // other node types (comments, processing instructions) are skipped
            }
            return newEl;
        }

        private static int OrderKey(string name)
        {
            for (int i = 0; i < AttributePrecedence.Length; i++)
                if (name.Equals(AttributePrecedence[i], StringComparison.OrdinalIgnoreCase))
                    return i - 1000; // bubble to front
            return 0;
        }

        private static string NormalizeWhitespace(string s)
        {
            // Collapse internal whitespace sequences
            var arr = s.ToCharArray();
            var sb = new StringBuilder(arr.Length);
            bool inWs = false;
            foreach (var ch in arr)
            {
                if (char.IsWhiteSpace(ch))
                {
                    if (!inWs)
                    {
                        sb.Append(' ');
                        inWs = true;
                    }
                }
                else
                {
                    sb.Append(ch);
                    inWs = false;
                }
            }
            return sb.ToString().Trim();
        }
    }
}

